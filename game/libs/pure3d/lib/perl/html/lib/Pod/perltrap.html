    <HTML> 
	<HEAD> 
	    <TITLE>perltrap - Perl traps for the unwary

</TITLE> 
	</HEAD>

	<BODY>

<!-- INDEX BEGIN -->

<UL>

	<LI><A HREF="#NAME">NAME</A>
	<LI><A HREF="#DESCRIPTION">DESCRIPTION</A>
	<UL>

		<LI><A HREF="#Awk_Traps">Awk Traps</A>
		<LI><A HREF="#C_Traps">C Traps</A>
		<LI><A HREF="#Sed_Traps">Sed Traps</A>
		<LI><A HREF="#Shell_Traps">Shell Traps</A>
		<LI><A HREF="#Perl_Traps">Perl Traps</A>
		<LI><A HREF="#Perl4_to_Perl5_Traps">Perl4 to Perl5 Traps</A>
		<LI><A HREF="#Discontinuance_Deprecation_and">Discontinuance, Deprecation, and BugFix traps</A>
		<LI><A HREF="#Parsing_Traps">Parsing Traps</A>
		<LI><A HREF="#Numerical_Traps">Numerical Traps</A>
		<LI><A HREF="#General_data_type_traps">General data type traps</A>
		<LI><A HREF="#Context_Traps_scalar_list_con">Context Traps - scalar, list contexts</A>
		<LI><A HREF="#Precedence_Traps">Precedence Traps</A>
		<LI><A HREF="#General_Regular_Expression_Traps">General Regular Expression Traps using s///, etc.</A>
		<LI><A HREF="#Subroutine_Signal_Sorting_Trap">Subroutine, Signal, Sorting Traps</A>
		<LI><A HREF="#OS_Traps">OS Traps</A>
		<LI><A HREF="#Interpolation_Traps">Interpolation Traps</A>
		<LI><A HREF="#DBM_Traps">DBM Traps</A>
		<LI><A HREF="#Unclassified_Traps">Unclassified Traps</A>
	</UL>

</UL>
<!-- INDEX END -->

<HR>
<P>
<H1><A NAME="NAME">NAME

</A></H1>
perltrap - Perl traps for the unwary


<P>

<P>
<HR>
<H1><A NAME="DESCRIPTION">DESCRIPTION

</A></H1>
The biggest trap of all is forgetting to use the <STRONG>-w</STRONG> switch; see
<A HREF="/n|/perl/html/./lib/Pod/perlrun.html#">the perlrun manpage</A>. The second biggest trap is not making your entire program runnable under <CODE>use strict</CODE>. The third biggest trap is not reading the list of changes in this version
of Perl; see <A HREF="/n|/perl/html/./lib/Pod/perldelta.html#">the perldelta manpage</A>.


<P>

<P>
<HR>
<H2><A NAME="Awk_Traps">Awk Traps

</A></H2>
Accustomed <STRONG>awk</STRONG> users should take special note of the following:


<P>

<UL>
<LI><STRONG></STRONG>
The English module, loaded via


<P>

<PRE>    use English;
</PRE>

<P>

allows you to refer to special variables (like <CODE>$/</CODE>) with names (like
<CODE>$RS</CODE>), as though they were in <STRONG>awk</STRONG>; see <A HREF="/n|/perl/html/./lib/Pod/perlvar.html#">the perlvar manpage</A> for details.


<P>

<LI><STRONG></STRONG>
Semicolons are required after all simple statements in Perl (except at the
end of a block). Newline is not a statement delimiter.


<P>

<LI><STRONG></STRONG>
Curly brackets are required on <CODE>if</CODE>s and <CODE>while</CODE>s.


<P>

<LI><STRONG></STRONG>
Variables begin with ``$'' or ``@'' in Perl.


<P>

<LI><STRONG></STRONG>
Arrays index from 0. Likewise string positions in <CODE>substr()</CODE> and
<CODE>index().</CODE>


<P>

<LI><STRONG></STRONG>
You have to decide whether your array has numeric or string indices.


<P>

<LI><STRONG></STRONG>
Hash values do not spring into existence upon mere reference.


<P>

<LI><STRONG></STRONG>
You have to decide whether you want to use string or numeric comparisons.


<P>

<LI><STRONG></STRONG>
Reading an input line does not split it for you. You get to split it to an
array yourself. And the <CODE>split()</CODE> operator has different
arguments than <STRONG>awk</STRONG>'s.


<P>

<LI><STRONG></STRONG>
The current input line is normally in $_, not $0. It generally does not
have the newline stripped. ($0 is the name of the program executed.) See <A HREF="/n|/perl/html/./lib/Pod/perlvar.html#">the perlvar manpage</A>.


<P>

<LI><STRONG></STRONG>
$&lt;<EM>digit</EM>&gt; does not refer to fields--it refers to substrings matched by the last match
pattern.


<P>

<LI><STRONG></STRONG>
The <CODE>print()</CODE> statement does not add field and record separators
unless you set <CODE>$,</CODE> and <CODE>$\</CODE>. You can set <CODE>$OFS</CODE> and <CODE>$ORS</CODE> if you're using the
English module.


<P>

<LI><STRONG></STRONG>
You must open your files before you print to them.


<P>

<LI><STRONG></STRONG>
The range operator is ``..'', not comma. The comma operator works as in 
<FONT SIZE=-1>C.</FONT>


<P>

<LI><STRONG></STRONG>
The match operator is ``=~'', not ``~''. (``~'' is the one's complement operator, as in 
<FONT SIZE=-1>C.)</FONT>



<P>

<LI><STRONG></STRONG>
The exponentiation operator is ``**'', not ``^''. ``^'' is the 
<FONT SIZE=-1>XOR</FONT> operator, as in 
<FONT SIZE=-1>C.</FONT> (You know, one could get the feeling that
 <STRONG>awk</STRONG> is basically incompatible with 
<FONT SIZE=-1>C.)</FONT>


<P>

<LI><STRONG></STRONG>
The concatenation operator is ``.'', not the null string. (Using the null
string would render <CODE>/pat/ /pat/</CODE> unparsable, because the third slash would be interpreted as a division
operator--the tokenizer is in fact slightly context sensitive for operators
like ``/'', ``?'', and ``&gt;''. And in fact, ``.'' itself can be the beginning of a number.)


<P>

<LI><STRONG></STRONG>
The <A HREF="#item_next">next</A>, <A HREF="#item_exit">exit</A>, and <A HREF="#item_continue">continue</A> keywords work differently.


<P>

<LI><STRONG></STRONG>
The following variables work differently:


<P>

<PRE>      Awk       Perl
      ARGC      $#ARGV or scalar @ARGV
      ARGV[0]   $0
      FILENAME  $ARGV
      FNR       $. - something
      FS        (whatever you like)
      NF        $#Fld, or some such
      NR        $.
      OFMT      $#
      OFS       $,
      ORS       $\
      RLENGTH   length($&amp;)
      RS        $/
      RSTART    length($`)
      SUBSEP    $;
</PRE>

<P>

<LI><STRONG></STRONG>
You cannot set <CODE>$RS</CODE> to a pattern, only a string.


<P>

<LI><STRONG></STRONG>
When in doubt, run the <STRONG>awk</STRONG> construct through <STRONG>a2p</STRONG> and see what it gives you.


<P>

</UL>
<P>
<HR>
<H2><A NAME="C_Traps">C Traps

</A></H2>
Cerebral 
<FONT SIZE=-1>C</FONT> programmers should take note of the following:


<P>

<UL>
<LI><STRONG></STRONG>
Curly brackets are required on <CODE>if</CODE>'s and <CODE>while</CODE>'s.


<P>

<LI><STRONG></STRONG>
You must use <CODE>elsif</CODE> rather than <A HREF="#item_else_if">else if</A>.


<P>

<LI><STRONG></STRONG>
The <CODE>break</CODE> and <A HREF="#item_continue">continue</A> keywords from 
<FONT SIZE=-1>C</FONT> become in Perl <A HREF="#item_last">last</A> and <A HREF="#item_next">next</A>, respectively. Unlike in 
<FONT SIZE=-1>C,</FONT> these do <EM>NOT</EM> work within a <CODE>do { } while</CODE> construct.


<P>

<LI><STRONG></STRONG>
There's no switch statement. (But it's easy to build one on the fly.)


<P>

<LI><STRONG></STRONG>
Variables begin with ``$'' or ``@'' in Perl.


<P>

<LI><STRONG></STRONG>
<A HREF="#item_printf">printf()</A> does not implement the ``*'' format for interpolating field widths, but
it's trivial to use interpolation of double-quoted strings to achieve the
same effect.


<P>

<LI><STRONG></STRONG>
Comments begin with ``#'', not ``/*''.


<P>

<LI><STRONG></STRONG>
You can't take the address of anything, although a similar operator in Perl
is the backslash, which creates a reference.


<P>

<LI><STRONG></STRONG>
<CODE>ARGV</CODE> must be capitalized.  <CODE>$ARGV[0]</CODE> is C's <CODE>argv[1]</CODE>, and <CODE>argv[0]</CODE>
ends up in <CODE>$0</CODE>.


<P>

<LI><STRONG></STRONG>
System calls such as <CODE>link(),</CODE> <CODE>unlink(),</CODE>
<CODE>rename(),</CODE> etc. return nonzero for success, not 0.


<P>

<LI><STRONG></STRONG>
Signal handlers deal with signal names, not numbers. Use <CODE>kill -l</CODE>
to find their names on your system.


<P>

</UL>
<P>
<HR>
<H2><A NAME="Sed_Traps">Sed Traps

</A></H2>
Seasoned <STRONG>sed</STRONG> programmers should take note of the following:


<P>

<UL>
<LI><STRONG></STRONG>
Backreferences in substitutions use ``$'' rather than ``\''.


<P>

<LI><STRONG></STRONG>
The pattern matching metacharacters ``('', ``)'', and ``|'' do not have
backslashes in front.


<P>

<LI><STRONG></STRONG>
The range operator is <CODE>...</CODE>, rather than comma.


<P>

</UL>
<P>
<HR>
<H2><A NAME="Shell_Traps">Shell Traps

</A></H2>
Sharp shell programmers should take note of the following:


<P>

<UL>
<LI><STRONG></STRONG>
The backtick operator does variable interpolation without regard to the
presence of single quotes in the command.


<P>

<LI><STRONG></STRONG>
The backtick operator does no translation of the return value, unlike <STRONG>csh</STRONG>.


<P>

<LI><STRONG></STRONG>
Shells (especially <STRONG>csh</STRONG>) do several levels of substitution on each command line. Perl does
substitution in only certain constructs such as double quotes, backticks,
angle brackets, and search patterns.


<P>

<LI><STRONG></STRONG>
Shells interpret scripts a little bit at a time. Perl compiles the entire
program before executing it (except for <A HREF="#item_BEGIN">BEGIN</A> blocks, which execute at compile time).


<P>

<LI><STRONG></STRONG>
The arguments are available via 
<FONT SIZE=-1>@ARGV,</FONT> not $1, $2, etc.


<P>

<LI><STRONG></STRONG>
The environment is not automatically made available as separate scalar
variables.


<P>

</UL>
<P>
<HR>
<H2><A NAME="Perl_Traps">Perl Traps

</A></H2>
Practicing Perl Programmers should take note of the following:


<P>

<UL>
<LI><STRONG></STRONG>
Remember that many operations behave differently in a list context than
they do in a scalar one. See <A HREF="/n|/perl/html/./lib/Pod/perldata.html#">the perldata manpage</A> for details.


<P>

<LI><STRONG></STRONG>
Avoid barewords if you can, especially all lowercase ones. You can't tell
by just looking at it whether a bareword is a function or a string. By
using quotes on strings and parentheses on function calls, you won't ever
get them confused.


<P>

<LI><STRONG></STRONG>
You cannot discern from mere inspection which builtins are unary operators
(like <CODE>chop()</CODE> and <CODE>chdir())</CODE> and which are list
operators (like <CODE>print()</CODE> and <CODE>unlink()).</CODE>
(User-defined subroutines can be <STRONG>only</STRONG> list operators, never unary ones.) See <A HREF="/n|/perl/html/./lib/Pod/perlop.html#">the perlop manpage</A>.


<P>

<LI><STRONG></STRONG>
People have a hard time remembering that some functions default to $_, or 
<FONT SIZE=-1>@ARGV,</FONT> or whatever, but that others which you might
expect to do not.


<P>

<LI><STRONG></STRONG>
The &lt;
<FONT SIZE=-1>FH</FONT>&gt; construct is not the name of the filehandle, it is a readline operation on
that handle. The data read is assigned to <CODE>$_</CODE> only if the file
read is the sole condition in a while loop:


<P>

<PRE>    while (&lt;FH&gt;)      { }
    while (defined($_ = &lt;FH&gt;)) { }..
    &lt;FH&gt;;  # data discarded!
</PRE>

<P>

<LI><STRONG></STRONG>
Remember not to use ``<CODE>=</CODE>'' when you need ``<CODE>=~</CODE>''; these two constructs are quite different:


<P>

<PRE>    $x =  /foo/;
    $x =~ /foo/;
</PRE>

<P>

<LI><STRONG></STRONG>
The <A HREF="#item_do_">do {}</A> construct isn't a real loop that you can use loop control on.


<P>

<LI><STRONG></STRONG>
Use <A HREF="#item_my">my()</A> for local variables whenever you can get away with it (but see <A HREF="/n|/perl/html/./lib/Pod/perlform.html#">the perlform manpage</A> for where you can't). Using <A HREF="#item_local">local()</A> actually gives a local value to a global variable, which leaves you open to
unforeseen side-effects of dynamic scoping.


<P>

<LI><STRONG></STRONG>
If you localize an exported variable in a module, its exported value will
not change. The local name becomes an alias to a new value but the external
name is still an alias for the original.


<P>

</UL>
<P>
<HR>
<H2><A NAME="Perl4_to_Perl5_Traps">Perl4 to Perl5 Traps

</A></H2>
Practicing Perl4 Programmers should take note of the following
Perl4-to-Perl5 specific traps.


<P>

They're crudely ordered according to the following list:


<P>

<DL>
<DT><STRONG><A NAME="item_Discontinuance">Discontinuance, Deprecation, and BugFix traps

</A></STRONG><DD>
Anything that's been fixed as a perl4 bug, removed as a perl4 feature or
deprecated as a perl4 feature with the intent to encourage usage of some
other perl5 feature.


<P>

<DT><STRONG><A NAME="item_Parsing">Parsing Traps

</A></STRONG><DD>
Traps that appear to stem from the new parser.


<P>

<DT><STRONG><A NAME="item_Numerical">Numerical Traps

</A></STRONG><DD>
Traps having to do with numerical or mathematical operators.


<P>

<DT><STRONG><A NAME="item_General">General data type traps

</A></STRONG><DD>
Traps involving perl standard data types.


<P>

<DT><STRONG><A NAME="item_Context">Context Traps - scalar, list contexts

</A></STRONG><DD>
Traps related to context within lists, scalar statements/declarations.


<P>

<DT><STRONG><A NAME="item_Precedence">Precedence Traps

</A></STRONG><DD>
Traps related to the precedence of parsing, evaluation, and execution of
code.


<P>

<DT><STRONG>General Regular Expression Traps using s///, etc.

</A></STRONG><DD>
Traps related to the use of pattern matching.


<P>

<DT><STRONG><A NAME="item_Subroutine">Subroutine, Signal, Sorting Traps

</A></STRONG><DD>
Traps related to the use of signals and signal handlers, general
subroutines, and sorting, along with sorting subroutines.


<P>

<DT><STRONG><A NAME="item_OS">OS Traps

</A></STRONG><DD>
OS-specific traps.


<P>

<DT><STRONG><A NAME="item_DBM">DBM Traps

</A></STRONG><DD>
Traps specific to the use of <A HREF="#item_dbmopen">dbmopen()</A>, and specific dbm implementations.


<P>

<DT><STRONG><A NAME="item_Unclassified">Unclassified Traps

</A></STRONG><DD>
Everything else.


<P>

</DL>
If you find an example of a conversion trap that is not listed here, please
submit it to Bill Middleton &lt;<EM>wjm@best.com</EM>&gt; for inclusion. Also note that at least some of these can be caught
with <STRONG>-w</STRONG>.


<P>

<P>
<HR>
<H2><A NAME="Discontinuance_Deprecation_and">Discontinuance, Deprecation, and BugFix traps

</A></H2>
Anything that has been discontinued, deprecated, or fixed as a bug from
perl4.


<P>

<UL>
<LI><STRONG><A NAME="item_Discontinuance">Discontinuance

</A></STRONG>
Symbols starting with ``_'' are no longer forced into package main, except
for <CODE>$_</CODE> itself (and <CODE>@_</CODE>, etc.).


<P>

<PRE>    package test;
    $_legacy = 1;
</PRE>

<P>

<PRE>    package main;
    print &quot;\$_legacy is &quot;,$_legacy,&quot;\n&quot;;
</PRE>

<P>

<PRE>    # perl4 prints: $_legacy is 1
    # perl5 prints: $_legacy is
</PRE>

<P>

<LI><STRONG><A NAME="item_Deprecation">Deprecation

</A></STRONG>
Double-colon is now a valid package separator in a variable name. Thus
these behave differently in perl4 vs. perl5, because the packages don't
exist.


<P>

<PRE>    $a=1;$b=2;$c=3;$var=4;
    print &quot;$a::$b::$c &quot;;
    print &quot;$var::abc::xyz\n&quot;;
 
    # perl4 prints: 1::2::3 4::abc::xyz
    # perl5 prints: 3
</PRE>

<P>

Given that <CODE>::</CODE> is now the preferred package delimiter, it is debatable whether this should
be classed as a bug or not. (The older package delimiter, ' ,is used here)


<P>

<PRE>    $x = 10 ;
    print &quot;x=${'x}\n&quot; ;
</PRE>

<P>

<PRE>    # perl4 prints: x=10
    # perl5 prints: Can't find string terminator &quot;'&quot; anywhere before EOF
</PRE>

<P>

You can avoid this problem, and remain compatible with perl4, if you always
explicitly include the package name:


<P>

<PRE>    $x = 10 ;
    print &quot;x=${main'x}\n&quot; ;
</PRE>

<P>

Also see precedence traps, for parsing <CODE>$:</CODE>.


<P>

<LI><STRONG><A NAME="item_BugFix">BugFix

</A></STRONG>
The second and third arguments of <A HREF="#item_splice">splice()</A> are now evaluated in scalar context (as the Camel says) rather than list
context.


<P>

<PRE>    sub sub1{return(0,2) }          # return a 2-elem array
    sub sub2{ return(1,2,3)}        # return a 3-elem array
    @a1 = (&quot;a&quot;,&quot;b&quot;,&quot;c&quot;,&quot;d&quot;,&quot;e&quot;);
    @a2 = splice(@a1,&amp;sub1,&amp;sub2);
    print join(' ',@a2),&quot;\n&quot;;
</PRE>

<P>

<PRE>    # perl4 prints: a b
    # perl5 prints: c d e
</PRE>

<P>

<LI><STRONG>Discontinuance

</A></STRONG>
You can't do a <A HREF="#item_goto">goto</A> into a block that is optimized away. Darn.


<P>

<PRE>    goto marker1;
</PRE>

<P>

<PRE>    for(1){
    marker1:
        print &quot;Here I is!\n&quot;;
    }
</PRE>

<P>

<PRE>    # perl4 prints: Here I is!
    # perl5 dumps core (SEGV)
</PRE>

<P>

<LI><STRONG>Discontinuance

</A></STRONG>
It is no longer syntactically legal to use whitespace as the name of a
variable, or as a delimiter for any kind of quote construct. Double darn.


<P>

<PRE>    $a = (&quot;foo bar&quot;);
    $b = q baz ;
    print &quot;a is $a, b is $b\n&quot;;
</PRE>

<P>

<PRE>    # perl4 prints: a is foo bar, b is baz
    # perl5 errors: Bareword found where operator expected
</PRE>

<P>

<LI><STRONG>Discontinuance

</A></STRONG>
The archaic while/if 
<FONT SIZE=-1>BLOCK</FONT> 
<FONT SIZE=-1>BLOCK</FONT> syntax is no longer supported.



<P>

<PRE>    if { 1 } {
        print &quot;True!&quot;;
    }
    else {
        print &quot;False!&quot;;
    }
</PRE>

<P>

<PRE>    # perl4 prints: True!
    # perl5 errors: syntax error at test.pl line 1, near &quot;if {&quot;
</PRE>

<P>

<LI><STRONG>BugFix

</A></STRONG>
The <CODE>**</CODE> operator now binds more tightly than unary minus. It was documented to work
this way before, but didn't.


<P>

<PRE>    print -4**2,&quot;\n&quot;;
</PRE>

<P>

<PRE>    # perl4 prints: 16
    # perl5 prints: -16
</PRE>

<P>

<LI><STRONG>Discontinuance

</A></STRONG>
The meaning of <CODE>foreach{}</CODE> has changed slightly when it is iterating over a list which is not an
array. This used to assign the list to a temporary array, but no longer
does so (for efficiency). This means that you'll now be iterating over the
actual values, not over copies of the values. Modifications to the loop
variable can change the original values.


<P>

<PRE>    @list = ('ab','abc','bcd','def');
    foreach $var (grep(/ab/,@list)){
        $var = 1;
    }
    print (join(':',@list));
</PRE>

<P>

<PRE>    # perl4 prints: ab:abc:bcd:def
    # perl5 prints: 1:1:bcd:def
</PRE>

<P>

To retain Perl4 semantics you need to assign your list explicitly to a
temporary array and then iterate over that. For example, you might need to
change


<P>

<PRE>    foreach $var (grep(/ab/,@list)){
</PRE>

<P>

to


<P>

<PRE>    foreach $var (@tmp = grep(/ab/,@list)){
</PRE>

<P>

Otherwise changing <CODE>$var</CODE> will clobber the values of @list.
(This most often happens when you use <CODE>$_</CODE> for the loop variable, and call subroutines in the loop that don't properly
localize <CODE>$_</CODE>.)


<P>

<LI><STRONG>Discontinuance

</A></STRONG>
<A HREF="#item_split">split</A> with no arguments now behaves like <A HREF="#item_split_">split ' '</A> (which doesn't return an initial null field if <CODE>$_</CODE> starts with
whitespace), it used to behave like <CODE>split /\s+/</CODE> (which does).


<P>

<PRE>    $_ = ' hi mom';
    print join(':', split);
</PRE>

<P>

<PRE>    # perl4 prints: :hi:mom
    # perl5 prints: hi:mom
</PRE>

<P>

<LI><STRONG>BugFix

</A></STRONG>
Perl 4 would ignore any text which was attached to an <STRONG>-e</STRONG> switch, always taking the code snippet from the following arg.
Additionally, it would silently accept an <STRONG>-e</STRONG> switch without a following arg. Both of these behaviors have been fixed.


<P>

<PRE>    perl -e'print &quot;attached to -e&quot;' 'print &quot;separate arg&quot;'
</PRE>

<P>

<PRE>    # perl4 prints: separate arg
    # perl5 prints: attached to -e
</PRE>

<P>

<PRE>    perl -e
</PRE>

<P>

<PRE>    # perl4 prints:
    # perl5 dies: No code specified for -e.
</PRE>

<P>

<LI><STRONG>Discontinuance

</A></STRONG>
In Perl 4 the return value of <A HREF="#item_push">push</A> was undocumented, but it was actually the last value being pushed onto the
target list. In Perl 5 the return value of <A HREF="#item_push">push</A> is documented, but has changed, it is the number of elements in the
resulting list.


<P>

<PRE>    @x = ('existing');
    print push(@x, 'first new', 'second new');
</PRE>

<P>

<PRE>    # perl4 prints: second new
    # perl5 prints: 3
</PRE>

<P>

<LI><STRONG>Discontinuance

</A></STRONG>
In Perl 4 (and versions of Perl 5 before 5.004), <CODE>'\r'</CODE> characters in Perl code were silently allowed, although they could cause
(mysterious!) failures in certain constructs, particularly here documents.
Now,
<CODE>'\r'</CODE> characters cause an immediate fatal error. (Note: In this example, the
notation <STRONG>\015</STRONG> represents the incorrect line ending. Depending upon your text viewer, it
will look different.)


<P>

<PRE>    print &quot;foo&quot;;\015
    print &quot;bar&quot;;
</PRE>

<P>

<PRE>    # perl4     prints: foobar
    # perl5.003 prints: foobar
    # perl5.004 dies: Illegal character \015 (carriage return)
</PRE>

<P>

See <A HREF="/n|/perl/html/./lib/Pod/perldiag.html#">the perldiag manpage</A> for full details.


<P>

<LI><STRONG>Deprecation

</A></STRONG>
Some error messages will be different.


<P>

<LI><STRONG>Discontinuance

</A></STRONG>
Some bugs may have been inadvertently removed. :-)


<P>

</UL>
<P>
<HR>
<H2><A NAME="Parsing_Traps">Parsing Traps

</A></H2>
Perl4-to-Perl5 traps from having to do with parsing.


<P>

<UL>
<LI><STRONG><A NAME="item_Parsing">Parsing

</A></STRONG>
Note the space between . and =


<P>

<PRE>    $string . = &quot;more string&quot;;
    print $string;
</PRE>

<P>

<PRE>    # perl4 prints: more string
    # perl5 prints: syntax error at - line 1, near &quot;. =&quot;
</PRE>

<P>

<LI><STRONG>Parsing

</A></STRONG>
Better parsing in perl 5


<P>

<PRE>    sub foo {}
    &amp;foo
    print(&quot;hello, world\n&quot;);
</PRE>

<P>

<PRE>    # perl4 prints: hello, world
    # perl5 prints: syntax error
</PRE>

<P>

<LI><STRONG>Parsing

</A></STRONG>
``if it looks like a function, it is a function'' rule.


<P>

<PRE>  print
    ($foo == 1) ? &quot;is one\n&quot; : &quot;is zero\n&quot;;
</PRE>

<P>

<PRE>    # perl4 prints: is zero
    # perl5 warns: &quot;Useless use of a constant in void context&quot; if using -w
</PRE>

<P>

</UL>
<P>
<HR>
<H2><A NAME="Numerical_Traps">Numerical Traps

</A></H2>
Perl4-to-Perl5 traps having to do with numerical operators, operands, or
output from same.


<P>

<UL>
<LI><STRONG><A NAME="item_Numerical">Numerical

</A></STRONG>
Formatted output and significant digits


<P>

<PRE>    print 7.373504 - 0, &quot;\n&quot;;
    printf &quot;%20.18f\n&quot;, 7.373504 - 0;
</PRE>

<P>

<PRE>    # Perl4 prints:
    7.375039999999996141
    7.37503999999999614
</PRE>

<P>

<PRE>    # Perl5 prints:
    7.373504
    7.37503999999999614
</PRE>

<P>

<LI><STRONG>Numerical

</A></STRONG>
This specific item has been deleted. It demonstrated how the auto-increment
operator would not catch when a number went over the signed int limit.
Fixed in version 5.003_04. But always be wary when using large integers. If
in doubt:


<P>

<PRE>   use Math::BigInt;
</PRE>

<P>

<LI><STRONG>Numerical

</A></STRONG>
Assignment of return values from numeric equality tests does not work in
perl5 when the test evaluates to false (0). Logical tests now return an
null, instead of 0


<P>

<PRE>    $p = ($test == 1);
    print $p,&quot;\n&quot;;
</PRE>

<P>

<PRE>    # perl4 prints: 0
    # perl5 prints:
</PRE>

<P>

Also see <A HREF="#General_Regular_Expression_Traps">General Regular Expression Traps using s///, etc.</A>
for another example of this new feature...


<P>

</UL>
<P>
<HR>
<H2><A NAME="General_data_type_traps">General data type traps

</A></H2>
Perl4-to-Perl5 traps involving most data-types, and their usage within
certain expressions and/or context.


<P>

<UL>
<LI><STRONG><A NAME="item__Arrays_">(Arrays)

</A></STRONG>
Negative array subscripts now count from the end of the array.


<P>

<PRE>    @a = (1, 2, 3, 4, 5);
    print &quot;The third element of the array is $a[3] also expressed as $a[-2] \n&quot;;
</PRE>

<P>

<PRE>    # perl4 prints: The third element of the array is 4 also expressed as
    # perl5 prints: The third element of the array is 4 also expressed as 4
</PRE>

<P>

<LI><STRONG>(Arrays)

</A></STRONG>
Setting <CODE>$#array</CODE> lower now discards array elements, and makes them impossible to recover.


<P>

<PRE>    @a = (a,b,c,d,e);
    print &quot;Before: &quot;,join('',@a);
    $#a =1;
    print &quot;, After: &quot;,join('',@a);
    $#a =3;
    print &quot;, Recovered: &quot;,join('',@a),&quot;\n&quot;;
</PRE>

<P>

<PRE>    # perl4 prints: Before: abcde, After: ab, Recovered: abcd
    # perl5 prints: Before: abcde, After: ab, Recovered: ab
</PRE>

<P>

<LI><STRONG><A NAME="item__Hashes_">(Hashes)

</A></STRONG>
Hashes get defined before use


<P>

<PRE>    local($s,@a,%h);
    die &quot;scalar \$s defined&quot; if defined($s);
    die &quot;array \@a defined&quot; if defined(@a);
    die &quot;hash \%h defined&quot; if defined(%h);
</PRE>

<P>

<PRE>    # perl4 prints:
    # perl5 dies: hash %h defined
</PRE>

<P>

<LI><STRONG><A NAME="item__Globs_">(Globs)

</A></STRONG>
glob assignment from variable to variable will fail if the assigned
variable is localized subsequent to the assignment


<P>

<PRE>    @a = (&quot;This is Perl 4&quot;);
    *b = *a;
    local(@a);
    print @b,&quot;\n&quot;;
</PRE>

<P>

<PRE>    # perl4 prints: This is Perl 4
    # perl5 prints:
</PRE>

<P>

<PRE>    # Another example
</PRE>

<P>

<PRE>    *fred = *barney; # fred is aliased to barney
    @barney = (1, 2, 4);
    # @fred;
    print &quot;@fred&quot;;  # should print &quot;1, 2, 4&quot;
</PRE>

<P>

<PRE>    # perl4 prints: 1 2 4
    # perl5 prints: In string, @fred now must be written as \@fred
</PRE>

<P>

<LI><STRONG><A NAME="item__Scalar_String_">(Scalar String)

</A></STRONG>
Changes in unary negation (of strings) This change effects both the return
value and what it does to <CODE>auto(magic)increment.</CODE>


<P>

<PRE>    $x = &quot;aaa&quot;;
    print ++$x,&quot; : &quot;;
    print -$x,&quot; : &quot;;
    print ++$x,&quot;\n&quot;;
</PRE>

<P>

<PRE>    # perl4 prints: aab : -0 : 1
    # perl5 prints: aab : -aab : aac
</PRE>

<P>

<LI><STRONG><A NAME="item__Constants_">(Constants)

</A></STRONG>
perl 4 lets you modify constants:


<P>

<PRE>    $foo = &quot;x&quot;;
    &amp;mod($foo);
    for ($x = 0; $x &lt; 3; $x++) {
        &amp;mod(&quot;a&quot;);
    }
    sub mod {
        print &quot;before: $_[0]&quot;;
        $_[0] = &quot;m&quot;;
        print &quot;  after: $_[0]\n&quot;;
    }
</PRE>

<P>

<PRE>    # perl4:
    # before: x  after: m
    # before: a  after: m
    # before: m  after: m
    # before: m  after: m
</PRE>

<P>

<PRE>    # Perl5:
    # before: x  after: m
    # Modification of a read-only value attempted at foo.pl line 12.
    # before: a
</PRE>

<P>

<LI><STRONG><A NAME="item__Scalars_">(Scalars)

</A></STRONG>
The behavior is slightly different for:


<P>

<PRE>    print &quot;$x&quot;, defined $x
</PRE>

<P>

<PRE>    # perl 4: 1
    # perl 5: &lt;no output, $x is not called into existence&gt;
</PRE>

<P>

<LI><STRONG><A NAME="item__Variable_Suicide_">(Variable Suicide)

</A></STRONG>
Variable suicide behavior is more consistent under Perl 5. Perl5 exhibits
the same behavior for hashes and scalars, that perl4 exhibits for only
scalars.


<P>

<PRE>    $aGlobal{ &quot;aKey&quot; } = &quot;global value&quot;;
    print &quot;MAIN:&quot;, $aGlobal{&quot;aKey&quot;}, &quot;\n&quot;;
    $GlobalLevel = 0;
    &amp;test( *aGlobal );
</PRE>

<P>

<PRE>    sub test {
        local( *theArgument ) = @_;
        local( %aNewLocal ); # perl 4 != 5.001l,m
        $aNewLocal{&quot;aKey&quot;} = &quot;this should never appear&quot;;
        print &quot;SUB: &quot;, $theArgument{&quot;aKey&quot;}, &quot;\n&quot;;
        $aNewLocal{&quot;aKey&quot;} = &quot;level $GlobalLevel&quot;;   # what should print
        $GlobalLevel++;
        if( $GlobalLevel&lt;4 ) {
            &amp;test( *aNewLocal );
        }
    }
</PRE>

<P>

<PRE>    # Perl4:
    # MAIN:global value
    # SUB: global value
    # SUB: level 0
    # SUB: level 1
    # SUB: level 2
</PRE>

<P>

<PRE>    # Perl5:
    # MAIN:global value
    # SUB: global value
    # SUB: this should never appear
    # SUB: this should never appear
    # SUB: this should never appear
</PRE>

<P>

</UL>
<P>
<HR>
<H2><A NAME="Context_Traps_scalar_list_con">Context Traps - scalar, list contexts

</A></H2>
<UL>
<LI><STRONG><A NAME="item__list_context_">(list context)

</A></STRONG>
The elements of argument lists for formats are now evaluated in list
context. This means you can interpolate list values now.


<P>

<PRE>    @fmt = (&quot;foo&quot;,&quot;bar&quot;,&quot;baz&quot;);
    format STDOUT=
    @&lt;&lt;&lt;&lt;&lt; @||||| @&gt;&gt;&gt;&gt;&gt;
    @fmt;
    .
    write;
</PRE>

<P>

<PRE>    # perl4 errors:  Please use commas to separate fields in file
    # perl5 prints: foo     bar      baz
</PRE>

<P>

<LI><STRONG><A NAME="item__scalar_context_">(scalar context)

</A></STRONG>
The <A HREF="#item_caller">caller()</A> function now returns a false value in a scalar context if there is no
caller. This lets library files determine if they're being required.


<P>

<PRE>    caller() ? (print &quot;You rang?\n&quot;) : (print &quot;Got a 0\n&quot;);
</PRE>

<P>

<PRE>    # perl4 errors: There is no caller
    # perl5 prints: Got a 0
</PRE>

<P>

<LI><STRONG>(scalar context)

</A></STRONG>
The comma operator in a scalar context is now guaranteed to give a scalar
context to its arguments.


<P>

<PRE>    @y= ('a','b','c');
    $x = (1, 2, @y);
    print &quot;x = $x\n&quot;;
</PRE>

<P>

<PRE>    # Perl4 prints:  x = c   # Thinks list context interpolates list
    # Perl5 prints:  x = 3   # Knows scalar uses length of list
</PRE>

<P>

<LI><STRONG><A NAME="item__list_builtin_">(list, builtin)

</A></STRONG>
<A HREF="#item_sprintf">sprintf()</A> funkiness (array argument converted to scalar array count) This test could
be added to t/op/sprintf.t


<P>

<PRE>    @z = ('%s%s', 'foo', 'bar');
    $x = sprintf(@z);
    if ($x eq 'foobar') {print &quot;ok 2\n&quot;;} else {print &quot;not ok 2 '$x'\n&quot;;}
</PRE>

<P>

<PRE>    # perl4 prints: ok 2
    # perl5 prints: not ok 2
</PRE>

<P>

<A HREF="#item_printf">printf()</A> works fine, though:


<P>

<PRE>    printf STDOUT (@z);
    print &quot;\n&quot;;
</PRE>

<P>

<PRE>    # perl4 prints: foobar
    # perl5 prints: foobar
</PRE>

<P>

Probably a bug.


<P>

</UL>
<P>
<HR>
<H2><A NAME="Precedence_Traps">Precedence Traps

</A></H2>
Perl4-to-Perl5 traps involving precedence order.


<P>

<UL>
<LI><STRONG><A NAME="item_Precedence">Precedence

</A></STRONG>

<FONT SIZE=-1>LHS</FONT> vs. 
<FONT SIZE=-1>RHS</FONT> of any assignment operator. 
<FONT SIZE=-1>LHS</FONT> is evaluated first in perl4, second in perl5; this can affect the relationship between side-effects in sub-expressions.



<P>

<PRE>    @arr = ( 'left', 'right' );
    $a{shift @arr} = shift @arr;
    print join( ' ', keys %a );
</PRE>

<P>

<PRE>    # perl4 prints: left
    # perl5 prints: right
</PRE>

<P>

<LI><STRONG>Precedence

</A></STRONG>
These are now semantic errors because of precedence:


<P>

<PRE>    @list = (1,2,3,4,5);
    %map = (&quot;a&quot;,1,&quot;b&quot;,2,&quot;c&quot;,3,&quot;d&quot;,4);
    $n = shift @list + 2;   # first item in list plus 2
    print &quot;n is $n, &quot;;
    $m = keys %map + 2;     # number of items in hash plus 2
    print &quot;m is $m\n&quot;;
</PRE>

<P>

<PRE>    # perl4 prints: n is 3, m is 6
    # perl5 errors and fails to compile
</PRE>

<P>

<LI><STRONG>Precedence

</A></STRONG>
The precedence of assignment operators is now the same as the precedence of
assignment. Perl 4 mistakenly gave them the precedence of the associated
operator. So you now must parenthesize them in expressions like


<P>

<PRE>    /foo/ ? ($a += 2) : ($a -= 2);
</PRE>

<P>

Otherwise


<P>

<PRE>    /foo/ ? $a += 2 : $a -= 2
</PRE>

<P>

would be erroneously parsed as


<P>

<PRE>    (/foo/ ? $a += 2 : $a) -= 2;
</PRE>

<P>

On the other hand,


<P>

<PRE>    $a += /foo/ ? 1 : 2;
</PRE>

<P>

now works as a 
<FONT SIZE=-1>C</FONT> programmer would expect.


<P>

<LI><STRONG>Precedence

</A></STRONG>
<PRE>    open FOO || die;
</PRE>

<P>

is now incorrect. You need parentheses around the filehandle. Otherwise,
perl5 leaves the statement as its default precedence:


<P>

<PRE>    open(FOO || die);
</PRE>

<P>

<PRE>    # perl4 opens or dies
    # perl5 errors: Precedence problem: open FOO should be open(FOO)
</PRE>

<P>

<LI><STRONG>Precedence

</A></STRONG>
perl4 gives the special variable, <CODE>$:</CODE> precedence, where perl5 treats <CODE>$::</CODE> as main <A HREF="#item_package">package</A>




<P>

<PRE>    $a = &quot;x&quot;; print &quot;$::a&quot;;
</PRE>

<P>

<PRE>    # perl 4 prints: -:a
    # perl 5 prints: x
</PRE>

<P>

<LI><STRONG>Precedence

</A></STRONG>
concatenation precedence over filetest operator?


<P>

<PRE>    -e $foo .= &quot;q&quot;
</PRE>

<P>

<PRE>    # perl4 prints: no output
    # perl5 prints: Can't modify -e in concatenation
</PRE>

<P>

</UL>
<P>
<HR>
<H2><A NAME="General_Regular_Expression_Traps">General Regular Expression Traps using s///, etc.

</A></H2>
All types of 
<FONT SIZE=-1>RE</FONT> traps.


<P>

<UL>
<LI><STRONG><A NAME="item_Regular">Regular Expression

</A></STRONG>
<CODE>s'$lhs'$rhs'</CODE> now does no interpolation on either side. It used to interpolate <CODE>$lhs</CODE> but not <CODE>$rhs</CODE>. (And still does not match a literal '$' in string)


<P>

<PRE>    $a=1;$b=2;
    $string = '1 2 $a $b';
    $string =~ s'$a'$b';
    print $string,&quot;\n&quot;;
</PRE>

<P>

<PRE>    # perl4 prints: $b 2 $a $b
    # perl5 prints: 1 2 $a $b
</PRE>

<P>

<LI><STRONG>Regular Expression

</A></STRONG>
<CODE>m//g</CODE> now attaches its state to the searched string rather than the regular
expression. (Once the scope of a block is left for the sub, the state of
the searched string is lost)


<P>

<PRE>    $_ = &quot;ababab&quot;;
    while(m/ab/g){
        &amp;doit(&quot;blah&quot;);
    }
    sub doit{local($_) = shift; print &quot;Got $_ &quot;}
</PRE>

<P>

<PRE>    # perl4 prints: blah blah blah
    # perl5 prints: infinite loop blah...
</PRE>

<P>

<LI><STRONG>Regular Expression

</A></STRONG>
Currently, if you use the <CODE>m//o</CODE> qualifier on a regular expression within an anonymous sub, <EM>all</EM> closures generated from that anonymous sub will use the regular expression
as it was compiled when it was used the very first time in any such
closure. For instance, if you say


<P>

<PRE>    sub build_match {
        my($left,$right) = @_;
        return sub { $_[0] =~ /$left stuff $right/o; };
    }
</PRE>

<P>

<CODE>build_match()</CODE> will always return a sub which matches the
contents of
<CODE>$left</CODE> and <CODE>$right</CODE> as they were the <EM>first</EM> time that <CODE>build_match()</CODE> was called, not as they are in the
current call.


<P>

This is probably a bug, and may change in future versions of Perl.


<P>

<LI><STRONG>Regular Expression

</A></STRONG>
If no parentheses are used in a match, Perl4 sets <CODE>$+</CODE> to the whole match, just like <CODE>$&</CODE>. Perl5 does not.


<P>

<PRE>    &quot;abcdef&quot; =~ /b.*e/;
    print &quot;\$+ = $+\n&quot;;
</PRE>

<P>

<PRE>    # perl4 prints: bcde
    # perl5 prints:
</PRE>

<P>

<LI><STRONG>Regular Expression

</A></STRONG>
substitution now returns the null string if it fails


<P>

<PRE>    $string = &quot;test&quot;;
    $value = ($string =~ s/foo//);
    print $value, &quot;\n&quot;;
</PRE>

<P>

<PRE>    # perl4 prints: 0
    # perl5 prints:
</PRE>

<P>

Also see <A HREF="#Numerical_Traps">Numerical Traps</A> for another example of this new feature.


<P>

<LI><STRONG>Regular Expression

</A></STRONG>
<CODE>s`lhs`rhs`</CODE> (using backticks) is now a normal substitution, with no backtick expansion


<P>

<PRE>    $string = &quot;&quot;;
    $string =~ s`^`hostname`;
    print $string, &quot;\n&quot;;
</PRE>

<P>

<PRE>    # perl4 prints: &lt;the local hostname&gt;
    # perl5 prints: hostname
</PRE>

<P>

<LI><STRONG>Regular Expression

</A></STRONG>
Stricter parsing of variables used in regular expressions


<P>

<PRE>    s/^([^$grpc]*$grpc[$opt$plus$rep]?)//o;
</PRE>

<P>

<PRE>    # perl4: compiles w/o error
    # perl5: with Scalar found where operator expected ..., near &quot;$opt$plus&quot;
</PRE>

<P>

an added component of this example, apparently from the same script, is the
actual value of the s'd string after the substitution.
<CODE>[$opt]</CODE> is a character class in perl4 and an array subscript in perl5


<P>

<PRE>    $grpc = 'a';
    $opt  = 'r';
    $_ = 'bar';
    s/^([^$grpc]*$grpc[$opt]?)/foo/;
    print ;
</PRE>

<P>

<PRE>    # perl4 prints: foo
    # perl5 prints: foobar
</PRE>

<P>

<LI><STRONG>Regular Expression

</A></STRONG>
Under perl5, <CODE>m?x?</CODE> matches only once, like <A HREF="#item__x_">?x?</A>. Under perl4, it matched repeatedly, like <A HREF="#item__x_">/x/</A> or <CODE>m!x!</CODE>.


<P>

<PRE>    $test = &quot;once&quot;;
    sub match { $test =~ m?once?; }
    &amp;match();
    if( &amp;match() ) {
        # m?x? matches more then once
        print &quot;perl4\n&quot;;
    } else {
        # m?x? matches only once
        print &quot;perl5\n&quot;;
    }
</PRE>

<P>

<PRE>    # perl4 prints: perl4
    # perl5 prints: perl5
</PRE>

<P>

<LI><STRONG>Regular Expression

</A></STRONG>
Under perl4 and upto version 5.003, a failed <CODE>m//g</CODE> match used to reset the internal iterator, so that subsequent <CODE>m//g</CODE> match attempts began from the beginning of the string. In perl version
5.004 and later, failed <CODE>m//g</CODE> matches do not reset the iterator position (which can be found using the <A HREF="#item_pos">pos()</A> function--see <A HREF="/n|/perl/html/./lib/Pod/perlfunc.html#pos">pos</A>).


<P>

<PRE>    $test = &quot;foop&quot;;
    for (1..3) {
        print $1 while ($test =~ /(o)/g);
        # pos $test = 0;     # to get old behavior
    }
</PRE>

<P>

<PRE>    # perl4     prints: oooooo
    # perl5.004 prints: oo
</PRE>

<P>

You may always reset the iterator yourself as shown in the commented line
to get the old behavior.


<P>

</UL>
<P>
<HR>
<H2><A NAME="Subroutine_Signal_Sorting_Trap">Subroutine, Signal, Sorting Traps

</A></H2>
The general group of Perl4-to-Perl5 traps having to do with Signals,
Sorting, and their related subroutines, as well as general subroutine
traps. Includes some OS-Specific traps.


<P>

<UL>
<LI><STRONG><A NAME="item__Signals_">(Signals)

</A></STRONG>
Barewords that used to look like strings to Perl will now look like
subroutine calls if a subroutine by that name is defined before the
compiler sees them.


<P>

<PRE>    sub SeeYa { warn&quot;Hasta la vista, baby!&quot; }
    $SIG{'TERM'} = SeeYa;
    print &quot;SIGTERM is now $SIG{'TERM'}\n&quot;;
</PRE>

<P>

<PRE>    # perl4 prints: SIGTERM is main'SeeYa
    # perl5 prints: SIGTERM is now main::1
</PRE>

<P>

Use <STRONG>-w</STRONG> to catch this one


<P>

<LI><STRONG><A NAME="item__Sort_Subroutine_">(Sort Subroutine)

</A></STRONG>
reverse is no longer allowed as the name of a sort subroutine.


<P>

<PRE>    sub reverse{ print &quot;yup &quot;; $a &lt;=&gt; $b }
    print sort reverse a,b,c;
</PRE>

<P>

<PRE>    # perl4 prints: yup yup yup yup abc
    # perl5 prints: abc
</PRE>

<P>

<LI><STRONG><A NAME="item_warn">warn() won't let you specify a filehandle.

</A></STRONG>
Although it _always_ printed to 
<FONT SIZE=-1>STDERR,</FONT> <CODE>warn()</CODE> would let you specify a
filehandle in perl4. With perl5 it does not.


<P>

<PRE>    warn STDERR &quot;Foo!&quot;;
</PRE>

<P>

<PRE>    # perl4 prints: Foo!
    # perl5 prints: String found where operator expected
</PRE>

<P>

</UL>
<P>
<HR>
<H2><A NAME="OS_Traps">OS Traps

</A></H2>
<UL>
<LI><STRONG><A NAME="item__SysV_">(SysV)

</A></STRONG>
Under 
<FONT SIZE=-1>HPUX,</FONT> and some other SysV OSes, one had to reset any
signal handler, within the signal handler function, each time a signal was
handled with perl4. With perl5, the reset is now done correctly. Any code
relying on the handler _not_ being reset will have to be reworked.


<P>

Since version 5.002, Perl uses <CODE>sigaction()</CODE> under SysV.


<P>

<PRE>    sub gotit {
        print &quot;Got @_... &quot;;
    }
    $SIG{'INT'} = 'gotit';
</PRE>

<P>

<PRE>    $| = 1;
    $pid = fork;
    if ($pid) {
        kill('INT', $pid);
        sleep(1);
        kill('INT', $pid);
    } else {
        while (1) {sleep(10);}
    }
</PRE>

<P>

<PRE>    # perl4 (HPUX) prints: Got INT...
    # perl5 (HPUX) prints: Got INT... Got INT...
</PRE>

<P>

<LI><STRONG>(SysV)

</A></STRONG>
Under SysV OSes, <A HREF="#item_seek">seek()</A> on a file opened to append <A HREF="#item__gt_gt_">&gt;&gt;</A> now does the right thing w.r.t. the <CODE>fopen()</CODE> manpage. e.g., -
When a file is opened for append, it is impossible to overwrite information
already in the file.


<P>

<PRE>    open(TEST,&quot;&gt;&gt;seek.test&quot;);
    $start = tell TEST ;
    foreach(1 .. 9){
        print TEST &quot;$_ &quot;;
    }
    $end = tell TEST ;
    seek(TEST,$start,0);
    print TEST &quot;18 characters here&quot;;
</PRE>

<P>

<PRE>    # perl4 (solaris) seek.test has: 18 characters here
    # perl5 (solaris) seek.test has: 1 2 3 4 5 6 7 8 9 18 characters here
</PRE>

<P>

</UL>
<P>
<HR>
<H2><A NAME="Interpolation_Traps">Interpolation Traps

</A></H2>
Perl4-to-Perl5 traps having to do with how things get interpolated within
certain expressions, statements, contexts, or whatever.


<P>

<UL>
<LI><STRONG><A NAME="item_Interpolation">Interpolation

</A></STRONG>
@ now always interpolates an array in double-quotish strings.


<P>

<PRE>    print &quot;To: someone@somewhere.com\n&quot;;
</PRE>

<P>

<PRE>    # perl4 prints: To:someone@somewhere.com
    # perl5 errors : In string, @somewhere now must be written as \@somewhere
</PRE>

<P>

<LI><STRONG>Interpolation

</A></STRONG>
Double-quoted strings may no longer end with an unescaped $ or @.


<P>

<PRE>    $foo = &quot;foo$&quot;;
    $bar = &quot;bar@&quot;;
    print &quot;foo is $foo, bar is $bar\n&quot;;
</PRE>

<P>

<PRE>    # perl4 prints: foo is foo$, bar is bar@
    # perl5 errors: Final $ should be \$ or $name
</PRE>

<P>

Note: perl5 
<FONT SIZE=-1>DOES</FONT> 
<FONT SIZE=-1>NOT</FONT> error on the terminating @ in <CODE>$bar</CODE>



<P>

<LI><STRONG>Interpolation

</A></STRONG>
Perl now sometimes evaluates arbitrary expressions inside braces that occur
within double quotes (usually when the opening brace is preceded by <CODE>$</CODE>
or <CODE>@</CODE>).


<P>

<PRE>    @www = &quot;buz&quot;;
    $foo = &quot;foo&quot;;
    $bar = &quot;bar&quot;;
    sub foo { return &quot;bar&quot; };
    print &quot;|@{w.w.w}|${main'foo}|&quot;;
</PRE>

<P>

<PRE>    # perl4 prints: |@{w.w.w}|foo|
    # perl5 prints: |buz|bar|
</PRE>

<P>

Note that you can <CODE>use strict;</CODE> to ward off such trappiness under perl5.


<P>

<LI><STRONG>Interpolation

</A></STRONG>
The construct ``this is $$x'' used to interpolate the pid at that point,
but now apparently tries to dereference <A HREF="#item__x">$x</A>.  <CODE>$$</CODE> by itself still works fine, however.


<P>

<PRE>    print &quot;this is $$x\n&quot;;
</PRE>

<P>

<PRE>    # perl4 prints: this is XXXx   (XXX is the current pid)
    # perl5 prints: this is
</PRE>

<P>

<LI><STRONG>Interpolation

</A></STRONG>
Creation of hashes on the fly with <CODE>eval "EXPR"</CODE> now requires either both
<CODE>$</CODE>'s to be protected in the specification of the hash name, or both curlies
to be protected. If both curlies are protected, the result will be
compatible with perl4 and perl5. This is a very common practice, and should
be changed to use the block form of <A HREF="#item_eval_">eval{}</A>  if possible.


<P>

<PRE>    $hashname = &quot;foobar&quot;;
    $key = &quot;baz&quot;;
    $value = 1234;
    eval &quot;\$$hashname{'$key'} = q|$value|&quot;;
    (defined($foobar{'baz'})) ?  (print &quot;Yup&quot;) : (print &quot;Nope&quot;);
</PRE>

<P>

<PRE>    # perl4 prints: Yup
    # perl5 prints: Nope
</PRE>

<P>

Changing


<P>

<PRE>    eval &quot;\$$hashname{'$key'} = q|$value|&quot;;
</PRE>

<P>

to


<P>

<PRE>    eval &quot;\$\$hashname{'$key'} = q|$value|&quot;;
</PRE>

<P>

causes the following result:


<P>

<PRE>    # perl4 prints: Nope
    # perl5 prints: Yup
</PRE>

<P>

or, changing to


<P>

<PRE>    eval &quot;\$$hashname\{'$key'\} = q|$value|&quot;;
</PRE>

<P>

causes the following result:


<P>

<PRE>    # perl4 prints: Yup
    # perl5 prints: Yup
    # and is compatible for both versions
</PRE>

<P>

<LI><STRONG>Interpolation

</A></STRONG>
perl4 programs which unconsciously rely on the bugs in earlier perl
versions.


<P>

<PRE>    perl -e '$bar=q/not/; print &quot;This is $foo{$bar} perl5&quot;'
</PRE>

<P>

<PRE>    # perl4 prints: This is not perl5
    # perl5 prints: This is perl5
</PRE>

<P>

<LI><STRONG>Interpolation

</A></STRONG>
You also have to be careful about array references.


<P>

<PRE>    print &quot;$foo{&quot;
</PRE>

<P>

<PRE>    perl 4 prints: {
    perl 5 prints: syntax error
</PRE>

<P>

<LI><STRONG>Interpolation

</A></STRONG>
Similarly, watch out for:


<P>

<PRE>    $foo = &quot;array&quot;;
    print &quot;\$$foo{bar}\n&quot;;
</PRE>

<P>

<PRE>    # perl4 prints: $array{bar}
    # perl5 prints: $
</PRE>

<P>

Perl 5 is looking for <CODE>$array{bar}</CODE> which doesn't exist, but perl 4 is happy just to expand <CODE>$foo</CODE>
to ``array'' by itself. Watch out for this especially in <A HREF="#item_eval">eval</A>'s.


<P>

<LI><STRONG>Interpolation

</A></STRONG>
<A HREF="#item_qq">qq()</A> string passed to <A HREF="#item_eval">eval</A>




<P>

<PRE>    eval qq(
        foreach \$y (keys %\$x\) {
            \$count++;
        }
    );
</PRE>

<P>

<PRE>    # perl4 runs this ok
    # perl5 prints: Can't find string terminator &quot;)&quot;
</PRE>

<P>

</UL>
<P>
<HR>
<H2><A NAME="DBM_Traps">DBM Traps

</A></H2>
General 
<FONT SIZE=-1>DBM</FONT> traps.


<P>

<UL>
<LI><STRONG><A NAME="item_DBM">DBM

</A></STRONG>
Existing dbm databases created under perl4 (or any other dbm/ndbm tool) may
cause the same script, run under perl5, to fail. The build of perl5 must
have been linked with the same dbm/ndbm as the default for <A HREF="#item_dbmopen">dbmopen()</A>
to function properly without <A HREF="#item_tie">tie</A>'ing to an extension dbm implementation.


<P>

<PRE>    dbmopen (%dbm, &quot;file&quot;, undef);
    print &quot;ok\n&quot;;
</PRE>

<P>

<PRE>    # perl4 prints: ok
    # perl5 prints: ok (IFF linked with -ldbm or -lndbm)
</PRE>

<P>

<LI><STRONG>DBM

</A></STRONG>
Existing dbm databases created under perl4 (or any other dbm/ndbm tool) may
cause the same script, run under perl5, to fail. The error generated when
exceeding the limit on the key/value size will cause perl5 to exit
immediately.


<P>

<PRE>    dbmopen(DB, &quot;testdb&quot;,0600) || die &quot;couldn't open db! $!&quot;;
    $DB{'trap'} = &quot;x&quot; x 1024;  # value too large for most dbm/ndbm
    print &quot;YUP\n&quot;;
</PRE>

<P>

<PRE>    # perl4 prints:
    dbm store returned -1, errno 28, key &quot;trap&quot; at - line 3.
    YUP
</PRE>

<P>

<PRE>    # perl5 prints:
    dbm store returned -1, errno 28, key &quot;trap&quot; at - line 3.
</PRE>

<P>

</UL>
<P>
<HR>
<H2><A NAME="Unclassified_Traps">Unclassified Traps

</A></H2>
Everything else.


<P>

<UL>
<LI><STRONG><A NAME="item_Unclassified">Unclassified

</A></STRONG>
<A HREF="#item_require">require</A>/<A HREF="#item_do">do</A> trap using returned value


<P>

If the file doit.pl has:


<P>

<PRE>    sub foo {
        $rc = do &quot;./do.pl&quot;;
        return 8;
    }
    print &amp;foo, &quot;\n&quot;;
</PRE>

<P>

And the do.pl file has the following single line:


<P>

<PRE>    return 3;
</PRE>

<P>

Running doit.pl gives the following:


<P>

<PRE>    # perl 4 prints: 3 (aborts the subroutine early)
    # perl 5 prints: 8
</PRE>

<P>

Same behavior if you replace <A HREF="#item_do">do</A> with <A HREF="#item_require">require</A>.


<P>

</UL>
As always, if any of these are ever officially declared as bugs, they'll be
fixed and removed.


<P>

</DL>
    </BODY>

    </HTML>
