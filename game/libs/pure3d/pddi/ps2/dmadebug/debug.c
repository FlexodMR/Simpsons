/*
    DEBUG functions

    James Russell - SCEE Technology Group

    ===================================================
    *Please* send bug reports to James_Russell@scee.net
    If you fix it yourself but don't tell me, your fix
    may be wiped out when you d/l the next release!
    ===================================================

    These functions are used to handle any output generated by the debug modules.
    They implement a very rudimentary STDOUT and STDERR channel.

    Version history:

    Ver        Author        Comments
    ===        ======        ========

    2.07    J Russell   8/1/2001 - Now explicitly tells you if it halted because
                        there were too many errors/warnings.
    0.95    J Russell    11/7/2000 - Added bounds checks on the output size.
                        Revamped config string parsing.
                        Added variable buffer size and scrolling.
    0.9        J Russell    8/7/2000 - Added a check to see if we were being
                        used without being initialised first.
    0.7        J Russell    1/6/2000 - First release

*/

/*
    debug.c

    Error handling and debugging functions
    ======================================

    The error system is fairly simple - there are two large output buffers
    called gOutputBuffer (equivalent to STDOUT) and gErrorBuffer (equivalent
    to STDERR). Errors/warnings write to the ErrorBuffer, other functions
    should write to gOutputBuffer.

    Errors/Warnings are added using AddError and AddWarning, which take an
    error/warning number (defined in Debug.h) and a string to be added to the
    gErrorBuffer.

    These error messages are stored in memory rather than being sent straight to
    the console output, because the console has been known to drop some output
    lines, and you might want to implement a more reliable protocol for getting
    the output back the the user (ie via the PS2 screen or some TCP connection).
    
    When the error system is initialised, you can specify a string which has some
    options on it. The parser is very simple, so it's probably easy to break, but
    basically it ignores other options on that line, so you can pass options to
    modules which use this error subsystem and be safe in the knowledge that the
    error subsystem will ignore those options.

    Initialisation options:
        -w            Ignore all warnings
        -Wx            Ignore warning 'x', where 'x' is a number. EG -W36 ignores warning 36.
        -Werror        Treat warnings as errors, i.e halt if a warning is encountered.
        -Ex            Stop processing after 'x' errors encountered. I.e. -E6 means stop
                    after encountering 6 errors.
        -Bx            Change buffer size. By default it is 100KB. Specify a new size with 'x'.
                    E.G. -B200 allocates a 200KB buffer. (The error buffer is always
                    fixed in size, you cannot change it)
        -noscroll    The buffer can either fill and stop (causing a fatal error
                    to be returned), or it can 'scroll', that is, once information goes off
                    one end, information at the start is removed to make space (this is the
                    default behaviour). Specifying this option causes the module to
                    disable deleting the first 20 lines whenever it fills up.

    You'd initialise the subsystem like so: InitialiseErrorSystem("-W36 -W22 -W1 -E8");
    which would ignore warnings 36, 22 and 1, and stop processing after 8 errors.

    Pass in NULL or the empty string if you don't need to set any options.

    ----------

    Because there is a maximum number of errors/warnings that can occur before the error
    system decides enough is enough, the error system must be able to inform the calling
    procedure that it should halt.

    Thus, when the limit of errors/warnings is reached, AddError and AddWarning will
    return TRUE.

    However, it is up to the calling function to actually recognise this and halt.

    In general, warnings are things that won't cause a crash, but are a bit suspect,
    like having bits set in unused parts of a DMA tag. Errors are things which are
    definitely right out, like setting reserved bits and invalid memory accesses.
    There are two types of errors though (just like in a C compiler) - those where
    you can still continue on for a bit and try to find any more errors (like setting
    reserved bits in some address), and those which mean that the module just can't go
    on, like null addresses in the 'next tag' field.
*/

//#define DEBUG

#include <sys/types.h>
#include <ctype.h>
#include <stdio.h>
#include <stdarg.h>
#include <string.h>
#include <malloc.h>
#include <sifdev.h>
#include <libdma.h>
#include <pddi/ps2/dmadebug/Debug.h>
#include <pddi/ps2/dmadebug/Dmaemu.h>
#include <pddi/ps2/dmadebug/Vifcursor.h>
#include <pddi/ps2/dmadebugGifcursor.h>


// ==================================================
// DEFINES
// ==================================================


//#define FALSE (0)
//#define TRUE (1)

#define MAX_WARNINGS_MASKED                    (100)
#define DEFAULT_MAX_ERRORS_BEFORE_HALT        (6)
#define MAX_WARNINGS_BEFORE_HALT            (25)

        // Specified in KB
#define ERROR_BUFFER_SIZE (10)

// ==================================================
// GLOBALS
// ==================================================

static int initialised = FALSE;        // Has this module been initialised?

static int gMaxErrors;                // The maximum number of errors we're prepared to encounter before
                                    // returning HALT.
static BOOL gTreatWarningsAsErrors;
static BOOL gEmbedErrorsInMainOutput;

static int gErrCount;                // Number of errors/warnings encountered so far.
static int gWarnCount;

static int numWarningsIgnored = 0;
static int warningsIgnored[MAX_WARNINGS_MASKED];    // Array holding all the warning numbers to ignore.


char gTempString[1024];                // Just a temporary string for random sprintf calls.
static char gTempStringBuffer[1024];    // Temporary string for use in this modules only

char gErrorBuffer[ERROR_BUFFER_SIZE*1024];            // The big error buffer
char *gOutputBuffer = NULL;        // The big output buffer
int    gOutputBufferSize;

static char *gpOutputBuffer;        // optimisation - a pointer showing the current end of the output
                                    // buffer, so we can add strings onto the end faster.

static BOOL gScroll = TRUE;        // Boolean, should we scroll when the buffer fills, or fail with an error.

// ==================================================
// FUNCTIONS
// ==================================================



// Initialises the Error System, using a configuration string (much like command line options)

// -w = ignore all warnings
// -Werror = treat warnings as errors
// -Wx = mask warnings for warning number 'x' (e.g. -W36 masks error 36, see Debug.h for errnums)
// -Ex = allow 'x' errors before quitting
// -S = embed error messages in gOutputBuffer instead of gErrorBuffer.

void DEBUG_parseConfig(char *initString) {
    int maskWarning;
    char *p;

    gErrorBuffer[0] = 0;
    if(gOutputBuffer != NULL) {
        free(gOutputBuffer);
    }

    gErrCount = 0;
    gWarnCount = 0;

    gMaxErrors = DEFAULT_MAX_ERRORS_BEFORE_HALT;
    gTreatWarningsAsErrors = FALSE;
    gEmbedErrorsInMainOutput = FALSE;
    numWarningsIgnored = 0;

    gOutputBufferSize = 100;
    gScroll = TRUE;

    if(initString != NULL) {
                // Parse the init string
        if(strstr(initString, "-w") != NULL) {
            numWarningsIgnored = -1;    // -1 means ignore all warnings
        }

        if((p = strstr(initString, "-E")) != NULL) {
            p+=2;
            gMaxErrors = 0;
            while(*p >= '0' && *p <= '9') {
                gMaxErrors = gMaxErrors * 10 + *(p++);
            }
        }

        if((p = strstr(initString, "-W")) != NULL) {
            p+=2;
            ASSERT((*p != 0), "Invalid debug initialisation string at '-W'!");

            if(*p == 'e') {        // Check for 'error' (actually just check for 'e');
                gTreatWarningsAsErrors = TRUE;
            } else {
                        // Else we assume its a decimal number and mask that warning
                maskWarning = 0;
                while(isdigit(*p)) {
                    maskWarning = maskWarning * 10 + (*(p++) - '0');
                }
                if(maskWarning != 0 && numWarningsIgnored >= 0) {
                    ASSERT( (numWarningsIgnored < MAX_WARNINGS_MASKED),
                            "Invalid initialisation string at '-W'! Too many warning masks!");
                    warningsIgnored[numWarningsIgnored++] = maskWarning;
                    dprintf( ("Will ignore warning number %d\n", maskWarning ) );
                }
            }
        }

        if(strstr(initString, "-S") != NULL) {
            gEmbedErrorsInMainOutput = TRUE;
        }

        if((p=strstr(initString, "-B")) != NULL) {
            p+=2;
            gOutputBufferSize = 0;
            while(isdigit(*p)) {
                gOutputBufferSize = gOutputBufferSize * 10 + (*(p++) - '0');
            }
            ASSERT( (gOutputBufferSize != 0), "Invalid parameter for buffer size (-B)! Must be a number > 0");
        }

        if(strstr(initString, "-noscroll") != NULL) {
            gScroll = FALSE;
        }
    }

    gOutputBuffer = (char *)memalign(4, gOutputBufferSize * 1024);
    ASSERT( (gOutputBuffer != NULL), "ERROR in Debug module! Could not allocate output buffer");

    initialised = TRUE;

    DEBUG_reset();
}





static void warnInit(void) {
    DEBUG_parseConfig("-S");
    puts(ERRORCOL "WARNING WARNING: An attempt was made to use the DEBUG module without initialising it first!" NORM);
    puts(ERRORCOL "WARNING WARNING: An attempt was made to use the DEBUG module without initialising it first!" NORM);
}




void DEBUG_reset(void) {        // once initialised, this will clear the output buffers
    if(!initialised) {
        warnInit();
    }

    gOutputBuffer[0] = 0;
    gErrorBuffer[0] = 0;

    gpOutputBuffer = gOutputBuffer;
}





// =====================================================
// Adds a string to the Output Buffer

int DEBUG_addToOutputBuffer(char *s) {
    int foundError = NO_ERROR;
    int i;

    if(initialised == FALSE) warnInit();

    i = strlen(s);
    if((gpOutputBuffer + i + 100) > (gOutputBuffer + gOutputBufferSize * 1024)) {    // if adding this string will overflow the buffer...
        if(gScroll == FALSE) {
            // Exit with an error;
            strcat(gpOutputBuffer, "\n\n" ERRORCOL "DEBUG MODULE - OUTPUT BUFFER FULL" NORM "\n");
            return ERROR_FATAL_HALT;
        } else {
                // Delete the first 20 lines of output and retry.
            char *p = gOutputBuffer;
            int numNewlines = 20;
            while(numNewlines > 0) {
                if(*p == '\n') {
                    numNewlines--;
                }
                p++;
                if(p >= gpOutputBuffer) {
                    break;
                }
            }
            if(numNewlines > 0 || p >= gpOutputBuffer) {
                p = gpOutputBuffer;
            }
                // p should now point to the char after the first char of the 20th line.
            memmove(gOutputBuffer, p, strlen(p)+1);
            gpOutputBuffer = gOutputBuffer + strlen(gOutputBuffer);
                // If it's still larger then we have to quit.
            ASSERT( ((gpOutputBuffer + i + 100) <= (gOutputBuffer + gOutputBufferSize * 1024)),
                "Error - could not fit string into Output Buffer, even after scrolling.");
        }
    }

    strcat(gpOutputBuffer, s);
    strcat(gpOutputBuffer, NORM "\n");
    gpOutputBuffer = gpOutputBuffer + strlen(gpOutputBuffer);

    return foundError;
}







// ==========================================
// Adds an error to the Error Buffer

int DEBUG_addError(int errNum, int severity, char *errString) {
    int err = severity;
    int i;

    if(initialised == FALSE) warnInit();

    if(severity == ERROR_WARNING) {
        if(numWarningsIgnored == -1) {            // -1 means ignore all warnings
            dputs("ignoring all warnings");
            return 0;
        }
        for(i = 0; i < numWarningsIgnored; i++) {    // else check to see if we should ignore this warning
            if(warningsIgnored[i] == errNum) {
                dprintf( ("Ignoring warning %d\n", errNum) );
                return 0;
            }
        }
        sprintf(gTempStringBuffer, WARNINGCOL"warning (%d) : %s" NORM, errNum, errString);
        if(gTreatWarningsAsErrors) {
            gErrCount++;
            if(gErrCount > gMaxErrors) {
                puts(ERRORCOL "DMAdebug - too many errors (treating warnings as errors), exiting."NORM);
                err |= ERROR_FATAL_HALT;
            }
        } else {
            gWarnCount++;
            if(gWarnCount > MAX_WARNINGS_BEFORE_HALT) {
                puts(ERRORCOL "DMAdebug - too many warnings, exiting."NORM);
                err |= ERROR_FATAL_HALT;
            }
        }

    } else {    // Errors
        sprintf(gTempStringBuffer, ERRORCOL"ERROR (%d) : %s"NORM, errNum, errString);
        gErrCount++;
        if(gErrCount > gMaxErrors) {
            puts(ERRORCOL "DMAdebug - too many errors, exiting."NORM);
            err |= ERROR_FATAL_HALT;
        }
    }

    if(gEmbedErrorsInMainOutput) {
        err |= DEBUG_addToOutputBuffer(gTempStringBuffer);
    } else {
        strcat(gErrorBuffer, gTempStringBuffer);
        strcat(gErrorBuffer, "\n");
    }

    return err;
}





int DEBUG_strlen(char *s) {
    // This returns the length of the string in characters, i.e. the length without
    // ANSI colour codes.

    int i = strlen(s);

    while(*s != 0) {
        if(*s == 0x1b) {
            while(*s != 'm') {
                s++;
                i--;
            }
            i--;
        }
        s++;
    }
    return i;
}







        // Returns address of first '%' in a format string that isn't '%%', or NULL if no such pattern exists.
char *findFirstPercent(char *s) {
    while(1) {
        s = strchr(s, '%');
        if(s == NULL) {
            return NULL;
        }
        if(s[1] == '%') {
            s+=2;
        } else {
            break;
        }
    }
    return s;
}



    // 'final' is a string containing a bit field's disassembly. addField will add this string
    // to the output. It checks to see that adding the field
    // will go off the end of the current line (there's a pre-defined line width), and
    // if so it will add a new line and indent.

    // This function essentially duplicates the work of sprintf.

    // There's some complex stuff in here because we'd ideally want to pass all the va_args
    // off to sprintf, but that's a little difficult without writing some assembler or
    // using the (nonexistant) varargs macros.

void DEBUG_addField(debug_msg_type type, char *final, char *fmt, ...) {
    va_list ap;
    int argnum;
    char *p,*q,*r;
    u_int arg;
    int i;
    char temp[1024];

    va_start(ap, fmt);

            // First, calculate the number of arguments
    argnum = 0;
    for(p = fmt; *p != 0; p++) {
        if(*p == '%') {
            if(p[1] == '%') {
                p++;
            } else {
                argnum++;
            }
        }
    }

            // This may seem rather complicated, but it's really the only way of doing it
            // without completely reinventing sprintf.
            // Basically, it searches for a '%' symbol, then find finds the next '%' and sets
            // it to '0'. Then it calls sprintf with the next var_arg. It then unsets the '%'
            // and continues.
    p = fmt;
    q = NULL;
    r = temp;
    if(argnum == 0) {
        sprintf(r, p);    // have to sprintf rather than strcpy, to remove any '%%'s.
    } else {
        while(argnum > 0) {
            arg = va_arg(ap, u_int);

            if(argnum != 1) {
                    // replace next '%' with 0 to stop sprintf from pulling more than 1 arg.

                q = findFirstPercent(p);        // This is the '%' of the string we're about to reformat
                ASSERT((q!=NULL), "Logic error - should have found at least 1 '%%'\n");

                q = findFirstPercent(q+1);        // this is the '%' of the place where we'll put the 0
                ASSERT((q!=NULL), "Logic error - should have found at least 2 '%%'\n");

                *q = 0;
            } else {
                q = NULL;
            }

            r += sprintf(r, p, arg);
                // Replace '%' if we previously set it to 0
            if(q != NULL) {
                *q = '%';
                p = q;
            }
            argnum--;
        }
    }
    va_end(ap);

        // Now add the 'temp' string to 'final'.
    p = final + strlen(final);
    switch(type) {
        case ENTRY_TITLE:
            dputs("-=-=-=-=-= DEBUG - Adding new TITLE");
            i = INDENT_SIZE - DEBUG_strlen(temp) - 1;
            strcat(p, temp);
            while(i-- > 0) {
                strcat(p, " ");
            }
            strcat(p, ":");
            break;

        case ENTRY_FIELD:
            dputs("-=-=-=-=-= DEBUG - Adding new FIELD");
            while(p > final && *p != '\n') {
                p--;
            }
            if(*p == '\n') p++;

            i = DEBUG_strlen(p) + DEBUG_strlen(temp);
                    // This will add a new line and indent if the field will go off the end... but won't
                    // if it's the first field on the line.
            if(i > LINE_WIDTH && DEBUG_strlen(p) > INDENT_SIZE) {
                strcat(p, "\n" INDENT);
            }
            strcat(p, " ");
            strcat(p, temp);
            break;

        case ENTRY_FIELD_NL:
            dputs("-=-=-=-=-= DEBUG - Adding new FIELD_NL");
            if(p > final && *(p-1) != '\n') {        // add a NL if the last char was not a new line.
                strcat(p, "\n");
            }
            strcat(p, INDENT " ");
            strcat(p, temp);
            break;

        default:
            ASSERT((0), "LOGIC ERROR in DEBUG_addField - this type does not exist.");
            break;
    }
}





    // Save the output buffers to a file

void DEBUG_saveBuffers(char *filename, BOOL append) {
    int handle;

    strcpy(gTempStringBuffer, "host0:");
    strcat(gTempStringBuffer, filename);
    if(append) {
        handle = sceOpen(gTempStringBuffer, SCE_WRONLY|SCE_CREAT|SCE_APPEND);
    } else {
        handle = sceOpen(gTempStringBuffer, SCE_WRONLY|SCE_TRUNC|SCE_CREAT);
    }
    ASSERT((handle >= 0), "Could not open the file for writing.");

    sceWrite(handle, gOutputBuffer, strlen(gOutputBuffer));
    sceWrite(handle, gErrorBuffer, strlen(gErrorBuffer));
    sceClose(handle);
}



            // initialises all the modules


void DEBUG_init(char *cs) {
    DEBUG_parseConfig(cs);
    DMA_parseConfig(cs);
    GIF_parseConfig(cs);
    VIF_parseConfig(cs);
}

