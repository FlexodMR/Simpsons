@perl use Wrap;
@perl $Wrap::columns = 80;
@perl sub max { my($a,$b) = @_; ($a>$b)?($a):($b);}
@perl sub pad { my($len,$str) = @_; sprintf("%-${len}s",$str); }
@perl ($sec,$min,$hour,$mday,$mon,$year,$wday,$yday,$isdst) = localtime(time);
@perl $year = $year+1900;
@perl my $shadername;
@perl my $filename;
@perl my $headerfilename;
@perl my $shaderid;
@perl my $pddiname;
@perl my $registername;
@perl my $decription;
@foreach shader_list 
    @perl $shadername = "P3D$shader_name";
    @perl $filename = "p3d$shader_name";
    @perl $headerfilename = "p3d$shader_name";
    @perl $filename .= ".cpp";
    @perl $headerfilename .= ".hpp";
    @perl $shaderid = $shader_id;
    @perl $pddiname = $shader_pddiShaderName;
    @perl $registername = $shader_registerName;
    @perl $description = $shader_description;
@end
@perl print "Generating .\\src\\$filename\n";
@openfile .\\src\\$filename
/*===========================================================================
    Automatically generated by Jeeves, don't edit.  Edit ${shadername}.sc instead

    File: $filename

    $description
    
    Copyright (c) $year Radical Entertainment, Inc.  All rights reserved.

===========================================================================*/
#include <math.h>
#include <maya/MString.h>
#include <maya/MTypeId.h>
#include <maya/MPlug.h>
#include <maya/MDataBlock.h>
#include <maya/MDataHandle.h>
#include <maya/MArrayDataHandle.h>
#include <maya/MFnCompoundAttribute.h>
#include <maya/MFnEnumAttribute.h>
#include <maya/MFnTypedAttribute.h>
#include <maya/MFnStringData.h>
#include <maya/MFnStringArrayData.h>
#include <maya/MFnNumericAttribute.h>
#include <maya/MFnLightDataAttribute.h>
#include <maya/MFloatVector.h>
#include <maya/MFileIO.h>       // required to detect file I/O
#include <maya/MGlobal.h>
#include <maya/MSceneMessage.h>
#include "$headerfilename"


MTypeId ${shadername}::id( $shaderid );

int ${shadername}::GetIntDefault( const char* attr, int nDefault )
{
    const char* control = "int \$p3dInt; if ( `optionVar -exists %s` ) \$p3dInt = `optionVar -q %s`; else \$p3dInt = %d;";

    char                        mel[256];
    sprintf( mel, control, attr, attr, nDefault );

    MGlobal::executeCommand( mel, nDefault, false, false );

    return nDefault;
}

float ${shadername}::GetFloatDefault( const char* attr, float fDefault )
{
    const char* control = "float \$p3dFloat; if ( `optionVar -exists %s` ) \$p3dFloat = `optionVar -q %s`; else \$p3dFloat = %f;";

    char                        mel[256];
    sprintf( mel, control, attr, attr, fDefault );

    double                      dblResult;
    MGlobal::executeCommand( mel, dblResult, false, false );
    fDefault = (float)dblResult;

    return fDefault;
}

void ${shadername}::GetColorDefault( const char* attr, float* cDefault )
{
    const char* control = "float \$p3dFloatArray[]; if ( `optionVar -exists %s` ) \$p3dFloatArray = `optionVar -q %s`; else \$p3dFloatArray = { %f, %f, %f };";

    char                        mel[256];
    sprintf( mel, control, attr, attr, cDefault[0], cDefault[1], cDefault[2] );

    MDoubleArray                dblResult;
    MGlobal::executeCommand( mel, dblResult, false, false );
    if ( dblResult.length() > 2 )
    {
        cDefault[0] = (float)dblResult[0];
        cDefault[1] = (float)dblResult[1];
        cDefault[2] = (float)dblResult[2];
    }
}

void ${shadername}::AfterOpen( void* clientData )
{
    ${shadername} *shader = (${shadername} *) clientData;
    MObject thisNode = shader->thisMObject();
    int i = 1;

    @foreach code_list
       @if( $code_hook eq "afteropen" )
          $code_source
       @endif
    @end

    // We are done with the callback for this specific shader.
    MSceneMessage::removeCallback( shader->afterOpenCallback );
    MSceneMessage::removeCallback( shader->afterImportCallback );
}

void ${shadername}::postConstructor( )
{
    // Must first check if a file is loading..
    // Maya does not save attributes whose values remain at their default.
    // The creation of all shader nodes -- including those while loading 
    // a scene -- would adopt the user settings and only those attributes
    // saved in  the scene file would be restored.
    // Result: Artists would get VERY upset.
    // In other words, don't diddle with them if a scene is being loaded!
    if ( !MFileIO::isReadingFile() )
    {
        MPlug                       plug;
        int                         nDefault = 0;
        float                       fDefault = 0.0f;
        bool                        bDefault = false;
        float                       cDefault[3] = { 0.0, 0.0, 0.0 };
    
    @foreach int_list
        @if( !defined $int_attribute || $int_attribute eq "true" )
        // Get default from optionVar "${shadername}_$int_long"
        @if (defined $int_value)
        nDefault = GetIntDefault( "${shadername}_$int_long", $int_value );
        @else
        nDefault = GetIntDefault( "${shadername}_$int_long", 0 );
        @endif
        plug = MPlug( thisMObject(), a$int_name );
        plug.setValue( nDefault );
        @endif

    @end

    @foreach float_list
        @if( !defined $float_attribute || $float_attribute eq "true" )
        // Get default from optionVar "${shadername}_$float_long"
        @if (defined $float_value)
        fDefault = GetFloatDefault( "${shadername}_$float_long", $float_value );
        @else
        fDefault = GetFloatDefault( "${shadername}_$float_long", 0.0f );
        @endif
        plug = MPlug( thisMObject(), a$float_name );
        plug.setValue( fDefault );
        @endif

    @end

    @foreach bool_list
        @if( !defined $bool_attribute || $bool_attribute eq "true" )
        // Get default from optionVar "${shadername}_$bool_long"
        @if (defined $bool_value)
        bDefault = ( 0 != GetIntDefault( "${shadername}_$bool_long", $bool_value ) );
        @else
        bDefault = ( 0 != GetIntDefault( "${shadername}_$bool_long", false ) );
        @endif
        plug = MPlug( thisMObject(), a$bool_name );
        plug.setValue( bDefault );
        @endif

    @end
    @foreach enum_list
        @if( !defined $enum_attribute || $enum_attribute eq "true" )
        // Get default from optionVar "${shadername}_$enum_long"
        @if (defined $enum_default)
        nDefault = GetIntDefault( "${shadername}_$enum_long", $enum_default );
        @else
        nDefault = GetIntDefault( "${shadername}_$enum_long", 0 );
        @endif
        plug = MPlug( thisMObject(), a$enum_name );
        plug.setValue( nDefault );
        @endif

    @end
    @foreach texture_list
        @if( !defined $texture_attribute || $texture_attribute eq "true" )
        // Get default from optionVar "${shadername}_$texture_long"
        @if (defined $texture_value0)
        cDefault[0] = ${texture_value0}f;
        cDefault[1] = ${texture_value1}f;
        cDefault[2] = ${texture_value2}f;
        @else
        cDefault[0] = 0.0f;
        cDefault[1] = 0.0f;
        cDefault[2] = 0.0f;
        @endif
        GetColorDefault( "${shadername}_$texture_long", cDefault );
        plug = MPlug( thisMObject(), a$texture_name );
        plug.child(0).setValue( cDefault[0] );
        plug.child(1).setValue( cDefault[1] );
        plug.child(2).setValue( cDefault[2] );
        @endif
    
    @end
    @foreach color_list
        @if( !defined $color_attribute || $color_attribute eq "true" )
        // Get default from optionVar "${shadername}_$color_long"
        @if (defined $color_value0)
        cDefault[0] = ${color_value0}f;
        cDefault[1] = ${color_value1}f;
        cDefault[2] = ${color_value2}f;
        @else
        cDefault[0] = 0.0f;
        cDefault[1] = 0.0f;
        cDefault[2] = 0.0f;
        @endif
        GetColorDefault( "${shadername}_$color_long", cDefault );
        plug = MPlug( thisMObject(), a$color_name );
        plug.child(0).setValue( cDefault[0] );
        plug.child(1).setValue( cDefault[1] );
        plug.child(2).setValue( cDefault[2] );
        @endif
    
    @end
    }
    else
    {
        // Bug fix: 03 Jul 2002 -> Callback is initiated ONLY if shader is
        //                         created as the result of a file load/import!

        // Set callback after scene is loaded.
        afterOpenCallback = MSceneMessage::addCallback( MSceneMessage::kAfterOpen, 
                                          ${shadername}::AfterOpen, (void *) this );
        afterImportCallback = MSceneMessage::addCallback( MSceneMessage::kAfterImport, 
                                          ${shadername}::AfterOpen, (void *) this );
    }

    @foreach code_list
       @if( $code_hook eq "postconstructor" )
          $code_source
       @endif
    @end

    setMPSafe(true);
}


//
// Declare static member variables:
/////////////////////////////////////////////////////////////////////////////
    
// Declare All New Added Textures:
@foreach texture_list
@if( !defined $texture_attribute || $texture_attribute eq "true" )
MObject  ${shadername}::a${texture_name};
MObject  ${shadername}::a${texture_name}R;
MObject  ${shadername}::a${texture_name}G;
MObject  ${shadername}::a${texture_name}B;
@endif

@end   
// Declare All New Added Colors:
@foreach color_list
@if( !defined $color_attribute || $color_attribute eq "true" )
MObject  ${shadername}::a${color_name}R;
MObject  ${shadername}::a${color_name}G;
MObject  ${shadername}::a${color_name}B;
MObject  ${shadername}::a${color_name};
@endif
@if( defined $color_fourCC )
MObject  ${shadername}::aExport$color_fourCC;        //export
MObject  ${shadername}::aExport${color_fourCC}R;        //export red
MObject  ${shadername}::aExport${color_fourCC}G;        //export red
MObject  ${shadername}::aExport${color_fourCC}B;        //export red
@endif

@end

// Declare All New Added enums:
@foreach enum_list
@if( !defined $enum_attribute || $enum_attribute eq "true" )
MObject  ${shadername}::a${enum_name};
@endif
@if( defined $enum_fourCC )
MObject  ${shadername}::aExport$enum_fourCC;        //export
@endif

@end   

// Declare All New Added floats:
@foreach float_list
@if( !defined $float_attribute || $float_attribute eq "true" )
MObject  ${shadername}::a${float_name};
@endif
@if( defined $float_fourCC )
MObject  ${shadername}::aExport$float_fourCC;        //export
@endif

@end   
  
// Declare All New Added uvs:
@foreach uv_list
@if( !defined $uv_attribute || $uv_attribute eq "true" )
MObject  ${shadername}::aU${uv_name};
MObject  ${shadername}::aV${uv_name};
MObject  ${shadername}::aUV${uv_name};
@endif
@if( defined $uv_fourCC )
MObject  $UV{shadername}::aExport$uv_fourCC;        //export
MObject  $U{shadername}::aExport$uv_fourCC;        //export
MObject  $V{shadername}::aExport$uv_fourCC;        //export
@endif

@end   
  
// Declare All New Added ints:
@foreach int_list
@if( !defined $int_attribute || $int_attribute eq "true" )
MObject  ${shadername}::a${int_name};
@endif
@if( defined $int_fourCC )
MObject  ${shadername}::aExport$int_fourCC;        //export
@endif

@end  

// Declare All New Added  bool:
@foreach bool_list
@if( !defined $bool_attribute || $bool_attribute eq "true" )
MObject  ${shadername}::a${bool_name};
@endif
@if( defined $bool_fourCC )
MObject  ${shadername}::aExport$bool_fourCC;        //export
@endif

@end  

// Declare All New Added  StringArray:
@foreach strarray_list
@if( !defined $strarray_attribute || $strarray_attribute eq "true" )
MObject  ${shadername}::a${strarray_name};
@endif
@if( defined $strarray_fourCC )
MObject  ${shadername}::aExport$strarray_fourCC;        //export
@endif

@end  

MObject  ${shadername}::aOutColor;
MObject  ${shadername}::aOutColorR;
MObject  ${shadername}::aOutColorG;
MObject  ${shadername}::aOutColorB;
MObject  ${shadername}::aOutTrans;
MObject  ${shadername}::aOutTransR;
MObject  ${shadername}::aOutTransG;
MObject  ${shadername}::aOutTransB;

MObject  ${shadername}::aPDDIShaderName;
MObject  ${shadername}::aVertexShaderName;
MObject  ${shadername}::aExport;

MObject  ${shadername}::aIsTranslucent;
MObject  ${shadername}::aVertexNeeds;
MObject  ${shadername}::aVertexMask;

MObject  ${shadername}::aPointCamera;
MObject  ${shadername}::aPointCameraX;
MObject  ${shadername}::aPointCameraY;
MObject  ${shadername}::aPointCameraZ;
MObject  ${shadername}::aNormalCamera;
MObject  ${shadername}::aNormalCameraX;
MObject  ${shadername}::aNormalCameraY;
MObject  ${shadername}::aNormalCameraZ;
MObject  ${shadername}::aTriangleNormalCamera;
MObject  ${shadername}::aTriangleNormalCameraX;
MObject  ${shadername}::aTriangleNormalCameraY;
MObject  ${shadername}::aTriangleNormalCameraZ;
MObject  ${shadername}::aLightData;
MObject  ${shadername}::aLightDirection;
MObject  ${shadername}::aLightDirectionX;
MObject  ${shadername}::aLightDirectionY;
MObject  ${shadername}::aLightDirectionZ;
MObject  ${shadername}::aLightIntensity; 
MObject  ${shadername}::aLightIntensityR;
MObject  ${shadername}::aLightIntensityG;
MObject  ${shadername}::aLightIntensityB;
MObject  ${shadername}::aLightAmbient;
MObject  ${shadername}::aLightDiffuse;
MObject  ${shadername}::aLightSpecular;
MObject  ${shadername}::aLightShadowFraction;
MObject  ${shadername}::aPreShadowIntensity;
MObject  ${shadername}::aLightBlindData;

MObject ${shadername}::aObjectId;

//
// Constructor:
/////////////////////////////////////////////////////////////////////////////
${shadername}::$shadername()
{
}

//
// Destructor:
/////////////////////////////////////////////////////////////////////////////
${shadername}::~$shadername()
{
}

//
// Creator:
/////////////////////////////////////////////////////////////////////////////
void * ${shadername}::creator()
{
     return new $shadername();
}

//
// Intialize all attributes:
/////////////////////////////////////////////////////////////////////////////
MStatus ${shadername}::initialize()
{
    MFnNumericAttribute nAttr; 
    MFnEnumAttribute eAttr; 
    MFnLightDataAttribute lAttr;
    MFnTypedAttribute tAttr;
    MFnStringData str;
    MFnStringArrayData strarray;

    // output and internal attributes

    aOutColorR = nAttr.create( "outColorR", "ocr", MFnNumericData::kFloat);
    aOutColorG = nAttr.create( "outColorG", "ocg", MFnNumericData::kFloat);
    aOutColorB = nAttr.create( "outColorB", "ocb", MFnNumericData::kFloat);

    aOutColor = nAttr.create( "outColor","oc", aOutColorR, aOutColorG, aOutColorB);
    nAttr.setHidden(false);
    nAttr.setReadable(true);
    nAttr.setWritable(false);

    aOutTransR = nAttr.create( "outTransparencyR","otr", MFnNumericData::kFloat);
    aOutTransG = nAttr.create( "outTransparencyG","otg", MFnNumericData::kFloat);
    aOutTransB = nAttr.create( "outTransparencyB","otb", MFnNumericData::kFloat);
    aOutTrans = nAttr.create( "outTransparency","ot", aOutTransR,aOutTransG,aOutTransB);
    nAttr.setHidden(false);
    nAttr.setReadable(true);
    nAttr.setWritable(false);

    aPDDIShaderName = tAttr.create( "pddiShaderName", "psn", MFnData::kString);
    tAttr.setHidden(true);
    tAttr.setReadable(true);
    tAttr.setWritable(false);
    tAttr.setDefault(str.create("$pddiname"));

    aVertexShaderName = tAttr.create( "vertexShaderName", "vsn", MFnData::kString);
    tAttr.setHidden(false);
    tAttr.setReadable(true);
    tAttr.setWritable(true);
    tAttr.setDefault(str.create(""));

    aIsTranslucent = nAttr.create( "isTranslucent", "trans", MFnNumericData::kBoolean);
    nAttr.setHidden(true);
    nAttr.setStorable(false);
    nAttr.setDefault(false);

    aVertexNeeds = nAttr.create( "vertexNeeds", "vn", MFnNumericData::kLong);
    nAttr.setHidden(true);
    nAttr.setStorable(false);
    nAttr.setDefault(0);

    aVertexMask = nAttr.create( "vertexMask", "vm", MFnNumericData::kLong);
    nAttr.setHidden(true);
    nAttr.setStorable(false);
    nAttr.setDefault(0);

    aPointCameraX = nAttr.create( "pointCameraX", "px", MFnNumericData::kFloat);
    nAttr.setStorable(false);
    nAttr.setDefault(1.0f);

    aPointCameraY = nAttr.create( "pointCameraY", "py", MFnNumericData::kFloat);
    nAttr.setStorable(false);
    nAttr.setDefault(1.0f);

    aPointCameraZ = nAttr.create( "pointCameraZ", "pz", MFnNumericData::kFloat);
    nAttr.setStorable(false);
    nAttr.setDefault(1.0f);

    aPointCamera = nAttr.create( "pointCamera","pc", 
                                          aPointCameraX, aPointCameraY, aPointCameraZ);
    nAttr.setStorable(false);
    nAttr.setDefault(1.0f, 1.0f, 1.0f);
    nAttr.setHidden(true);


    aNormalCameraX = nAttr.create( "normalCameraX", "nx", MFnNumericData::kFloat);
    nAttr.setStorable(false);
    nAttr.setDefault(1.0f);

    aNormalCameraY = nAttr.create( "normalCameraY", "ny", MFnNumericData::kFloat);
    nAttr.setStorable(false);
    nAttr.setDefault(1.0f);

    aNormalCameraZ = nAttr.create( "normalCameraZ", "nz", MFnNumericData::kFloat);
    nAttr.setStorable(false);
    nAttr.setDefault(1.0f);

    aNormalCamera = nAttr.create( "normalCamera","n", 
                                            aNormalCameraX, aNormalCameraY, aNormalCameraZ);
    nAttr.setStorable(false);
    nAttr.setDefault(1.0f, 1.0f, 1.0f);
    nAttr.setHidden(true);

    aTriangleNormalCameraX = nAttr.create( "triangleNormalCameraX", "tnx", MFnNumericData::kFloat);
    nAttr.setStorable(false);
    nAttr.setDefault(1.0f);

    aTriangleNormalCameraY = nAttr.create( "triangleNormalCameraY", "tny", MFnNumericData::kFloat);
    nAttr.setStorable(false);
    nAttr.setDefault(1.0f);

    aTriangleNormalCameraZ = nAttr.create( "triangleNormalCameraZ", "tnz", MFnNumericData::kFloat);
    nAttr.setStorable(false);
    nAttr.setDefault(1.0f);

    aTriangleNormalCamera = nAttr.create( "triangleNormalCamera","tn", 
                                            aTriangleNormalCameraX, aTriangleNormalCameraY, aTriangleNormalCameraZ);
    nAttr.setStorable(false);
    nAttr.setDefault(1.0f, 1.0f, 1.0f);
    nAttr.setHidden(true);

    aLightDirectionX = nAttr.create( "lightDirectionX", "ldx", MFnNumericData::kFloat);
    nAttr.setStorable(false);
    nAttr.setHidden(true);
    nAttr.setReadable(false);
    nAttr.setDefault(1.0f);

    aLightDirectionY = nAttr.create( "lightDirectionY", "ldy", MFnNumericData::kFloat);
    nAttr.setStorable(false);
    nAttr.setHidden(true);
    nAttr.setReadable(false);
    nAttr.setDefault(1.0f);

    aLightDirectionZ = nAttr.create( "lightDirectionZ", "ldz", MFnNumericData::kFloat);
    nAttr.setStorable(false);
    nAttr.setHidden(true);
    nAttr.setReadable(false);
    nAttr.setDefault(1.0f);

    aLightDirection = nAttr.create( "lightDirection", "ld", 
                                              aLightDirectionX, aLightDirectionY, aLightDirectionZ);
    nAttr.setStorable(false);
    nAttr.setHidden(true);
    nAttr.setReadable(false);
    nAttr.setDefault(1.0f, 1.0f, 1.0f);

    aLightIntensityR = nAttr.create( "lightIntensityR", "lir", MFnNumericData::kFloat);
    nAttr.setStorable(false);
    nAttr.setHidden(true);
    nAttr.setReadable(false);
    nAttr.setDefault(1.0f);

    aLightIntensityG = nAttr.create( "lightIntensityG", "lig", MFnNumericData::kFloat);
    nAttr.setStorable(false);
    nAttr.setHidden(true);
    nAttr.setReadable(false);
    nAttr.setDefault(1.0f);

    aLightIntensityB = nAttr.create( "lightIntensityB", "lib", MFnNumericData::kFloat);
    nAttr.setStorable(false);
    nAttr.setHidden(true);
    nAttr.setReadable(false);
    nAttr.setDefault(1.0f);

    aLightIntensity = nAttr.create( "lightIntensity", "li", 
                                              aLightIntensityR, aLightIntensityG, aLightIntensityB);
    nAttr.setStorable(false);
    nAttr.setHidden(true);
    nAttr.setReadable(false);
    nAttr.setDefault(1.0f, 1.0f, 1.0f);

    aLightAmbient = nAttr.create( "lightAmbient", "la", MFnNumericData::kBoolean);
    nAttr.setStorable(false);
    nAttr.setHidden(true);
    nAttr.setReadable(false);
    nAttr.setDefault(true);

    aLightDiffuse = nAttr.create( "lightDiffuse", "ldf", MFnNumericData::kBoolean);
    nAttr.setStorable(false);
    nAttr.setHidden(true);
    nAttr.setReadable(false);
    nAttr.setDefault(true);

    aLightSpecular = nAttr.create( "lightSpecular", "ls", MFnNumericData::kBoolean);
    nAttr.setStorable(false);
    nAttr.setHidden(true);
    nAttr.setReadable(false);
    nAttr.setDefault(false);

    aLightShadowFraction = nAttr.create("lightShadowFraction","lsf",MFnNumericData::kFloat);
    nAttr.setStorable(false);
    nAttr.setHidden(true);
    nAttr.setReadable(false);
    nAttr.setDefault(0.0f);

    aPreShadowIntensity = nAttr.create("preShadowIntensity","psi",MFnNumericData::kFloat);
    nAttr.setStorable(false);
    nAttr.setHidden(true);
    nAttr.setReadable(false);
    nAttr.setDefault(0.0f);

    aLightBlindData = nAttr.create("lightBlindData","lbld",MFnNumericData::kLong);
    nAttr.setStorable(false);
    nAttr.setHidden(true);
    nAttr.setReadable(false);
    nAttr.setDefault(0);

#if ( MAYA_API_VERSION >= 400 )
    aLightData = lAttr.create( "lightDataArray", "ltd", 
                                        aLightDirection, aLightIntensity, aLightAmbient, 
                                        aLightDiffuse, aLightSpecular, aLightShadowFraction,
                                        aPreShadowIntensity,
                                        aLightBlindData);
    lAttr.setDefault(0.0f, 0.0f, 0.0f, 0.0f, 0.0f, 0.0f, true, true, false, 0.0f, 1.0f, 0);
#else
#if ( MAYA_API_VERSION >= 300 )
    aLightData = lAttr.create( "lightDataArray", "ltd", 
                                        aLightDirection, aLightIntensity, aLightAmbient, 
                                        aLightDiffuse, aLightSpecular, aLightShadowFraction,
                                        aPreShadowIntensity,
                                        aLightBlindData);
    lAttr.setDefault(0.0f, 0.0f, 0.0f, 0.0f, 0.0f, 0.0f, true, true, false, 0.0f, 1.0f, 0);
#else
    aLightData = lAttr.create( "lightDataArray", "ltd", 
                                        aLightDirection, aLightIntensity, aLightAmbient, 
                                        aLightDiffuse, aLightSpecular, aLightShadowFraction,
                                        aPreShadowIntensity);
    lAttr.setDefault(0.0f, 0.0f, 0.0f, 0.0f, 0.0f, 0.0f, true, true, false, 0.0f, 1.0f);
#endif
#endif

    lAttr.setArray(true);
    lAttr.setStorable(false);
    lAttr.setHidden(true);

    // objectId
    aObjectId = nAttr.create( "objectId", "oi", MFnNumericData::kLong, 0.0 );
    nAttr.setStorable(false);
    nAttr.setHidden(true);
    nAttr.setReadable(false);

    addAttribute(aPDDIShaderName);
    addAttribute(aVertexShaderName);
    addAttribute(aExport);
    addAttribute(aIsTranslucent);
    addAttribute(aVertexNeeds);
    addAttribute(aVertexMask);

    addAttribute(aPointCamera);
    addAttribute(aNormalCamera);
    addAttribute(aTriangleNormalCamera);
    addAttribute(aLightData);
    addAttribute(aOutColor);
    addAttribute(aOutTrans);
    addAttribute(aObjectId);

    attributeAffects (aLightIntensity, aOutColor);
    attributeAffects (aLightIntensityR, aOutColor);
    attributeAffects (aLightIntensityG, aOutColor);
    attributeAffects (aLightIntensityB, aOutColor);
    attributeAffects (aPointCamera, aOutColor);
    attributeAffects (aPointCameraX, aOutColor);
    attributeAffects (aPointCameraY, aOutColor);
    attributeAffects (aPointCameraZ, aOutColor);
    attributeAffects (aNormalCamera, aOutColor);
    attributeAffects (aNormalCameraX, aOutColor);
    attributeAffects (aNormalCameraY, aOutColor);
    attributeAffects (aNormalCameraZ, aOutColor);
    attributeAffects (aTriangleNormalCamera, aOutColor);
    attributeAffects (aTriangleNormalCameraX, aOutColor);
    attributeAffects (aTriangleNormalCameraY, aOutColor);
    attributeAffects (aTriangleNormalCameraZ, aOutColor);
    attributeAffects (aLightData, aOutColor);
    attributeAffects (aLightDirectionX, aOutColor);
    attributeAffects (aLightDirectionY, aOutColor);
    attributeAffects (aLightDirectionZ, aOutColor);
    attributeAffects (aLightAmbient, aOutColor);
    attributeAffects (aLightSpecular, aOutColor);
    attributeAffects (aLightDiffuse, aOutColor);
    attributeAffects (aLightDirection, aOutColor);
    attributeAffects (aLightShadowFraction, aOutColor);
    attributeAffects (aPreShadowIntensity, aOutColor);
    attributeAffects (aLightBlindData, aOutColor);

    attributeAffects(aObjectId,aOutColor);
    attributeAffects(aObjectId,aVertexNeeds);
    attributeAffects(aObjectId,aVertexMask);

    //Create all texture attributes here:
@foreach texture_list
    @if( !defined $texture_attribute || $texture_attribute eq "true" )
    a${texture_name}R = nAttr.create( "${texture_long}R", "${texture_short}r",MFnNumericData::kFloat);
    a${texture_name}G = nAttr.create( "${texture_long}G", "${texture_short}g",MFnNumericData::kFloat);
    a${texture_name}B = nAttr.create( "${texture_long}B", "${texture_short}b",MFnNumericData::kFloat);
    
    a$texture_name = nAttr.create( "$texture_long", "$texture_short", a${texture_name}R , a${texture_name}G, a${texture_name}B );
    nAttr.setKeyable(true);
    @if ( defined $texture_storable )
    nAttr.setStorable($texture_storable);
    @else
    nAttr.setStorable(true);
    @endif
    @if ( defined $texture_value0 )
    nAttr.setDefault($texture_value0, $texture_value1, $texture_value2);
    @else
    nAttr.setDefault(0.0f, 0.0f, 0.0f);
    @endif
    nAttr.setUsedAsColor(true);
    @endif
@end

    //Create all color attributes here:
@foreach color_list
    @if( !defined $color_attribute || $color_attribute eq "true" )
    a${color_name}R = nAttr.create( "${color_long}R", "${color_short}r",MFnNumericData::kFloat);
    a${color_name}G = nAttr.create( "${color_long}G", "${color_short}g",MFnNumericData::kFloat);
    a${color_name}B = nAttr.create( "${color_long}B", "${color_short}b",MFnNumericData::kFloat);
    
    a$color_name = nAttr.create( "$color_long", "$color_short", a${color_name}R , a${color_name}G, a${color_name}B );
    @if (defined $color_keyable)
    nAttr.setKeyable($color_keyable);
    @else
    nAttr.setKeyable(true);
    @endif
    @if ( defined $color_storable )
    nAttr.setStorable($color_storable);
    @else
    nAttr.setStorable(true);
    @endif
    @if (defined $color_connectable)
    nAttr.setConnectable($color_connectable);
    @else
    nAttr.setConnectable(true);
    @endif
    @if ( defined $color_value0 )
    nAttr.setDefault($color_value0, $color_value1, $color_value2);
    @else
    nAttr.setDefault(0.0f, 0.0f, 0.0f);
    @endif
    nAttr.setUsedAsColor(true);
    @endif

@end

    //Create all bool attributes here:
@foreach bool_list
    @if( !defined $bool_attribute || $bool_attribute eq "true" )
    a$bool_name = nAttr.create( "$bool_long", "$bool_short", MFnNumericData::kBoolean);
    @if (defined $bool_keyable)
    nAttr.setKeyable($bool_keyable);
    @else
    nAttr.setKeyable(true);
    @endif
    @if (defined $bool_storable)
    nAttr.setStorable($bool_storable);
    @else
    nAttr.setStorable(true);
    @endif
    @if (defined $bool_keyable)
    nAttr.setConnectable( $bool_keyable );
    @else
    nAttr.setConnectable( false );
    @endif
    @if (defined $bool_value)
    nAttr.setDefault($bool_value);
    @else
    nAttr.setDefault(true);
    @endif
    @endif

@end

     //Create all float attributes here:
@foreach float_list
    @if( !defined $float_attribute || $float_attribute eq "true" )
    a$float_name = nAttr.create( "$float_long", "$float_short", MFnNumericData::kFloat);
    @if (defined $float_keyable)
    nAttr.setKeyable($float_keyable);
    @else
    nAttr.setKeyable(true);
    @endif
    @if (defined $float_storable)
    nAttr.setStorable($float_storable);
    @else
    nAttr.setStorable(true);
    @endif
    nAttr.setWritable( true );
    @if (defined $float_connectable)
    nAttr.setConnectable($float_connectable);
    @else
    nAttr.setConnectable(true);
    @endif
    @if (defined $float_min)
    nAttr.setMin($float_min);
    @endif
    @if (defined $float_max)
    nAttr.setMax($float_max);
    @endif
    @if (defined $float_value)
    nAttr.setDefault($float_value);
    @endif
    @endif

@end

     //Create all uv attributes here:
@foreach uv_list
    @if( !defined $uv_attribute || $uv_attribute eq "true" )
    aU${uv_name} = nAttr.create( "u${uv_long}", "u${uv_short}",MFnNumericData::kFloat);
    aV${uv_name} = nAttr.create( "v${uv_long}", "v${uv_short}",MFnNumericData::kFloat);
    aUV${uv_name} = nAttr.create( "uv$uv_long", "uv$uv_short", aU${uv_name} , aV${uv_name} );
    @if (defined $uv_keyable)
    nAttr.setKeyable($uv_keyable);
    @else
    nAttr.setKeyable(true);
    @endif
    @if (defined $uv_storable)
    nAttr.setStorable($uv_storable);
    @else
    nAttr.setStorable(true);
    @endif
    nAttr.setWritable( true );
    @if (defined $uv_connectable)
    nAttr.setConnectable($uv_connectable);
    @else
    nAttr.setConnectable(true);
    @endif
    @if (defined $uv_min)
    nAttr.setMin($uv_min);
    @endif
    @if (defined $uv_max)
    nAttr.setMax($uv_max);
    @endif
    @if ( defined $uv_value0 )
    nAttr.setDefault($uv_value0, $uv_value1);
    @else
    nAttr.setDefault(0.0f, 0.0f);
    @endif
    @if ( defined $uv_renderSource )
    nAttr.setRenderSource($uv_renderSource);
    @endif
    @endif

@end

     //Create all int attributes here:
@foreach int_list
    @if( !defined $int_attribute || $int_attribute eq "true" )
    a$int_name = nAttr.create( "$int_long", "$int_short", MFnNumericData::kShort);
    @if (defined $int_keyable)
    nAttr.setKeyable($int_keyable);
    @else
    nAttr.setKeyable(true);
    @endif
    @if (defined $int_storable)
    nAttr.setStorable($int_storable);
    @else
    nAttr.setStorable(true);
    @endif
    @if (defined $int_connectable)
    nAttr.setConnectable($int_connectable);
    @else
    nAttr.setConnectable(true);
    @endif
    @if (defined $int_min)
    nAttr.setMin($int_min);
    @else
    nAttr.setMin(0);
    @endif
    @if (defined $int_max)
    nAttr.setMax($int_max);
    @else
    nAttr.setMax(1);
    @endif
    @if (defined $int_value)
    nAttr.setDefault($int_value);
    @else
    nAttr.setDefault(0);
    @endif
    @endif

@end

     //Create all enum attributes here:
@foreach enum_list
    @if( !defined $enum_attribute || $enum_attribute eq "true" )
    @if( !defined $enum_default )
    a$enum_name = eAttr.create( "$enum_long", "$enum_short", 0 );
    @else
    a$enum_name = eAttr.create( "$enum_long", "$enum_short", $enum_default );
    @endif
    @if( defined $enum_keyable )
    eAttr.setKeyable($enum_keyable);
    eAttr.setConnectable($enum_keyable);
    @else
    eAttr.setKeyable(false);
    eAttr.setConnectable(false);
    @endif
    @if (defined $enum_storable)
    eAttr.setStorable($enum_storable);
    @else
    eAttr.setStorable(true);
    @endif
    @perl my $count = $enum_valuenum;
    @perl --$count;
    @perl while( $count >= 0 ){
    eAttr.addField( "${"enum_value".$count}", $count );
    @perl --$count;
    @perl }
    @endif

@end
 
     //Create all StringArray attributes here:
@foreach strarray_list
    @if( !defined $strarray_attribute || $strarray_attribute eq "true" )
    a$strarray_name = tAttr.create( "$strarray_long", "$strarray_short", MFnData::kStringArray);
    tAttr.setHidden(true);
    tAttr.setReadable(true);
    tAttr.setWritable(false);
    @perl my $count = $strarray_valuenum;
    @perl my $str;
    @perl my $name;
    @perl --$count;
    @perl while( $count >= 0 ){
    @perl $name = "strarray_value".$count;
    @perl if( !defined $str ){
    @perl   $str = "\"$$name\"";
    @perl }
    @perl else{
    @perl   $str = "$str".", "."\"$$name\"";
    @perl }
    @perl --$count;
    @perl }
    const char* ${strarray_short}char[] = { $str };
    MStringArray ${strarray_short}Strings(${strarray_short}char, $strarray_valuenum);
    tAttr.setDefault(strarray.create(${strarray_short}Strings));
    @endif

@end

    //Add all texture attributes here:
@foreach texture_list
    @if( !defined $texture_attribute || $texture_attribute eq "true" )
    addAttribute( a$texture_name );
    @endif
@end

    //Add all texture attributes here:
@foreach color_list
    @if( !defined $color_attribute || $color_attribute eq "true" )
    addAttribute( a$color_name );
    @endif
@end

    //Add all bool attributes here:
@foreach bool_list
    @if( !defined $bool_attribute || $bool_attribute eq "true" )
    addAttribute( a$bool_name );
    @endif
@end

     //Add all float attributes here:
@foreach float_list
    @if( !defined $float_attribute || $float_attribute eq "true" )
    addAttribute( a$float_name );
    @endif
@end

     //Add all uv attributes here:
@foreach uv_list
    @if( !defined $uv_attribute || $uv_attribute eq "true" )
    addAttribute( aUV$uv_name );
    @endif
@end

     //Add all int attributes here:
@foreach int_list
    @if( !defined $int_attribute || $int_attribute eq "true" )
    addAttribute( a$int_name );
    @endif
@end

     //Add all enum attributes here:
@foreach enum_list
    @if( !defined $enum_attribute || $enum_attribute eq "true" )
    addAttribute( a$enum_name );
    @endif
@end
 
     //Add all StringArray attributes here:
@foreach strarray_list
    @if( !defined $strarray_attribute || $strarray_attribute eq "true" )
    addAttribute( a$strarray_name );
    @endif
@end

    // attributeAffects for all texture attributes here:
@foreach texture_list
    @if( !defined $texture_attribute || $texture_attribute eq "true" )
    @if ( defined $texture_affectnum )
    @perl my $affectnum = $texture_affectnum;
    @perl --$affectnum;
    @perl while( $affectnum >= 0 ){
    attributeAffects ( a$texture_name, ${"texture_affect".${affectnum}} );
    attributeAffects ( a${texture_name}R, ${"texture_affect".${affectnum}}R );
    attributeAffects ( a${texture_name}G, ${"texture_affect".${affectnum}}G );
    attributeAffects ( a${texture_name}B, ${"texture_affect".${affectnum}}B );
    @perl --$affectnum;
    @perl }
    @endif
    @endif
@end

    //attributeAffects for all texture attributes here:
@foreach color_list
    @if( !defined $color_attribute || $color_attribute eq "true" )
    @if ( defined $color_affectnum )
    @perl my $affectnum = $color_affectnum;
    @perl --$affectnum;
    @perl while( $affectnum >= 0 ){
    attributeAffects ( a$color_name, ${"color_affect".${affectnum}} );
    attributeAffects ( a${color_name}R, ${"color_affect".${affectnum}}R );
    attributeAffects ( a${color_name}G, ${"color_affect".${affectnum}}G );
    attributeAffects ( a${color_name}B, ${"color_affect".${affectnum}}B );
    @perl --$affectnum;
    @perl }
    @endif
    @endif
@end

    //attributeAffects for all bool attributes here:
@foreach bool_list
    @if( !defined $bool_attribute || $bool_attribute eq "true" )
    @if ( defined $bool_affectnum )
    @perl my $affectnum = $bool_affectnum;
    @perl --$affectnum;
    @perl while( $affectnum >= 0 ){
    attributeAffects ( a$bool_name, ${"bool_affect".$affectnum} );
    @perl --$affectnum;
    @perl }
    @endif
    @endif
@end

     //attributeAffects for  all float attributes here:
@foreach float_list
    @if( !defined $float_attribute || $float_attribute eq "true" )
    @if ( defined $float_affectnum )
    @perl my $affectnum = $float_affectnum;
    @perl --$affectnum;
    @perl while( $affectnum >= 0 ){  
    attributeAffects ( a$float_name, ${"float_affect".$affectnum} );
    @perl --$affectnum;
    @perl }
    @endif
    @endif
@end

     //attributeAffects for  all uv attributes here:
@foreach uv_list
    @if( !defined $uv_attribute || $uv_attribute eq "true" )
    @if ( defined $uv_affectnum )
    @perl my $affectnum = $uv_affectnum;
    @perl --$affectnum;
    @perl while( $affectnum >= 0 ){  
    attributeAffects ( aUV$uv_name, ${"uv_affect".$affectnum} );
    @perl --$affectnum;
    @perl }
    @endif
    @endif
@end

     //attributeAffects for  all int attributes here:
@foreach int_list
    @if( !defined $int_attribute || $int_attribute eq "true" )
    @if ( defined $int_affectnum )
    @perl my $affectnum = $int_affectnum;
    @perl --$affectnum;
    @perl while( $affectnum >= 0 ){
    attributeAffects ( a$int_name, ${"int_affect".$affectnum} );
    @perl --$affectnum;
    @perl }
    @endif
    @endif
@end

     //attributeAffects for  all enum attributes here:
@foreach enum_list
    @if( !defined $enum_attribute || $enum_attribute eq "true" )
    @if ( defined $enum_affectnum )
    @perl my $affectnum = $enum_affectnum;
    @perl --$affectnum;
    @perl while( $affectnum >= 0 ){
    attributeAffects ( a$enum_name, ${"enum_affect".$affectnum} );
    @perl --$affectnum;
    @perl }
    @endif
    @endif
@end
 
     //attributeAffects for all StringArray attributes here:
@foreach strarray_list
    @if( !defined $strarray_attribute || $strarray_attribute eq "true" )
    @if ( defined $strarray_affectnum )
    @perl my $affectnum = $strarray_affectnum;
    @perl --$affectnum;
    @perl while( $affectnum >= 0 ){
    attributeAffects ( a$strarray_name, ${"strarray_affect".$affectnum} );
    @perl --$affectnum;
    @perl }
    @endif
    @endif
@end

    exporterAttributes();
    
    return MS::kSuccess;
}

//

#define BOOLATTR(code, source)  aExport##code = nAttr.create( #code , "export"#code , MFnNumericData::kBoolean); \\
                                         nAttr.setStorable(false);                                                     \\
                                         cAttr.addChild(aExport##code);                                                \\
                                         addAttribute(aExport##code);                                                  \\
                                         attributeAffects(source, aExport);                                            \\
                                         attributeAffects(aExport##code, aExport);

#define FIXEDBOOLATTR(code, value)  aExport##code = nAttr.create( #code , "export"#code , MFnNumericData::kBoolean); \\
                                         nAttr.setStorable(false);                                                     \\
                                         cAttr.addChild(aExport##code);                                                \\
                                         addAttribute(aExport##code);                                                  \\
                                         nAttr.setDefault(value);                                                      \\
                                         attributeAffects(aExport##code, aExport);

#define INTATTR(code, source)  aExport##code = nAttr.create( #code , "export"#code , MFnNumericData::kLong); \\
                                         nAttr.setStorable(false);                                                     \\
                                         cAttr.addChild(aExport##code);                                                \\
                                         addAttribute(aExport##code);                                                  \\
                                         attributeAffects(source, aExport);                                            \\
                                         attributeAffects(aExport##code, aExport);

#define FIXEDINTATTR(code, value)  aExport##code = nAttr.create( #code , "export"#code , MFnNumericData::kLong); \\
                                         nAttr.setStorable(false);                                                     \\
                                         cAttr.addChild(aExport##code);                                                \\
                                         addAttribute(aExport##code);                                                  \\
                                         nAttr.setDefault(value);                                                      \\
                                         attributeAffects(aExport##code, aExport);

#define COLORATTR(code, source) \\
    aExport##code##R = nAttr.create( #code"R" , "export"#code"R" , MFnNumericData::kFloat); \\
    aExport##code##G = nAttr.create( #code"G" , "export"#code"G" , MFnNumericData::kFloat); \\
    aExport##code##B = nAttr.create( #code"B" , "export"#code"B" , MFnNumericData::kFloat); \\
    aExport##code  = nAttr.create( #code     , "export"#code, aExport##code##R, aExport##code##G, aExport##code##B); \\
    nAttr.setUsedAsColor(true);                                                     \\
    nAttr.setStorable(false);                                                       \\
    cAttr.addChild(aExport##code);                                                  \\
    addAttribute(aExport##code);                                                    \\
    attributeAffects(source, aExport);                                              \\
    attributeAffects(aExport##code, aExport);             

#define FIXEDCOLORATTR(code) \\
    aExport##code##R = nAttr.create( #code"R" , "export"#code"R" , MFnNumericData::kFloat); \\
    aExport##code##G = nAttr.create( #code"G" , "export"#code"G" , MFnNumericData::kFloat); \\
    aExport##code##B = nAttr.create( #code"B" , "export"#code"B" , MFnNumericData::kFloat); \\
    aExport##code  = nAttr.create( #code     , "export"#code, aExport##code##R, aExport##code##G, aExport##code##B); \\
    nAttr.setUsedAsColor(true);                                                     \\
    nAttr.setStorable(false);                                                       \\
    cAttr.addChild(aExport##code);                                                  \\
    addAttribute(aExport##code);                                                    \\
    attributeAffects(aExport##code, aExport);

#define FLOATATTR(code, source) aExport##code = nAttr.create( #code , "export"#code , MFnNumericData::kFloat); \\
                                          nAttr.setStorable(false);                                                       \\
                                          cAttr.addChild(aExport##code);                                                 \\
                                          addAttribute(aExport##code);                                                   \\
                                          attributeAffects(source, aExport);                                             \\
                                          attributeAffects(aExport##code, aExport);

#define FIXEDFLOATATTR(code, value) aExport##code = nAttr.create( #code , "export"#code , MFnNumericData::kFloat); \\
                                          nAttr.setStorable(false);                                                       \\
                                          cAttr.addChild(aExport##code);                                                 \\
                                          addAttribute(aExport##code);                                                   \\
                                          nAttr.setDefault(value);                                                       \\
                                          attributeAffects(aExport##code, aExport);
//
// Export some attributes
/////////////////////////////////////////////////////////////////////////////
void
${shadername}::exporterAttributes()
{
    MFnNumericAttribute nAttr; 
    MFnCompoundAttribute cAttr;

    // The exporter data
    aExport = cAttr.create("shaderExport", "sxp");
    addAttribute(aExport);

    //export color attributes
@foreach color_list
    @if ( defined $color_fourCC )
    @if ( !defined $color_attribute || $color_attribute eq "true" )
    COLORATTR($color_fourCC, a${color_name});
    @else
    FIXEDCOLORATTR($color_fourCC);
    @endif
    @endif
@end

    //export float attributes
@foreach float_list
    @if ( defined $float_fourCC )
    @if ( !defined $float_attribute || $float_attribute eq "true" )
    FLOATATTR($float_fourCC, a${float_name});
    @else
    FIXEDFLOATATTR($float_fourCC, $float_value );
    @endif
    @endif
@end

    //export int attributes
@foreach int_list
    @if ( defined $int_fourCC )
    @if ( !defined $int_attribute || $int_attribute eq "true" )
    INTATTR($int_fourCC, a${int_name});
    @else
    FIXEDINTATTR($int_fourCC, $int_value );
    @endif
    @endif
@end

    //export bool attributes
@foreach bool_list   
    @if ( defined $bool_fourCC )
    @if ( !defined $bool_attribute || $bool_attribute eq "true" )
    BOOLATTR($bool_fourCC, a${bool_name});
    @else
    @perl my $value;
    @perl if( $bool_value eq "true" ){
    @perl $value = 1;
    @perl }
    @perl else{
    @perl $value = 0;
    @perl }
    FIXEDBOOLATTR($bool_fourCC, $value);
    @endif
    @endif
@end

    //export enum attributes
@foreach enum_list
    @if ( defined $enum_fourCC )
    @if ( !defined $enum_attribute || $enum_attribute eq "true" )
    INTATTR($enum_fourCC, a${enum_name});
    @else
    FIXEDINTATTR($enum_fourCC, $enum_default);
    @endif
    @endif
@end

}

//
// Compute all attributes for exporting:
/////////////////////////////////////////////////////////////////////////////
MStatus ${shadername}::compute(
const MPlug&      plug,
        MDataBlock& block ) 
{ 

    if( compute_output( plug, block ) == MS::kSuccess )
    {
        return MS::kSuccess;
    }
    //compute all bool attributes
@foreach bool_list
    @if( defined $bool_fourCC && (!defined $bool_attribute || $bool_attribute eq "true" ) )
    else if(plug == aExport$bool_fourCC)
    {
        MDataHandle out${bool_fourCC}Handle = block.outputValue( aExport$bool_fourCC );
        short& value = out${bool_fourCC}Handle.asShort();
        value = block.inputValue( a$bool_name ).asBool();
        out${bool_fourCC}Handle.setClean();
    }
    @endif
@end
    //compute all float attributes
@foreach float_list
    @if( defined $float_fourCC && (!defined $float_attribute || $float_attribute eq "true" ) )
    else if (plug == aExport$float_fourCC)
    {
        MDataHandle out${float_fourCC}Handle = block.outputValue( aExport$float_fourCC );
        float& value = out${float_fourCC}Handle.asFloat();
        value = block.inputValue ( a$float_name ).asFloat();
        out${float_fourCC}Handle.setClean();
    }
    @endif
@end
    //compute all int attributes
@foreach int_list
    @if( defined $int_fourCC && (!defined $int_attribute || $int_attribute eq "true" ) )
    else if (plug == aExport$int_fourCC)
    {
        MDataHandle out${int_fourCC}Handle = block.outputValue( aExport$int_fourCC );
        short& value = out${int_fourCC}Handle.asShort();
        value = block.inputValue ( a$int_name ).asShort();
        out${int_fourCC}Handle.setClean();
    }
    @endif
@end 
    //compute all color attributes
@foreach color_list
    @if( defined $color_fourCC && (!defined $color_attribute || $color_attribute eq "true" ) )
    else if((plug == aExport${color_fourCC}) || (plug == aExport${color_fourCC}R) || (plug == aExport${color_fourCC}G) || (plug == aExport${color_fourCC}B))
    {
        MDataHandle out${color_fourCC}Handle = block.outputValue( aExport${color_fourCC} );
        MFloatVector& value = out${color_fourCC}Handle.asFloatVector();
        value = block.inputValue( a$color_name ).asFloatVector();
        out${color_fourCC}Handle.setClean();
    }     
    @endif
@end
    //compute all enum attributes
@foreach enum_list
    @if( defined $enum_fourCC && (!defined $enum_attribute || $enum_attribute eq "true" ) )
    else if(plug == aExport${enum_fourCC})
    {
        MDataHandle outEnumHandle = block.outputValue( aExport${enum_fourCC} );
        short& value = outEnumHandle.asShort();
        value = block.inputValue( a$enum_name ).asShort();
        outEnumHandle.setClean();
    }
    @endif
@end
    else 
    {
        return MS::kUnknownParameter;
    }
    return MS::kSuccess;
}


