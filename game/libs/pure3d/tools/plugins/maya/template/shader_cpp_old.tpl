@perl use Wrap;
@perl $Wrap::columns = 80;
@perl sub max { my($a,$b) = @_; ($a>$b)?($a):($b);}
@perl sub pad { my($len,$str) = @_; sprintf("%-${len}s",$str); }
@perl ($sec,$min,$hour,$mday,$mon,$year,$wday,$yday,$isdst) = localtime(time);
@perl $year = $year+1900;
@perl my $shadername;
@perl my $filename;
@perl my $headerfilename;
@perl my $shaderid;
@perl my $pddiname;
@perl my $registername;
@perl my $decription;
@foreach shader_list 
    @perl $shadername = "P3D$shader_name";
    @perl $filename = "p3d$shader_name";
    @perl $headerfilename = "p3d$shader_name";
    @perl $filename .= ".cpp";
    @perl $headerfilename .= ".hpp";
    @perl $shaderid = $shader_id;
    @perl $pddiname = $shader_pddiShaderName;
    @perl $registername = $shader_registerName;
    @perl $description = $shader_description;
@end
@perl print "Generating $filename\n";
@openfile $filename 
/*===========================================================================
    Automatically generated by Jeeves, don't edit.  Edit ${shadername}.sc instead

    File: $filename

    $description
    
    Copyright (c) $year Radical Entertainment, Inc.  All rights reserved.

===========================================================================*/
#include <math.h>
#include <maya/MString.h>
#include <maya/MTypeId.h>
#include <maya/MPlug.h>
#include <maya/MDataBlock.h>
#include <maya/MDataHandle.h>
#include <maya/MArrayDataHandle.h>
#include <maya/MFnCompoundAttribute.h>
#include <maya/MFnEnumAttribute.h>
#include <maya/MFnTypedAttribute.h>
#include <maya/MFnStringData.h>
#include <maya/MFnStringArrayData.h>
#include <maya/MFnNumericAttribute.h>
#include <maya/MFnLightDataAttribute.h>
#include <maya/MFloatVector.h>
#include <maya/MFnPlugin.h>
#include <maya/MGlobal.h>
#include <maya/MDGMessage.h>
#include <maya/MFnDependencyNode.h>
#include "$headerfilename"


MTypeId ${shadername}::id( $shaderid );

void ${shadername}::postConstructor( )
{
    setMPSafe(true);
}


//
// Declare static member variables:
/////////////////////////////////////////////////////////////////////////////
    
// Declare All New Added Textures:
@foreach texture_list
MObject  ${shadername}::a${texture_name};
MObject  ${shadername}::a${texture_name}R;
MObject  ${shadername}::a${texture_name}G;
MObject  ${shadername}::a${texture_name}B;

@end   
// Declare All New Added Colors:
@foreach color_list
MObject  ${shadername}::a${color_name}R;
MObject  ${shadername}::a${color_name}G;
MObject  ${shadername}::a${color_name}B;
MObject  ${shadername}::a${color_name};
MObject  ${shadername}::aExport$color_fourCC;        //export
@end
// Declare All New Added enums:
@foreach enum_list
MObject  ${shadername}::a${enum_name};
MObject  ${shadername}::aExport$enum_fourCC;        //export
@end   

// Declare All New Added floats:
@foreach float_list
MObject  ${shadername}::a${float_name};
MObject  ${shadername}::aExport$float_fourCC;        //export
@end   
  
// Declare All New Added ints:
@foreach int_list
MObject  ${shadername}::a${int_name};
MObject  ${shadername}::aExport$int_fourCC;        //export
@end  

// Declare All New Added  bool:
@foreach bool_list
MObject  ${shadername}::a${bool_name};
MObject  ${shadername}::aExport$bool_fourCC;        //export
@end  

MObject  ${shadername}::aAmbientR;
MObject  ${shadername}::aAmbientG;
MObject  ${shadername}::aAmbientB;
MObject  ${shadername}::aAmbient;

MObject  ${shadername}::aDiffuseR;
MObject  ${shadername}::aDiffuseG;
MObject  ${shadername}::aDiffuseB;
MObject  ${shadername}::aDiffuse;

MObject  ${shadername}::aEmissiveR;
MObject  ${shadername}::aEmissiveG;
MObject  ${shadername}::aEmissiveB;
MObject  ${shadername}::aEmissive;

MObject  ${shadername}::aSpecularR;
MObject  ${shadername}::aSpecularG;
MObject  ${shadername}::aSpecularB;
MObject  ${shadername}::aSpecular;

MObject  ${shadername}::aShininess;
MObject  ${shadername}::aUVMode;
MObject  ${shadername}::aFilterMode;
MObject  ${shadername}::aShadeMode;
MObject  ${shadername}::aBlendMode;
MObject  ${shadername}::aAlphaTest;
MObject  ${shadername}::aAlphaCompare;
MObject  ${shadername}::aProceduralXRes;
MObject  ${shadername}::aProceduralYRes;


MObject  ${shadername}::aOutColor;
MObject  ${shadername}::aOutColorR;
MObject  ${shadername}::aOutColorG;
MObject  ${shadername}::aOutColorB;
MObject  ${shadername}::aOutTrans;
MObject  ${shadername}::aOutTransR;
MObject  ${shadername}::aOutTransG;
MObject  ${shadername}::aOutTransB;

MObject  ${shadername}::aPDDIShaderName;
MObject  ${shadername}::aExport;
MObject  ${shadername}::aExportUVMD;
MObject  ${shadername}::aExportFIMD;
MObject  ${shadername}::aExportSHMD;
MObject  ${shadername}::aExportAMBI;
MObject  ${shadername}::aExportAMBIR;
MObject  ${shadername}::aExportAMBIG;
MObject  ${shadername}::aExportAMBIB;
MObject  ${shadername}::aExportDIFF;
MObject  ${shadername}::aExportDIFFR;
MObject  ${shadername}::aExportDIFFG;
MObject  ${shadername}::aExportDIFFB;
MObject  ${shadername}::aExportEMIS;
MObject  ${shadername}::aExportEMISR;
MObject  ${shadername}::aExportEMISG;
MObject  ${shadername}::aExportEMISB;
MObject  ${shadername}::aExportSPEC;
MObject  ${shadername}::aExportSPECR;
MObject  ${shadername}::aExportSPECG;
MObject  ${shadername}::aExportSPECB;
MObject  ${shadername}::aExportSHIN;
MObject  ${shadername}::aExportBLMD;
MObject  ${shadername}::aExportATST;
MObject  ${shadername}::aExportACMP;

MObject  ${shadername}::aIsTranslucent;
MObject  ${shadername}::aVertexNeeds;
MObject  ${shadername}::aVertexMask;
MObject  ${shadername}::aTextureAttributes;
MObject  ${shadername}::aTexturePlugs;
MObject  ${shadername}::aTextureAlphaPlugs;

MObject  ${shadername}::aPointCamera;
MObject  ${shadername}::aPointCameraX;
MObject  ${shadername}::aPointCameraY;
MObject  ${shadername}::aPointCameraZ;
MObject  ${shadername}::aNormalCamera;
MObject  ${shadername}::aNormalCameraX;
MObject  ${shadername}::aNormalCameraY;
MObject  ${shadername}::aNormalCameraZ;
MObject  ${shadername}::aTriangleNormalCamera;
MObject  ${shadername}::aTriangleNormalCameraX;
MObject  ${shadername}::aTriangleNormalCameraY;
MObject  ${shadername}::aTriangleNormalCameraZ;
MObject  ${shadername}::aLightData;
MObject  ${shadername}::aLightDirection;
MObject  ${shadername}::aLightDirectionX;
MObject  ${shadername}::aLightDirectionY;
MObject  ${shadername}::aLightDirectionZ;
MObject  ${shadername}::aLightIntensity; 
MObject  ${shadername}::aLightIntensityR;
MObject  ${shadername}::aLightIntensityG;
MObject  ${shadername}::aLightIntensityB;
MObject  ${shadername}::aLightAmbient;
MObject  ${shadername}::aLightDiffuse;
MObject  ${shadername}::aLightSpecular;
MObject  ${shadername}::aLightShadowFraction;
MObject  ${shadername}::aPreShadowIntensity;
MObject  ${shadername}::aLightBlindData;

MObject ${shadername}::aObjectId;

//
// Constructor:
/////////////////////////////////////////////////////////////////////////////
${shadername}::$shadername()
{
}

//
// Destructor:
/////////////////////////////////////////////////////////////////////////////
${shadername}::~$shadername()
{
}

//
// Creator:
/////////////////////////////////////////////////////////////////////////////
void * ${shadername}::creator()
{
     return new $shadername();
}

//
// Intialize all attributes:
/////////////////////////////////////////////////////////////////////////////
MStatus ${shadername}::initialize()
{
    MFnNumericAttribute nAttr; 
    MFnEnumAttribute eAttr; 
    MFnLightDataAttribute lAttr;
    MFnTypedAttribute tAttr;
    MFnStringData str;
    MFnStringArrayData strarray;

    //Create all texture attributes here:
@foreach texture_list
    a${texture_name}R = nAttr.create( "${texture_long}R", "${texture_short}r",MFnNumericData::kFloat);
    a${texture_name}G = nAttr.create( "${texture_long}G", "${texture_short}g",MFnNumericData::kFloat);
    a${texture_name}B = nAttr.create( "${texture_long}B", "${texture_short}b",MFnNumericData::kFloat);
    
    a$texture_name = nAttr.create( "$texture_long", "$texture_short", a${texture_name}R , a${texture_name}G, a${texture_name}B );
    nAttr.setKeyable(true);
    nAttr.setStorable(true);
    @if ( defined $texture_value0 )
    nAttr.setDefault($texture_value0, $texture_value1, $texture_value2);
    @else
    nAttr.setDefault(0.0f, 0.0f, 0.0f);
    @endif
    nAttr.setUsedAsColor(true);

@end

    //Create all bool attributes here:
@foreach bool_list
    a$bool_name = nAttr.create( "$bool_long", "$bool_short", MFnNumericData::kBoolean);
    nAttr.setKeyable(true);
    nAttr.setStorable(true);
    nAttr.setConnectable(false);
    @if (defined $bool_value)
    nAttr.setDefault($bool_value);
    @else
    nAttr.setDefault(true);
    @endif

@end

     //Create all float attributes here:
@foreach float_list
    a$float_name = nAttr.create( "$float_long", "$float_short", MFnNumericData::kFloat);
    nAttr.setKeyable(true);
    nAttr.setStorable(true);
    nAttr.setConnectable(false);
    @if (defined $float_min)
    nAttr.setMin($float_min);
    @else
    nAttr.setMin(0.0f);
    @endif
    @if (defined $float_max)
    nAttr.setMax($float_max);
    @else
    nAttr.setMax(1.0f);
    @endif
    @if (defined $float_value)
    nAttr.setDefault($float_value);
    @else
    nAttr.setDefault(0.0f);
    @endif

@end

     //Create all int attributes here:
@foreach int_list
    a$int_name = nAttr.create( "$int_long", "$int_short", MFnNumericData::kint);
    nAttr.setKeyable(true);
    nAttr.setStorable(true);
    nAttr.setConnectable(false);
    @if (defined $int_min)
    nAttr.setMin($int_min);
    @else
    nAttr.setMin(0);
    @endif
    @if (defined $int_max)
    nAttr.setMax($int_max);
    @else
    nAttr.setMax(1);
    @endif
    @if (defined $int_value)
    nAttr.setDefault($int_value);
    @else
    nAttr.setDefault(0);
    @endif

@end


    aAmbientR = nAttr.create( "ambientR", "ar",MFnNumericData::kFloat);
    nAttr.setKeyable(true);
    nAttr.setStorable(true);
    nAttr.setDefault(1.0f);

    aAmbientG = nAttr.create( "ambientG", "ag",MFnNumericData::kFloat);
    nAttr.setKeyable(true);
    nAttr.setStorable(true);
    nAttr.setConnectable(false);
    nAttr.setDefault(1.0f);

    aAmbientB = nAttr.create( "ambientB", "ab",MFnNumericData::kFloat);
    nAttr.setKeyable(true);
    nAttr.setStorable(true);
    nAttr.setConnectable(false);
    nAttr.setDefault(1.0f);

    aAmbient = nAttr.create( "ambient", "a", aAmbientR, aAmbientG, aAmbientB);
    nAttr.setKeyable(true);
    nAttr.setStorable(true);
    nAttr.setConnectable(false);
    nAttr.setDefault(1.0f, 1.0f, 1.0f);
    nAttr.setUsedAsColor(true);


    aDiffuseR = nAttr.create( "diffuseR", "dr",MFnNumericData::kFloat);
    nAttr.setKeyable(true);
    nAttr.setStorable(true);
    nAttr.setConnectable(false);
    nAttr.setDefault(1.0f);

    aDiffuseG = nAttr.create( "diffuseG", "dg",MFnNumericData::kFloat);
    nAttr.setKeyable(true);
    nAttr.setStorable(true);
    nAttr.setConnectable(false);
    nAttr.setDefault(1.0f);

    aDiffuseB = nAttr.create( "diffuseB", "db",MFnNumericData::kFloat);
    nAttr.setKeyable(true);
    nAttr.setStorable(true);
    nAttr.setConnectable(false);
    nAttr.setDefault(1.0f);

    aDiffuse = nAttr.create( "diffuse", "d", aDiffuseR, aDiffuseG, aDiffuseB);
    nAttr.setKeyable(true);
    nAttr.setStorable(true);
    nAttr.setConnectable(false);
    nAttr.setDefault(1.0f, 1.0f, 1.0f);
    nAttr.setUsedAsColor(true);

    aEmissiveR = nAttr.create( "emissiveR", "er",MFnNumericData::kFloat);
    nAttr.setKeyable(true);
    nAttr.setStorable(true);
    nAttr.setConnectable(false);
    nAttr.setDefault(0.0f);

    aEmissiveG = nAttr.create( "emissiveG", "eg",MFnNumericData::kFloat);
    nAttr.setKeyable(true);
    nAttr.setStorable(true);
    nAttr.setConnectable(false);
    nAttr.setDefault(0.0f);

    aEmissiveB = nAttr.create( "emissiveB", "eb",MFnNumericData::kFloat);
    nAttr.setKeyable(true);
    nAttr.setStorable(true);
    nAttr.setConnectable(false);
    nAttr.setDefault(0.0f);

    aEmissive = nAttr.create( "emissive", "e", aEmissiveR, aEmissiveG, aEmissiveB);
    nAttr.setKeyable(true);
    nAttr.setStorable(true);
    nAttr.setConnectable(false);
    nAttr.setDefault(0.0f, 0.0f, 0.0f);
    nAttr.setUsedAsColor(true);


    aSpecularR = nAttr.create( "specularR", "sr",MFnNumericData::kFloat);
    nAttr.setKeyable(true);
    nAttr.setStorable(true);
    nAttr.setConnectable(false);
    nAttr.setDefault(0.0f);

    aSpecularG = nAttr.create( "specularG", "sg",MFnNumericData::kFloat);
    nAttr.setKeyable(true);
    nAttr.setStorable(true);
    nAttr.setConnectable(false);
    nAttr.setDefault(0.0f);

    aSpecularB = nAttr.create( "specularB", "sb",MFnNumericData::kFloat);
    nAttr.setKeyable(true);
    nAttr.setStorable(true);
    nAttr.setConnectable(false);
    nAttr.setDefault(0.0f);

    aSpecular = nAttr.create( "specular", "s", aSpecularR, aSpecularG, aSpecularB);
    nAttr.setKeyable(true);
    nAttr.setStorable(true);
    nAttr.setDefault(0.0f, 0.0f, 0.0f);
    nAttr.setConnectable(false);
    nAttr.setUsedAsColor(true);


    aShininess = nAttr.create( "shininess", "sh", MFnNumericData::kFloat);
    nAttr.setKeyable(true);
    nAttr.setStorable(true);
    nAttr.setConnectable(false);
    nAttr.setMin(0.0f);
    nAttr.setMax(200.0f);
    nAttr.setDefault(10.0f);

    aUVMode = eAttr.create( "uvMode", "uv", 0 );
    eAttr.setKeyable(true);
    eAttr.setStorable(true);
    eAttr.setConnectable(false);
    eAttr.addField("Tile", 0);           // Maybe change this to use pddienum.hpp?
    eAttr.addField("Clamp", 1);

    aFilterMode = eAttr.create( "filterMode", "fm", 1);
    eAttr.setKeyable(true);
    eAttr.setStorable(true);
    eAttr.setConnectable(false);
    eAttr.addField("None", 0);
    eAttr.addField("Bilinear", 1);
    eAttr.addField("Mipmap", 2);
    eAttr.addField("Mipmap Bilinear", 3);
    eAttr.addField("Mipmap Trilinear", 4);


    aShadeMode = eAttr.create( "shadeMode", "sm", 1);
    eAttr.setKeyable(true);
    eAttr.setStorable(true);
    eAttr.setConnectable(false);
    eAttr.addField("Flat", 0);
    eAttr.addField("Gouraud", 1);

    aBlendMode = eAttr.create( "blendMode", "bm", 0);
    eAttr.setKeyable(true);
    eAttr.setStorable(true);
    eAttr.setConnectable(false);
    eAttr.addField("None", 0);           // should use pddienum.hpp
    eAttr.addField("Alpha", 1);
    eAttr.addField("Add", 2);
    eAttr.addField("Subtract", 3);
    eAttr.addField("Modulate", 4);

    aAlphaTest = nAttr.create( "alphaTest", "at", MFnNumericData::kBoolean);
    nAttr.setKeyable(true);
    nAttr.setStorable(true);
    nAttr.setConnectable(false);
    nAttr.setDefault(false);

    aAlphaCompare = eAttr.create( "alphaCompare", "ac", 4);
    eAttr.setKeyable(true);
    eAttr.setStorable(true);
    eAttr.setConnectable(false);
    eAttr.addField("None", 0);
    eAttr.addField("Always", 1);
    eAttr.addField("Less", 2);
    eAttr.addField("LessEqual", 3);
    eAttr.addField("Greater",4);
    eAttr.addField("GreaterEqual", 5);
    eAttr.addField("Equal", 6);
    eAttr.addField("NotEqual", 7);

    aProceduralXRes = eAttr.create( "proceduralXRes", "pxres", 0);
    eAttr.setKeyable(true);
    eAttr.setStorable(true);
    eAttr.setConnectable(false);
    eAttr.addField("global", 0);
    eAttr.addField("8",1);
    eAttr.addField("16", 2);
    eAttr.addField("32", 3);
    eAttr.addField("64", 4);
    eAttr.addField("128", 5);
    eAttr.addField("256", 6);
    eAttr.addField("512", 7);
    eAttr.addField("1024", 8);

    aProceduralYRes = eAttr.create( "proceduralYRes", "pyres", 0);
    eAttr.setKeyable(true);
    eAttr.setStorable(true);
    eAttr.setConnectable(false);
    eAttr.addField("global", 0);
    eAttr.addField("8",1);
    eAttr.addField("16", 2);
    eAttr.addField("32", 3);
    eAttr.addField("64", 4);
    eAttr.addField("128", 5);
    eAttr.addField("256", 6);
    eAttr.addField("512", 7);
    eAttr.addField("1024", 8);

    // output and internal attributes

    aOutColorR = nAttr.create( "outColorR", "ocr", MFnNumericData::kFloat);
    aOutColorG = nAttr.create( "outColorG", "ocg", MFnNumericData::kFloat);
    aOutColorB = nAttr.create( "outColorB", "ocb", MFnNumericData::kFloat);

    aOutColor = nAttr.create( "outColor","oc", aOutColorR, aOutColorG, aOutColorB);
    nAttr.setHidden(false);
    nAttr.setReadable(true);
    nAttr.setWritable(false);

    aOutTransR = nAttr.create( "outTransparencyR","otr", MFnNumericData::kFloat);
    aOutTransG = nAttr.create( "outTransparencyG","otg", MFnNumericData::kFloat);
    aOutTransB = nAttr.create( "outTransparencyB","otb", MFnNumericData::kFloat);
    aOutTrans = nAttr.create( "outTransparency","ot", aOutTransR,aOutTransG,aOutTransB);
    nAttr.setHidden(false);
    nAttr.setReadable(true);
    nAttr.setWritable(false);

    aPDDIShaderName = tAttr.create( "pddiShaderName", "psn", MFnData::kString);
    tAttr.setHidden(true);
    tAttr.setReadable(true);
    tAttr.setWritable(false);
    tAttr.setDefault(str.create("simple"));

    aIsTranslucent = nAttr.create( "isTranslucent", "trans", MFnNumericData::kBoolean);
    nAttr.setHidden(true);
    nAttr.setStorable(false);
    nAttr.setDefault(false);

    aVertexNeeds = nAttr.create( "vertexNeeds", "vn", MFnNumericData::kLong);
    nAttr.setHidden(true);
    nAttr.setStorable(false);
    nAttr.setDefault(0);

    aVertexMask = nAttr.create( "vertexMask", "vm", MFnNumericData::kLong);
    nAttr.setHidden(true);
    nAttr.setStorable(false);
    nAttr.setDefault(0);

    aTextureAttributes = tAttr.create( "textureAttributes", "txat", MFnData::kStringArray);
    tAttr.setHidden(true);
    tAttr.setReadable(true);
    tAttr.setWritable(false);
    const char* txatchar[] = { "TEX" };
    MStringArray txatStrings(txatchar, 1);
    tAttr.setDefault(strarray.create(txatStrings));

    aTexturePlugs = tAttr.create( "texturePlugs", "txpl", MFnData::kStringArray);
    tAttr.setHidden(true);
    tAttr.setReadable(true);
    tAttr.setWritable(false);
    const char* txplchar[] = { "color" };
    MStringArray txplStrings(txplchar, 1);
    tAttr.setDefault(strarray.create(txplStrings));

    aTextureAlphaPlugs = tAttr.create( "textureAlphaPlugs", "txapl", MFnData::kStringArray);
    tAttr.setHidden(true);
    tAttr.setReadable(true);
    tAttr.setWritable(false);
    const char* txaplchar[] = { "transparency" };
    MStringArray txaplStrings(txaplchar, 1);
    tAttr.setDefault(strarray.create(txaplStrings));

    aPointCameraX = nAttr.create( "pointCameraX", "px", MFnNumericData::kFloat);
    nAttr.setStorable(false);
    nAttr.setDefault(1.0f);

    aPointCameraY = nAttr.create( "pointCameraY", "py", MFnNumericData::kFloat);
    nAttr.setStorable(false);
    nAttr.setDefault(1.0f);

    aPointCameraZ = nAttr.create( "pointCameraZ", "pz", MFnNumericData::kFloat);
    nAttr.setStorable(false);
    nAttr.setDefault(1.0f);

    aPointCamera = nAttr.create( "pointCamera","pc", 
                                          aPointCameraX, aPointCameraY, aPointCameraZ);
    nAttr.setStorable(false);
    nAttr.setDefault(1.0f, 1.0f, 1.0f);
    nAttr.setHidden(true);


    aNormalCameraX = nAttr.create( "normalCameraX", "nx", MFnNumericData::kFloat);
    nAttr.setStorable(false);
    nAttr.setDefault(1.0f);

    aNormalCameraY = nAttr.create( "normalCameraY", "ny", MFnNumericData::kFloat);
    nAttr.setStorable(false);
    nAttr.setDefault(1.0f);

    aNormalCameraZ = nAttr.create( "normalCameraZ", "nz", MFnNumericData::kFloat);
    nAttr.setStorable(false);
    nAttr.setDefault(1.0f);

    aNormalCamera = nAttr.create( "normalCamera","n", 
                                            aNormalCameraX, aNormalCameraY, aNormalCameraZ);
    nAttr.setStorable(false);
    nAttr.setDefault(1.0f, 1.0f, 1.0f);
    nAttr.setHidden(true);

    aTriangleNormalCameraX = nAttr.create( "triangleNormalCameraX", "tnx", MFnNumericData::kFloat);
    nAttr.setStorable(false);
    nAttr.setDefault(1.0f);

    aTriangleNormalCameraY = nAttr.create( "triangleNormalCameraY", "tny", MFnNumericData::kFloat);
    nAttr.setStorable(false);
    nAttr.setDefault(1.0f);

    aTriangleNormalCameraZ = nAttr.create( "triangleNormalCameraZ", "tnz", MFnNumericData::kFloat);
    nAttr.setStorable(false);
    nAttr.setDefault(1.0f);

    aTriangleNormalCamera = nAttr.create( "triangleNormalCamera","tn", 
                                            aTriangleNormalCameraX, aTriangleNormalCameraY, aTriangleNormalCameraZ);
    nAttr.setStorable(false);
    nAttr.setDefault(1.0f, 1.0f, 1.0f);
    nAttr.setHidden(true);

    aLightDirectionX = nAttr.create( "lightDirectionX", "ldx", MFnNumericData::kFloat);
    nAttr.setStorable(false);
    nAttr.setHidden(true);
    nAttr.setReadable(false);
    nAttr.setDefault(1.0f);

    aLightDirectionY = nAttr.create( "lightDirectionY", "ldy", MFnNumericData::kFloat);
    nAttr.setStorable(false);
    nAttr.setHidden(true);
    nAttr.setReadable(false);
    nAttr.setDefault(1.0f);

    aLightDirectionZ = nAttr.create( "lightDirectionZ", "ldz", MFnNumericData::kFloat);
    nAttr.setStorable(false);
    nAttr.setHidden(true);
    nAttr.setReadable(false);
    nAttr.setDefault(1.0f);

    aLightDirection = nAttr.create( "lightDirection", "ld", 
                                              aLightDirectionX, aLightDirectionY, aLightDirectionZ);
    nAttr.setStorable(false);
    nAttr.setHidden(true);
    nAttr.setReadable(false);
    nAttr.setDefault(1.0f, 1.0f, 1.0f);

    aLightIntensityR = nAttr.create( "lightIntensityR", "lir", MFnNumericData::kFloat);
    nAttr.setStorable(false);
    nAttr.setHidden(true);
    nAttr.setReadable(false);
    nAttr.setDefault(1.0f);

    aLightIntensityG = nAttr.create( "lightIntensityG", "lig", MFnNumericData::kFloat);
    nAttr.setStorable(false);
    nAttr.setHidden(true);
    nAttr.setReadable(false);
    nAttr.setDefault(1.0f);

    aLightIntensityB = nAttr.create( "lightIntensityB", "lib", MFnNumericData::kFloat);
    nAttr.setStorable(false);
    nAttr.setHidden(true);
    nAttr.setReadable(false);
    nAttr.setDefault(1.0f);

    aLightIntensity = nAttr.create( "lightIntensity", "li", 
                                              aLightIntensityR, aLightIntensityG, aLightIntensityB);
    nAttr.setStorable(false);
    nAttr.setHidden(true);
    nAttr.setReadable(false);
    nAttr.setDefault(1.0f, 1.0f, 1.0f);

    aLightAmbient = nAttr.create( "lightAmbient", "la", MFnNumericData::kBoolean);
    nAttr.setStorable(false);
    nAttr.setHidden(true);
    nAttr.setReadable(false);
    nAttr.setDefault(true);

    aLightDiffuse = nAttr.create( "lightDiffuse", "ldf", MFnNumericData::kBoolean);
    nAttr.setStorable(false);
    nAttr.setHidden(true);
    nAttr.setReadable(false);
    nAttr.setDefault(true);

    aLightSpecular = nAttr.create( "lightSpecular", "ls", MFnNumericData::kBoolean);
    nAttr.setStorable(false);
    nAttr.setHidden(true);
    nAttr.setReadable(false);
    nAttr.setDefault(false);

    aLightShadowFraction = nAttr.create("lightShadowFraction","lsf",MFnNumericData::kFloat);
    nAttr.setStorable(false);
    nAttr.setHidden(true);
    nAttr.setReadable(false);
    nAttr.setDefault(0.0f);

    aPreShadowIntensity = nAttr.create("preShadowIntensity","psi",MFnNumericData::kFloat);
    nAttr.setStorable(false);
    nAttr.setHidden(true);
    nAttr.setReadable(false);
    nAttr.setDefault(0.0f);

    aLightBlindData = nAttr.create("lightBlindData","lbld",MFnNumericData::kLong);
    nAttr.setStorable(false);
    nAttr.setHidden(true);
    nAttr.setReadable(false);
    nAttr.setDefault(0);

#ifdef MAYA_3
    aLightData = lAttr.create( "lightDataArray", "ltd", 
                                        aLightDirection, aLightIntensity, aLightAmbient, 
                                        aLightDiffuse, aLightSpecular, aLightShadowFraction,
                                        aPreShadowIntensity,
                                        aLightBlindData);
    lAttr.setDefault(0.0f, 0.0f, 0.0f, 0.0f, 0.0f, 0.0f, true, true, false, 0.0f, 1.0f, 0);
#else
    aLightData = lAttr.create( "lightDataArray", "ltd", 
                                        aLightDirection, aLightIntensity, aLightAmbient, 
                                        aLightDiffuse, aLightSpecular, aLightShadowFraction,
                                        aPreShadowIntensity);
    lAttr.setDefault(0.0f, 0.0f, 0.0f, 0.0f, 0.0f, 0.0f, true, true, false, 0.0f, 1.0f);
#endif

    lAttr.setArray(true);
    lAttr.setStorable(false);
    lAttr.setHidden(true);

    // objectId
    aObjectId = nAttr.create( "objectId", "oi", MFnNumericData::kLong, 0.0 );
    nAttr.setStorable(false);
    nAttr.setHidden(true);
    nAttr.setReadable(false);

    //Add all texture attributes
@foreach texture_list
    addAttribute(a${texture_name});
@end

    //Add all color attributes
@foreach color_list
    addAttribute(a${color_name});
@end

    //Add all bool attributes
@foreach bool_list
    addAttribute(a${bool_name});
@end

    //Add all float attributes
@foreach float_list
    addAttribute(a${float_name});
@end

    //Add all int attributes
@foreach int_list
    addAttribute(a${int_name});
@end

    //Add all enum attributes
@foreach enum_list
    addAttribute(a${enum_name});
@end

    addAttribute(aAmbient);
    addAttribute(aDiffuse);
    addAttribute(aEmissive);
    addAttribute(aSpecular);

    addAttribute(aShininess);
    addAttribute(aUVMode);
    addAttribute(aFilterMode);
    addAttribute(aShadeMode);
    addAttribute(aBlendMode);
    addAttribute(aAlphaTest);
    addAttribute(aAlphaCompare);
    addAttribute(aProceduralXRes);
    addAttribute(aProceduralYRes);

    addAttribute(aPDDIShaderName);
    addAttribute(aExport);
    addAttribute(aIsTranslucent);
    addAttribute(aVertexNeeds);
    addAttribute(aVertexMask);
    addAttribute(aTextureAttributes);
    addAttribute(aTexturePlugs);
    addAttribute(aTextureAlphaPlugs);

    addAttribute(aPointCamera);
    addAttribute(aNormalCamera);
    addAttribute(aTriangleNormalCamera);
    addAttribute(aLightData);
    addAttribute(aOutColor);
    addAttribute(aOutTrans);
    addAttribute(aObjectId);

    //Specify all attributes affected by texture
@foreach texture_list
    @if ( defined $texture_affectnum )
    @perl my $affectnum = $texture_affectnum;
    @perl --$affectnum;
    @perl while( $affectnum >= 0 ){
    attributeAffects ( a$texture_name, ${"texture_affect".${affectnum}} );
    attributeAffects ( a${texture_name}R, ${"texture_affect".${affectnum}}R );
    attributeAffects ( a${texture_name}G, ${"texture_affect".${affectnum}}G );
    attributeAffects ( a${texture_name}B, ${"texture_affect".${affectnum}}B );
    @perl --$affectnum;
    @perl }
    @endif
@end

    //Specify all attributes affected by color
@foreach color_list
    @if ( defined $color_affectnum )
    @perl my $affectnum = $color_affectnum;
    @perl --$affectnum;
    @perl while( $affectnum >= 0 ){
    attributeAffects ( a$color_name, ${"color_affect".$affectnum} );
    @perl --$affectnum;
    @perl }
    @endif
@end

    //Specify all attributes affected by float
@foreach float_list
    @if ( defined $float_affectnum )
    @perl my $affectnum = $float_affectnum;
    @perl --$affectnum;
    @perl while( $affectnum >= 0 ){  
    attributeAffects ( a$float_name, ${"float_affect".$affectnum} );
    @perl --$affectnum;
    @perl }
    @endif
@end

    //Specify all attributes affected by int
@foreach int_list
    @if ( defined $int_affectnum )
    @perl my $affectnum = $int_affectnum;
    @perl --$affectnum;
    @perl while( $affectnum >= 0 ){
    attributeAffects ( a$int_name, ${"int_affect".$affectnum} );
    @perl --$affectnum;
    @perl }
    @endif
@end

    //Specify all attributes affected by bool
@foreach bool_list
    @if ( defined $bool_affectnum )
    @perl my $affectnum = $bool_affectnum;
    @perl --$affectnum;
    @perl while( $affectnum >= 0 ){
    attributeAffects ( a$bool_name, ${"bool_affect".$affectnum} );
    @perl --$affectnum;
    @perl }
    @endif
@end

    //Specify all attributes affected by enum
@foreach enum_list
    @if ( defined $enum_affectnum )
    @perl my $affectnum = $enum_affectnum;
    @perl --$affectnum;
    @perl while( $affectnum >= 0 ){
    attributeAffects ( a$enum_name, ${"enum_affect".$affectnum} );
    @perl --$affectnum;
    @perl }
    @endif
@end

    attributeAffects (aBlendMode, aIsTranslucent);
    attributeAffects (aLightIntensity, aOutColor);
    attributeAffects (aLightIntensityR, aOutColor);
    attributeAffects (aLightIntensityG, aOutColor);
    attributeAffects (aLightIntensityB, aOutColor);
    attributeAffects (aPointCamera, aOutColor);
    attributeAffects (aPointCameraX, aOutColor);
    attributeAffects (aPointCameraY, aOutColor);
    attributeAffects (aPointCameraZ, aOutColor);
    attributeAffects (aNormalCamera, aOutColor);
    attributeAffects (aNormalCameraX, aOutColor);
    attributeAffects (aNormalCameraY, aOutColor);
    attributeAffects (aNormalCameraZ, aOutColor);
    attributeAffects (aTriangleNormalCamera, aOutColor);
    attributeAffects (aTriangleNormalCameraX, aOutColor);
    attributeAffects (aTriangleNormalCameraY, aOutColor);
    attributeAffects (aTriangleNormalCameraZ, aOutColor);
    attributeAffects (aLightData, aOutColor);
    attributeAffects (aLightDirectionX, aOutColor);
    attributeAffects (aLightDirectionY, aOutColor);
    attributeAffects (aLightDirectionZ, aOutColor);
    attributeAffects (aLightAmbient, aOutColor);
    attributeAffects (aLightSpecular, aOutColor);
    attributeAffects (aLightDiffuse, aOutColor);
    attributeAffects (aLightDirection, aOutColor);
    attributeAffects (aLightShadowFraction, aOutColor);
    attributeAffects (aPreShadowIntensity, aOutColor);
    attributeAffects (aLightBlindData, aOutColor);

    attributeAffects (aAmbient, aOutColor);
    attributeAffects (aDiffuse, aOutColor);
    attributeAffects (aEmissive, aOutColor);
    attributeAffects (aSpecular, aOutColor);

    attributeAffects (aShininess, aOutColor);
    attributeAffects (aShadeMode, aOutColor);

    attributeAffects(aObjectId,aOutColor);

    exporterAttributes();
    
    return MS::kSuccess;
}

//

#define INTATTR(code, source)  aExport##code = nAttr.create( #code , "export"#code , MFnNumericData::kLong); \\
                                         nAttr.setStorable(false);                                                     \\
                                         cAttr.addChild(aExport##code);                                                \\
                                         addAttribute(aExport##code);                                                  \\
                                         attributeAffects(source, aExport);                                            \\
                                         attributeAffects(aExport##code, aExport);

#define COLORATTR(code, source) \\
    aExport##code##R = nAttr.create( #code"R" , "export"#code"R" , MFnNumericData::kFloat); \\
    aExport##code##G = nAttr.create( #code"G" , "export"#code"G" , MFnNumericData::kFloat); \\
    aExport##code##B = nAttr.create( #code"B" , "export"#code"B" , MFnNumericData::kFloat); \\
    aExport##code  = nAttr.create( #code     , "export"#code, aExport##code##R, aExport##code##G, aExport##code##B); \\
    nAttr.setUsedAsColor(true);                                                     \\
    nAttr.setStorable(false);                                                       \\
    cAttr.addChild(aExport##code);                                                  \\
    addAttribute(aExport##code);                                                    \\
    attributeAffects(source, aExport);                                              \\
    attributeAffects(aExport##code, aExport);             

#define FLOATATTR(code, source) aExport##code = nAttr.create( #code , "export"#code , MFnNumericData::kFloat); \\
                                          nAttr.setStorable(false);                                                       \\
                                          cAttr.addChild(aExport##code);                                                 \\
                                          addAttribute(aExport##code);                                                   \\
                                          attributeAffects(source, aExport);                                             \\
                                          attributeAffects(aExport##code, aExport);

void
${shadername}::exporterAttributes()
{
    MFnNumericAttribute nAttr; 
    MFnCompoundAttribute cAttr;

    // The exporter data
    aExport = cAttr.create("shaderExport", "sxp");
    //cAttr.setHidden(true);
    //cAttr.setReadable(true);
    //cAttr.setWritable(false);
    addAttribute(aExport);

    INTATTR(UVMD, aUVMode);
    INTATTR(FIMD, aFilterMode);
    INTATTR(SHMD, aShadeMode);

    COLORATTR(AMBI, aAmbient);
    COLORATTR(DIFF, aDiffuse);
    COLORATTR(EMIS, aEmissive);
    COLORATTR(SPEC, aSpecular);

    FLOATATTR(SHIN, aShininess);

    INTATTR(BLMD, aBlendMode);
    INTATTR(ATST, aAlphaTest);
    INTATTR(ACMP, aAlphaCompare);
}

//
// Compute all attributes for exporting:
///////////////////////////////////////////////////////
MStatus ${shadername}::compute(
const MPlug&      plug,
        MDataBlock& block ) 
{ 

    if( compute_output( plug, block ) == MS::kSuccess )
    {
        return MS::kSuccess;
    }
    else if(plug == aIsTranslucent)
    {
        MDataHandle outHandle = block.outputValue( aIsTranslucent );
        short& value = outHandle.asShort();
        value = block.inputValue( aBlendMode ).asShort() != 0;
        outHandle.setClean();
    }
    else if(plug == aVertexNeeds)
    {
        MDataHandle outHandle = block.outputValue( aVertexNeeds );
        long& value = outHandle.asLong();
        bool islit = block.inputValue( aIsLit ).asShort() != 0;
        if(islit)
        {
            value = (1<<4);  // PDDI_V_NORMAL
        }
        else
        {
            value = (1<<5);  // PDDI_V_COLOUR
        }
        outHandle.setClean();
    }
    else if(plug == aVertexMask)
    {
        MDataHandle outHandle = block.outputValue( aVertexMask );
        long& value = outHandle.asLong();
        bool islit = block.inputValue( aIsLit ).asShort() != 0;
        if(islit)
        {
            value = ~(1<<5);  // PDDI_V_COLOUR
        }
        else
        {
            value = ~(1<<4);  // PDDI_V_NORMAL
        }
        outHandle.setClean();
    }
    else if(plug == aExportUVMD)
    {
        MDataHandle outUVMDHandle = block.outputValue( aExportUVMD );
        short& value = outUVMDHandle.asShort();
        value = block.inputValue( aUVMode ).asShort();
        outUVMDHandle.setClean();
    }
    else if(plug == aExportFIMD)
    {
        MDataHandle outFIMDHandle = block.outputValue( aExportFIMD );
        short& value = outFIMDHandle.asShort();
        value = block.inputValue( aFilterMode ).asShort();
        outFIMDHandle.setClean();
    }
    else if(plug == aExportSHMD)
    {
        MDataHandle outSHMDHandle = block.outputValue( aExportSHMD );
        short& value = outSHMDHandle.asShort();
        value = block.inputValue( aShadeMode ).asShort();
        outSHMDHandle.setClean();
    }
    else if(plug == aExportBLMD)
    {
        MDataHandle outBLMDHandle = block.outputValue( aExportBLMD );
        short& value = outBLMDHandle.asShort();
        value = block.inputValue( aBlendMode ).asShort();
        outBLMDHandle.setClean();
    }
    else if(plug == aExportATST)
    {
        MDataHandle outATSTHandle = block.outputValue( aExportATST );
        short& value = outATSTHandle.asShort();
        value = block.inputValue( aAlphaTest ).asBool();
        outATSTHandle.setClean();
    }
    else if(plug == aExportACMP)
    {
        MDataHandle outACMPHandle = block.outputValue( aExportACMP );
        short& value = outACMPHandle.asShort();
        value = block.inputValue( aAlphaCompare ).asShort();
        outACMPHandle.setClean();
    }
    else if (plug == aExportSHIN)
    {
        MDataHandle outSHINHandle = block.outputValue( aExportSHIN );
        float& value = outSHINHandle.asFloat();
        value = block.inputValue (aShininess ).asFloat();
        outSHINHandle.setClean();
    }
    else if((plug == aExportAMBI) || (plug == aExportAMBIR) || (plug == aExportAMBIG) || (plug == aExportAMBIB))
    {
        MDataHandle outAMBIHandle = block.outputValue( aExportAMBI );
        MFloatVector& value = outAMBIHandle.asFloatVector();
        value = block.inputValue( aAmbient ).asFloatVector();
        outAMBIHandle.setClean();
    }
    else if((plug == aExportDIFF) || (plug == aExportDIFFR) || (plug == aExportDIFFG) || (plug == aExportDIFFB))
    {
        MDataHandle outDIFFHandle = block.outputValue( aExportDIFF );
        MFloatVector& value = outDIFFHandle.asFloatVector();
        value = block.inputValue( aDiffuse ).asFloatVector();
        outDIFFHandle.setClean();
    }
    else if((plug == aExportEMIS) || (plug == aExportEMISR) || (plug == aExportEMISG) || (plug == aExportEMISB))
    {
        MDataHandle outEMISHandle = block.outputValue( aExportEMIS );
        MFloatVector& value = outEMISHandle.asFloatVector();
        value = block.inputValue( aEmissive ).asFloatVector();
        outEMISHandle.setClean();
    }
    else if((plug == aExportSPEC) || (plug == aExportSPECR) || (plug == aExportSPECG) || (plug == aExportSPECB))
    {
        MDataHandle outSPECHandle = block.outputValue( aExportSPEC );
        MFloatVector& value = outSPECHandle.asFloatVector();
        value = block.inputValue( aSpecular ).asFloatVector();
        outSPECHandle.setClean();
    }
    //compute all bool attribute
@foreach bool_list
    else if(plug == aExport$bool_fourCC)
    {
     MDataHandle out${bool_fourCC}Handle = block.outputValue( aExport$bool_fourCC );
        short& value = out${bool_fourCC}Handle.asShort();
        value = block.inputValue( a$bool_name ).asBool();
        out${bool_fourCC}Handle.setClean();
    }
@end
    //compute all float attribue
@foreach float_list
    else if (plug == aExport$float_fourCC)
    {
        MDataHandle out${float_fourCC}Handle = block.outputValue( aExport$float_fourCC );
        float& value = out${float_fourCC}Handle.asFloat();
        value = block.inputValue ( a$float_name ).asFloat();
        out${float_fourCC}Handle.setClean();
    }
@end
    //compute all int attribue
@foreach int_list
    else if (plug == aExport$int_fourCC)
    {
        MDataHandle out${int_fourCC}Handle = block.outputValue( aExport$int_fourCC );
        int& value = out${int_fourCC}Handle.asShort();
        value = block.inputValue ( a$int_name ).asShort();
        out${int_fourCC}Handle.setClean();
    }
@end      
    else 
    {
        return MS::kUnknownParameter;
    }
    return MS::kSuccess;
}

static MCallbackId callbackid;
void ${shadername}CB(MObject &node, void*)
{
    MStatus stat;
    MString      command;
    MStringArray arrayResult;
    MFnDependencyNode depnode(node);

    command = MString("string \$p3dsimpletmp = \\"FixHWTextureInfo ") + depnode.name() + "\\";\\n"
              + MString("evalDeferred \\"FixHWTextureInfo ") + depnode.name() + "\\";\\n"
              + MString("evalDeferred \\"scriptJob -con ") 
              + depnode.name() + MString(".color \$p3dsimpletmp;\\"");
    stat = MGlobal::executeCommand(command, arrayResult);
    if (stat != MS::kSuccess) 
    {
        MGlobal::displayError("Failed in $registername Callback!");
        return ;
    }
}

//
// Intialize plugin:
///////////////////////////////////////////////////////
MStatus initializePlugin( MObject obj )
{ 
    const MString UserClassify( "shader/surface" );
    MString command( "if( `window -exists createRenderNodeWindow` )  {refreshCreateRenderNodeWindow(\\"" );

    MFnPlugin plugin( obj, "Radical - Pure3D", "0.01", "Any");
    //named $registername because maya will reformat $shadername into P 3d Simple Shader
    plugin.registerNode( "$registername", ${shadername}::id, 
                                 ${shadername}::creator, ${shadername}::initialize,
                                 MPxNode::kDependNode, &UserClassify );
    command += UserClassify;
    command += "\\");}\\n";

    MGlobal::executeCommand(command);
    callbackid = MDGMessage::addNodeAddedCallback(${shadername}CB, "$registername", NULL, NULL);
    return MS::kSuccess;
}

//
// Unintialize plugin:
/////////////////////////////////////////////////////////////////////////////
MStatus uninitializePlugin( MObject obj )
{
    MMessage::removeCallback( callbackid );

    const MString UserClassify( "shader/surface" );
    MString command( "if( `window -exists createRenderNodeWindow` )  {refreshCreateRenderNodeWindow(\\"" );

    MFnPlugin plugin( obj );
    plugin.deregisterNode( ${shadername}::id );

    command += UserClassify;
    command += "\\");}\\n";

    MGlobal::executeCommand(command);

    return MS::kSuccess;
}

