

<HTML><HEAD><TITLE>Manpage of FLEX</TITLE>
</HEAD><BODY>
<H1>FLEX</H1>
Section: User Commands  (1)<BR>Updated: 26 May 1990<BR><A HREF="#index">Index</A>
<A HREF="http://localhost/cgi-bin/man/man2html">Return to Main Contents</A><HR>

<A NAME="lbAB">&nbsp;</A>
<H2>NAME</H2>

flex - fast lexical analyzer generator
<A NAME="lbAC">&nbsp;</A>
<H2>SYNOPSIS</H2>

<B>flex</B>

<B>[-bcdfinpstvFILT8 -C[efmF] -Sskeleton]</B>

<I>[filename ...]</I>

<A NAME="lbAD">&nbsp;</A>
<H2>DESCRIPTION</H2>

<I>flex</I>

is a tool for generating
<I>scanners:</I>

programs which recognized lexical patterns in text.
<I>flex</I>

reads
the given input files, or its standard input if no file names are given,
for a description of a scanner to generate.  The description is in
the form of pairs
of regular expressions and C code, called
<I>rules.  flex</I>

generates as output a C source file,
<B>lex.yy.c,</B>

which defines a routine
<B>yylex().</B>

This file is compiled and linked with the
<B>-lfl</B>

library to produce an executable.  When the executable is run,
it analyzes its input for occurrences
of the regular expressions.  Whenever it finds one, it executes
the corresponding C code.
<A NAME="lbAE">&nbsp;</A>
<H2>SOME SIMPLE EXAMPLES</H2>

<P>

First some simple examples to get the flavor of how one uses
<I>flex.</I>

The following
<I>flex</I>

input specifies a scanner which whenever it encounters the string
&quot;username&quot; will replace it with the user's login name:
<PRE>

    %%
    username    printf( &quot;%s&quot;, getlogin() );

</PRE>

By default, any text not matched by a
<I>flex</I>

scanner
is copied to the output, so the net effect of this scanner is
to copy its input file to its output with each occurrence
of &quot;username&quot; expanded.
In this input, there is just one rule.  &quot;username&quot; is the
<I>pattern</I>

and the &quot;printf&quot; is the
<I>action.</I>

The &quot;%%&quot; marks the beginning of the rules.
<P>

Here's another simple example:
<PRE>

        int num_lines = 0, num_chars = 0;

    %%
    \n    ++num_lines; ++num_chars;
    .     ++num_chars;

    %%
    main()
        {
        yylex();
        printf( &quot;# of lines = %d, # of chars = %d\n&quot;,
                num_lines, num_chars );
        }

</PRE>

This scanner counts the number of characters and the number
of lines in its input (it produces no output other than the
final report on the counts).  The first line
declares two globals, &quot;num_lines&quot; and &quot;num_chars&quot;, which are accessible
both inside
<B>yylex()</B>

and in the
<B>main()</B>

routine declared after the second &quot;%%&quot;.  There are two rules, one
which matches a newline (&quot;\n&quot;) and increments both the line count and
the character count, and one which matches any character other than
a newline (indicated by the &quot;.&quot; regular expression).
<P>

A somewhat more complicated example:
<PRE>

    /* scanner for a toy Pascal-like language */

    %{
    /* need this for the call to atof() below */
    #include &lt;<A HREF="file:/usr/include/math.h">math.h</A>&gt;
    %}

    DIGIT    [0-9]
    ID       [a-z][a-z0-9]*

    %%

    {DIGIT}+    {
                printf( &quot;An integer: %s (%d)\n&quot;, yytext,
                        atoi( yytext ) );
                }

    {DIGIT}+&quot;.&quot;{DIGIT}*        {
                printf( &quot;A float: %s (%g)\n&quot;, yytext,
                        atof( yytext ) );
                }

    if|then|begin|end|procedure|function        {
                printf( &quot;A keyword: %s\n&quot;, yytext );
                }

    {ID}        printf( &quot;An identifier: %s\n&quot;, yytext );

    &quot;+&quot;|&quot;-&quot;|&quot;*&quot;|&quot;/&quot;   printf( &quot;An operator: %s\n&quot;, yytext );

    &quot;{&quot;[^}\n]*&quot;}&quot;     /* eat up one-line comments */

    [ \t\n]+          /* eat up whitespace */

    .           printf( &quot;Unrecognized character: %s\n&quot;, yytext );

    %%

    main( argc, argv )
    int argc;
    char **argv;
        {
        ++argv, --argc;  /* skip over program name */
        if ( argc &gt; 0 )
                yyin = fopen( argv[0], &quot;r&quot; );
        else
                yyin = stdin;
        
        yylex();
        }

</PRE>

This is the beginnings of a simple scanner for a language like
Pascal.  It identifies different types of
<I>tokens</I>

and reports on what it has seen.
<P>

The details of this example will be explained in the following
sections.
<A NAME="lbAF">&nbsp;</A>
<H2>FORMAT OF THE INPUT FILE</H2>

The
<I>flex</I>

input file consists of three sections, separated by a line with just
<B>%%</B>

in it:
<PRE>

    definitions
    %%
    rules
    %%
    user code

</PRE>

The
<I>definitions</I>

section contains declarations of simple
<I>name</I>

definitions to simplify the scanner specification, and declarations of
<I>start conditions,</I>

which are explained in a later section.
<P>

Name definitions have the form:
<PRE>

    name definition

</PRE>

The &quot;name&quot; is a word beginning with a letter or an underscore ('_')
followed by zero or more letters, digits, '_', or '-' (dash).
The definition is taken to begin at the first non-white-space character
following the name and continuing to the end of the line.
The definition can subsequently be referred to using &quot;{name}&quot;, which
will expand to &quot;(definition)&quot;.  For example,
<PRE>

    DIGIT    [0-9]
    ID       [a-z][a-z0-9]*

</PRE>

defines &quot;DIGIT&quot; to be a regular expression which matches a
single digit, and
&quot;ID&quot; to be a regular expression which matches a letter
followed by zero-or-more letters-or-digits.
A subsequent reference to
<PRE>

    {DIGIT}+&quot;.&quot;{DIGIT}*

</PRE>

is identical to
<PRE>

    ([0-9])+&quot;.&quot;([0-9])*

</PRE>

and matches one-or-more digits followed by a '.' followed
by zero-or-more digits.
<P>

The
<I>rules</I>

section of the
<I>flex</I>

input contains a series of rules of the form:
<PRE>

    pattern   action

</PRE>

where the pattern must be unindented and the action must begin
on the same line.
<P>

See below for a further description of patterns and actions.
<P>

Finally, the user code section is simply copied to
<B>lex.yy.c</B>

verbatim.
It is used for companion routines which call or are called
by the scanner.  The presence of this section is optional;
if it is missing, the second
<B>%%</B>

in the input file may be skipped, too.
<P>

In the definitions and rules sections, any
<I>indented</I>

text or text enclosed in
<B>%{</B>

and
<B>%}</B>

is copied verbatim to the output (with the %{}'s removed).
The %{}'s must appear unindented on lines by themselves.
<P>

In the rules section,
any indented or %{} text appearing before the
first rule may be used to declare variables
which are local to the scanning routine and (after the declarations)
code which is to be executed whenever the scanning routine is entered.
Other indented or %{} text in the rule section is still copied to the output,
but its meaning is not well-defined and it may well cause compile-time
errors (this feature is present for
<I>POSIX</I>

compliance; see below for other such features).
<P>

In the definitions section, an unindented comment (i.e., a line
beginning with &quot;/*&quot;) is also copied verbatim to the output up
to the next &quot;*/&quot;.  Also, any line in the definitions section
beginning with '#' is ignored, though this style of comment is
deprecated and may go away in the future.
<A NAME="lbAG">&nbsp;</A>
<H2>PATTERNS</H2>

The patterns in the input are written using an extended set of regular
expressions.  These are:
<PRE>

    x          match the character 'x'
    .          any character except newline
    [xyz]      a &quot;character class&quot;; in this case, the pattern
                 matches either an 'x', a 'y', or a 'z'
    [abj-oZ]   a &quot;character class&quot; with a range in it; matches
                 an 'a', a 'b', any letter from 'j' through 'o',
                 or a 'Z'
    [^A-Z]     a &quot;negated character class&quot;, i.e., any character
                 but those in the class.  In this case, any
                 character EXCEPT an uppercase letter.
    [^A-Z\n]   any character EXCEPT an uppercase letter or
                 a newline
    r*         zero or more r's, where r is any regular expression
    r+         one or more r's
    r?         zero or one r's (that is, &quot;an optional r&quot;)
    r{2,5}     anywhere from two to five r's
    r{2,}      two or more r's
    r{4}       exactly 4 r's
    {name}     the expansion of the &quot;name&quot; definition
               (see above)
    &quot;[xyz]\&quot;foo&quot;
               the literal string: [xyz]&quot;foo
    \X         if X is an 'a', 'b', 'f', 'n', 'r', 't', or 'v',
                 then the ANSI-C interpretation of \x.
                 Otherwise, a literal 'X' (used to escape
                 operators such as '*')
    \123       the character with octal value 123
    \x2a       the character with hexadecimal value 2a
    (r)        match an r; parentheses are used to override
                 precedence (see below)


    rs         the regular expression r followed by the
                 regular expression s; called &quot;concatenation&quot;


    r|s        either an r or an s


    r/s        an r but only if it is followed by an s.  The
                 s is not part of the matched text.  This type
                 of pattern is called as &quot;trailing context&quot;.
    ^r         an r, but only at the beginning of a line
    r$         an r, but only at the end of a line.  Equivalent
                 to &quot;r/\n&quot;.


    &lt;s&gt;r       an r, but only in start condition s (see
               below for discussion of start conditions)
    &lt;s1,s2,s3&gt;r
               same, but in any of start conditions s1,
               s2, or s3


    &lt;&lt;EOF&gt;&gt;    an end-of-file
    &lt;s1,s2&gt;&lt;&lt;EOF&gt;&gt;
               an end-of-file when in start condition s1 or s2

</PRE>

The regular expressions listed above are grouped according to
precedence, from highest precedence at the top to lowest at the bottom.
Those grouped together have equal precedence.  For example,
<PRE>

    foo|bar*

</PRE>

is the same as
<PRE>

    (foo)|(ba(r*))

</PRE>

since the '*' operator has higher precedence than concatenation,
and concatenation higher than alternation ('|').  This pattern
therefore matches
<I>either</I>

the string &quot;foo&quot;
<I>or</I>

the string &quot;ba&quot; followed by zero-or-more r's.
To match &quot;foo&quot; or zero-or-more &quot;bar&quot;'s, use:
<PRE>

    foo|(bar)*

</PRE>

and to match zero-or-more &quot;foo&quot;'s-or-&quot;bar&quot;'s:
<PRE>

    (foo|bar)*

</PRE>

<P>

Some notes on patterns:
<DL COMPACT>
<DT>-<DD>
A negated character class such as the example &quot;[^A-Z]&quot;
above
<I>will match a newline</I>

unless &quot;\n&quot; (or an equivalent escape sequence) is one of the
characters explicitly present in the negated character class
(e.g., &quot;[^A-Z\n]&quot;).  This is unlike how many other regular
expression tools treat negated character classes, but unfortunately
the inconsistency is historically entrenched.
Matching newlines means that a pattern like [^&quot;]* can match an entire
input (overflowing the scanner's input buffer) unless there's another
quote in the input.
<DT>-<DD>
A rule can have at most one instance of trailing context (the '/' operator
or the '$' operator).  The start condition, '^', and &quot;&lt;&lt;EOF&gt;&gt;&quot; patterns
can only occur at the beginning of a pattern, and, as well as with '/' and '$',
cannot be grouped inside parentheses.  A '^' which does not occur at
the beginning of a rule or a '$' which does not occur at the end of
a rule loses its special properties and is treated as a normal character.
<DT><DD>
The following are illegal:
<PRE>

    foo/bar$
    &lt;sc1&gt;foo&lt;sc2&gt;bar

</PRE>

Note that the first of these, can be written &quot;foo/bar\n&quot;.
<DT><DD>
The following will result in '$' or '^' being treated as a normal character:
<PRE>

    foo|(bar$)
    foo|^bar

</PRE>

If what's wanted is a &quot;foo&quot; or a bar-followed-by-a-newline, the following
could be used (the special '|' action is explained below):
<PRE>

    foo      |
    bar$     /* action goes here */

</PRE>

A similar trick will work for matching a foo or a
bar-at-the-beginning-of-a-line.
</DL>
<A NAME="lbAH">&nbsp;</A>
<H2>HOW THE INPUT IS MATCHED</H2>

When the generated scanner is run, it analyzes its input looking
for strings which match any of its patterns.  If it finds more than
one match, it takes the one matching the most text (for trailing
context rules, this includes the length of the trailing part, even
though it will then be returned to the input).  If it finds two
or more matches of the same length, the
rule listed first in the
<I>flex</I>

input file is chosen.
<P>

Once the match is determined, the text corresponding to the match
(called the
<I>token)</I>

is made available in the global character pointer
<B>yytext,</B>

and its length in the global integer
<B>yyleng.</B>

The
<I>action</I>

corresponding to the matched pattern is then executed (a more
detailed description of actions follows), and then the remaining
input is scanned for another match.
<P>

If no match is found, then the
<I>default rule</I>

is executed: the next character in the input is considered matched and
copied to the standard output.  Thus, the simplest legal
<I>flex</I>

input is:
<PRE>

    %%

</PRE>

which generates a scanner that simply copies its input (one character
at a time) to its output.
<A NAME="lbAI">&nbsp;</A>
<H2>ACTIONS</H2>

Each pattern in a rule has a corresponding action, which can be any
arbitrary C statement.  The pattern ends at the first non-escaped
whitespace character; the remainder of the line is its action.  If the
action is empty, then when the pattern is matched the input token
is simply discarded.  For example, here is the specification for a program
which deletes all occurrences of &quot;zap me&quot; from its input:
<PRE>

    %%
    &quot;zap me&quot;

</PRE>

(It will copy all other characters in the input to the output since
they will be matched by the default rule.)
<P>

Here is a program which compresses multiple blanks and tabs down to
a single blank, and throws away whitespace found at the end of a line:
<PRE>

    %%
    [ \t]+        putchar( ' ' );
    [ \t]+$       /* ignore this token */

</PRE>

<P>

If the action contains a '{', then the action spans till the balancing '}'
is found, and the action may cross multiple lines.
<I>flex </I>

knows about C strings and comments and won't be fooled by braces found
within them, but also allows actions to begin with
<B>%{</B>

and will consider the action to be all the text up to the next
<B>%}</B>

(regardless of ordinary braces inside the action).
<P>

An action consisting solely of a vertical bar ('|') means &quot;same as
the action for the next rule.&quot;  See below for an illustration.
<P>

Actions can include arbitrary C code, including
<B>return</B>

statements to return a value to whatever routine called
<B>yylex().</B>

Each time
<B>yylex()</B>

is called it continues processing tokens from where it last left
off until it either reaches
the end of the file or executes a return.  Once it reaches an end-of-file,
however, then any subsequent call to
<B>yylex()</B>

will simply immediately return, unless
<B>yyrestart()</B>

is first called (see below).
<P>

Actions are not allowed to modify yytext or yyleng.
<P>

There are a number of special directives which can be included within
an action:
<DL COMPACT>
<DT>-<DD>
<B>ECHO</B>

copies yytext to the scanner's output.
<DT>-<DD>
<B>BEGIN</B>

followed by the name of a start condition places the scanner in the
corresponding start condition (see below).
<DT>-<DD>
<B>REJECT</B>

directs the scanner to proceed on to the &quot;second best&quot; rule which matched the
input (or a prefix of the input).  The rule is chosen as described
above in &quot;How the Input is Matched&quot;, and
<B>yytext</B>

and
<B>yyleng</B>

set up appropriately.
It may either be one which matched as much text
as the originally chosen rule but came later in the
<I>flex</I>

input file, or one which matched less text.
For example, the following will both count the
words in the input and call the routine special() whenever &quot;frob&quot; is seen:
<PRE>

            int word_count = 0;
    %%

    frob        special(); REJECT;
    [^ \t\n]+   ++word_count;

</PRE>

Without the
<B>REJECT,</B>

any &quot;frob&quot;'s in the input would not be counted as words, since the
scanner normally executes only one action per token.
Multiple
<B>REJECT's</B>

are allowed, each one finding the next best choice to the currently
active rule.  For example, when the following scanner scans the token
&quot;abcd&quot;, it will write &quot;abcdabcaba&quot; to the output:
<PRE>

    %%
    a        |
    ab       |
    abc      |
    abcd     ECHO; REJECT;
    .|\n     /* eat up any unmatched character */

</PRE>

(The first three rules share the fourth's action since they use
the special '|' action.)
<B>REJECT</B>

is a particularly expensive feature in terms scanner performance;
if it is used in
<I>any</I>

of the scanner's actions it will slow down
<I>all</I>

of the scanner's matching.  Furthermore,
<B>REJECT</B>

cannot be used with the
<I>-f</I>

or
<I>-F</I>

options (see below).
<DT><DD>
Note also that unlike the other special actions,
<B>REJECT</B>

is a
<I>branch;</I>

code immediately following it in the action will
<I>not</I>

be executed.
<DT>-<DD>
<B>yymore()</B>

tells the scanner that the next time it matches a rule, the corresponding
token should be
<I>appended</I>

onto the current value of
<B>yytext</B>

rather than replacing it.  For example, given the input &quot;mega-kludge&quot;
the following will write &quot;mega-mega-kludge&quot; to the output:
<PRE>

    %%
    mega-    ECHO; yymore();
    kludge   ECHO;

</PRE>

First &quot;mega-&quot; is matched and echoed to the output.  Then &quot;kludge&quot;
is matched, but the previous &quot;mega-&quot; is still hanging around at the
beginning of
<B>yytext</B>

so the
<B>ECHO</B>

for the &quot;kludge&quot; rule will actually write &quot;mega-kludge&quot;.
The presence of
<B>yymore()</B>

in the scanner's action entails a minor performance penalty in the
scanner's matching speed.
<DT>-<DD>
<B><A HREF="http://localhost/cgi-bin/man/man2html?n+yyless">yyless</A>(n)</B>

returns all but the first
<I>n</I>

characters of the current token back to the input stream, where they
will be rescanned when the scanner looks for the next match.
<B>yytext</B>

and
<B>yyleng</B>

are adjusted appropriately (e.g.,
<B>yyleng</B>

will now be equal to
<I>n</I>

).  For example, on the input &quot;foobar&quot; the following will write out
&quot;foobarbar&quot;:
<PRE>

    %%
    foobar    ECHO; <A HREF="http://localhost/cgi-bin/man/man2html?3+yyless">yyless</A>(3);
    [a-z]+    ECHO;

</PRE>

An argument of 0 to
<B>yyless</B>

will cause the entire current input string to be scanned again.  Unless you've
changed how the scanner will subsequently process its input (using
<B>BEGIN,</B>

for example), this will result in an endless loop.
<DT>-<DD>
<B>unput(c)</B>

puts the character
<I>c</I>

back onto the input stream.  It will be the next character scanned.
The following action will take the current token and cause it
to be rescanned enclosed in parentheses.
<PRE>

    {
    int i;
    unput( ')' );
    for ( i = yyleng - 1; i &gt;= 0; --i )
        unput( yytext[i] );
    unput( '(' );
    }

</PRE>

Note that since each
<B>unput()</B>

puts the given character back at the
<I>beginning</I>

of the input stream, pushing back strings must be done back-to-front.
<DT>-<DD>
<B>input()</B>

reads the next character from the input stream.  For example,
the following is one way to eat up C comments:
<PRE>

    %%
    &quot;/*&quot;        {
                register int c;

                for ( ; ; )
                    {
                    while ( (c = input()) != '*' &amp;&amp;
                            c != EOF )
                        ;    /* eat up text of comment */

                    if ( c == '*' )
                        {
                        while ( (c = input()) == '*' )
                            ;
                        if ( c == '/' )
                            break;    /* found the end */
                        }

                    if ( c == EOF )
                        {
                        error( &quot;EOF in comment&quot; );
                        break;
                        }
                    }
                }

</PRE>

(Note that if the scanner is compiled using
<B>C++,</B>

then
<B>input()</B>

is instead referred to as
<B>yyinput(),</B>

in order to avoid a name clash with the
<B>C++</B>

stream by the name of
<I>input.)</I>

<DT>-<DD>
<B>yyterminate()</B>

can be used in lieu of a return statement in an action.  It terminates
the scanner and returns a 0 to the scanner's caller, indicating &quot;all done&quot;.
Subsequent calls to the scanner will immediately return unless preceded
by a call to
<B>yyrestart()</B>

(see below).
By default,
<B>yyterminate()</B>

is also called when an end-of-file is encountered.  It is a macro and
may be redefined.
</DL>
<A NAME="lbAJ">&nbsp;</A>
<H2>THE GENERATED SCANNER</H2>

The output of
<I>flex</I>

is the file
<B>lex.yy.c,</B>

which contains the scanning routine
<B>yylex(),</B>

a number of tables used by it for matching tokens, and a number
of auxiliary routines and macros.  By default,
<B>yylex()</B>

is declared as follows:
<PRE>

    int yylex()
        {
        ... various definitions and the actions in here ...
        }

</PRE>

(If your environment supports function prototypes, then it will
be &quot;int yylex( void )&quot;.)  This definition may be changed by redefining
the &quot;YY_DECL&quot; macro.  For example, you could use:
<PRE>

    #undef YY_DECL
    #define YY_DECL float lexscan( a, b ) float a, b;

</PRE>

to give the scanning routine the name
<I>lexscan,</I>

returning a float, and taking two floats as arguments.  Note that
if you give arguments to the scanning routine using a
K&amp;R-style/non-prototyped function declaration, you must terminate
the definition with a semi-colon (;).
<P>

Whenever
<B>yylex()</B>

is called, it scans tokens from the global input file
<I>yyin</I>

(which defaults to stdin).  It continues until it either reaches
an end-of-file (at which point it returns the value 0) or
one of its actions executes a
<I>return</I>

statement.
In the former case, when called again the scanner will immediately
return unless
<B>yyrestart()</B>

is called to point
<I>yyin</I>

at the new input file.  (
<B>yyrestart()</B>

takes one argument, a
<B>FILE *</B>

pointer.)
In the latter case (i.e., when an action
executes a return), the scanner may then be called again and it
will resume scanning where it left off.
<P>

By default (and for purposes of efficiency), the scanner uses
block-reads rather than simple
<I>getc()</I>

calls to read characters from
<I>yyin.</I>

The nature of how it gets its input can be controlled by redefining the
<B>YY_INPUT</B>

macro.
YY_INPUT's calling sequence is &quot;YY_INPUT(buf,result,max_size)&quot;.  Its
action is to place up to
<I>max_size</I>

characters in the character array
<I>buf</I>

and return in the integer variable
<I>result</I>

either the
number of characters read or the constant YY_NULL (0 on Unix systems)
to indicate EOF.  The default YY_INPUT reads from the
global file-pointer &quot;yyin&quot;.
<P>

A sample redefinition of YY_INPUT (in the definitions
section of the input file):
<PRE>

    %{
    #undef YY_INPUT
    #define YY_INPUT(buf,result,max_size) \
        { \
        int c = getchar(); \
        result = (c == EOF) ? YY_NULL : (buf[0] = c, 1); \
        }
    %}

</PRE>

This definition will change the input processing to occur
one character at a time.
<P>

You also can add in things like keeping track of the
input line number this way; but don't expect your scanner to
go very fast.
<P>

When the scanner receives an end-of-file indication from YY_INPUT,
it then checks the
<B>yywrap()</B>

function.  If
<B>yywrap()</B>

returns false (zero), then it is assumed that the
function has gone ahead and set up
<I>yyin</I>

to point to another input file, and scanning continues.  If it returns
true (non-zero), then the scanner terminates, returning 0 to its
caller.
<P>

The default
<B>yywrap()</B>

always returns 1.  Presently, to redefine it you must first
&quot;#undef yywrap&quot;, as it is currently implemented as a macro.  As indicated
by the hedging in the previous sentence, it may be changed to
a true function in the near future.
<P>

The scanner writes its
<B>ECHO</B>

output to the
<I>yyout</I>

global (default, stdout), which may be redefined by the user simply
by assigning it to some other
<B>FILE</B>

pointer.
<A NAME="lbAK">&nbsp;</A>
<H2>START CONDITIONS</H2>

<I>flex</I>

provides a mechanism for conditionally activating rules.  Any rule
whose pattern is prefixed with &quot;&lt;sc&gt;&quot; will only be active when
the scanner is in the start condition named &quot;sc&quot;.  For example,
<PRE>

    &lt;STRING&gt;[^&quot;]*        { /* eat up the string body ... */
                ...
                }

</PRE>

will be active only when the scanner is in the &quot;STRING&quot; start
condition, and
<PRE>

    &lt;INITIAL,STRING,QUOTE&gt;\.        { /* handle an escape ... */
                ...
                }

</PRE>

will be active only when the current start condition is
either &quot;INITIAL&quot;, &quot;STRING&quot;, or &quot;QUOTE&quot;.
<P>

Start conditions
are declared in the definitions (first) section of the input
using unindented lines beginning with either
<B>%s</B>

or
<B>%x</B>

followed by a list of names.
The former declares
<I>inclusive</I>

start conditions, the latter
<I>exclusive</I>

start conditions.  A start condition is activated using the
<B>BEGIN</B>

action.  Until the next
<B>BEGIN</B>

action is executed, rules with the given start
condition will be active and
rules with other start conditions will be inactive.
If the start condition is
<I>inclusive,</I>

then rules with no start conditions at all will also be active.
If it is
<I>exclusive,</I>

then
<I>only</I>

rules qualified with the start condition will be active.
A set of rules contingent on the same exclusive start condition
describe a scanner which is independent of any of the other rules in the
<I>flex</I>

input.  Because of this,
exclusive start conditions make it easy to specify &quot;mini-scanners&quot;
which scan portions of the input that are syntactically different
from the rest (e.g., comments).
<P>

If the distinction between inclusive and exclusive start conditions
is still a little vague, here's a simple example illustrating the
connection between the two.  The set of rules:
<PRE>

    %s example
    %%
    &lt;example&gt;foo           /* do something */

</PRE>

is equivalent to
<PRE>

    %x example
    %%
    &lt;INITIAL,example&gt;foo   /* do something */

</PRE>

<P>

The default rule (to
<B>ECHO</B>

any unmatched character) remains active in start conditions.
<P>

<B>BEGIN(0)</B>

returns to the original state where only the rules with
no start conditions are active.  This state can also be
referred to as the start-condition &quot;INITIAL&quot;, so
<B>BEGIN(INITIAL)</B>

is equivalent to
<B>BEGIN(0).</B>

(The parentheses around the start condition name are not required but
are considered good style.)
<P>

<B>BEGIN</B>

actions can also be given as indented code at the beginning
of the rules section.  For example, the following will cause
the scanner to enter the &quot;SPECIAL&quot; start condition whenever
<I>yylex()</I>

is called and the global variable
<I>enter_special</I>

is true:
<PRE>

            int enter_special;

    %x SPECIAL
    %%
            if ( enter_special )
                BEGIN(SPECIAL);

    &lt;SPECIAL&gt;blahblahblah
    ...more rules follow...

</PRE>

<P>

To illustrate the uses of start conditions,
here is a scanner which provides two different interpretations
of a string like &quot;123.456&quot;.  By default it will treat it as
as three tokens, the integer &quot;123&quot;, a dot ('.'), and the integer &quot;456&quot;.
But if the string is preceded earlier in the line by the string
&quot;expect-floats&quot;
it will treat it as a single token, the floating-point number
123.456:
<PRE>

    %{
    #include &lt;<A HREF="file:/usr/include/math.h">math.h</A>&gt;
    %}
    %s expect

    %%
    expect-floats        BEGIN(expect);

    &lt;expect&gt;[0-9]+&quot;.&quot;[0-9]+      {
                printf( &quot;found a float, = %f\n&quot;,
                        atof( yytext ) );
                }
    &lt;expect&gt;\n           {
                /* that's the end of the line, so
                 * we need another &quot;expect-number&quot;
                 * before we'll recognize any more
                 * numbers
                 */
                BEGIN(INITIAL);
                }

    [0-9]+      {
                printf( &quot;found an integer, = %d\n&quot;,
                        atoi( yytext ) );
                }

    &quot;.&quot;         printf( &quot;found a dot\n&quot; );

</PRE>

Here is a scanner which recognizes (and discards) C comments while
maintaining a count of the current input line.
<PRE>

    %x comment
    %%
            int line_num = 1;

    &quot;/*&quot;         BEGIN(comment);

    &lt;comment&gt;[^*\n]*        /* eat anything that's not a '*' */
    &lt;comment&gt;&quot;*&quot;+[^*/\n]*   /* eat up '*'s not followed by '/'s */
    &lt;comment&gt;\n             ++line_num;
    &lt;comment&gt;&quot;*&quot;+&quot;/&quot;        BEGIN(INITIAL);

</PRE>

Note that start-conditions names are really integer values and
can be stored as such.  Thus, the above could be extended in the
following fashion:
<PRE>

    %x comment foo
    %%
            int line_num = 1;
            int comment_caller;

    &quot;/*&quot;         {
                 comment_caller = INITIAL;
                 BEGIN(comment);
                 }

    ...

    &lt;foo&gt;&quot;/*&quot;    {
                 comment_caller = foo;
                 BEGIN(comment);
                 }

    &lt;comment&gt;[^*\n]*        /* eat anything that's not a '*' */
    &lt;comment&gt;&quot;*&quot;+[^*/\n]*   /* eat up '*'s not followed by '/'s */
    &lt;comment&gt;\n             ++line_num;
    &lt;comment&gt;&quot;*&quot;+&quot;/&quot;        BEGIN(comment_caller);

</PRE>

One can then implement a &quot;stack&quot; of start conditions using an
array of integers.  (It is likely that such stacks will become
a full-fledged
<I>flex</I>

feature in the future.)  Note, though, that
start conditions do not have their own name-space; %s's and %x's
declare names in the same fashion as #define's.
<A NAME="lbAL">&nbsp;</A>
<H2>MULTIPLE INPUT BUFFERS</H2>

Some scanners (such as those which support &quot;include&quot; files)
require reading from several input streams.  As
<I>flex</I>

scanners do a large amount of buffering, one cannot control
where the next input will be read from by simply writing a
<B>YY_INPUT</B>

which is sensitive to the scanning context.
<B>YY_INPUT</B>

is only called when the scanner reaches the end of its buffer, which
may be a long time after scanning a statement such as an &quot;include&quot;
which requires switching the input source.
<P>

To negotiate these sorts of problems,
<I>flex</I>

provides a mechanism for creating and switching between multiple
input buffers.  An input buffer is created by using:
<PRE>

    YY_BUFFER_STATE yy_create_buffer( FILE *file, int size )

</PRE>

which takes a
<I>FILE</I>

pointer and a size and creates a buffer associated with the given
file and large enough to hold
<I>size</I>

characters (when in doubt, use
<B>YY_BUF_SIZE</B>

for the size).  It returns a
<B>YY_BUFFER_STATE</B>

handle, which may then be passed to other routines:
<PRE>

    void yy_switch_to_buffer( YY_BUFFER_STATE new_buffer )

</PRE>

switches the scanner's input buffer so subsequent tokens will
come from
<I>new_buffer.</I>

Note that
<B>yy_switch_to_buffer()</B>

may be used by yywrap() to sets things up for continued scanning, instead
of opening a new file and pointing
<I>yyin</I>

at it.
<PRE>

    void yy_delete_buffer( YY_BUFFER_STATE buffer )

</PRE>

is used to reclaim the storage associated with a buffer.
<P>

<B>yy_new_buffer()</B>

is an alias for
<B>yy_create_buffer(),</B>

provided for compatibility with the C++ use of
<I>new</I>

and
<I>delete</I>

for creating and destroying dynamic objects.
<P>

Finally, the
<B>YY_CURRENT_BUFFER</B>

macro returns a
<B>YY_BUFFER_STATE</B>

handle to the current buffer.
<P>

Here is an example of using these features for writing a scanner
which expands include files (the
<B>&lt;&lt;EOF&gt;&gt;</B>

feature is discussed below):
<PRE>

    /* the &quot;incl&quot; state is used for picking up the name
     * of an include file
     */
    %x incl

    %{
    #define MAX_INCLUDE_DEPTH 10
    YY_BUFFER_STATE include_stack[MAX_INCLUDE_DEPTH];
    int include_stack_ptr = 0;
    %}

    %%
    include             BEGIN(incl);

    [a-z]+              ECHO;
    [^a-z\n]*\n?        ECHO;

    &lt;incl&gt;[ \t]*      /* eat the whitespace */
    &lt;incl&gt;[^ \t\n]+   { /* got the include file name */
            if ( include_stack_ptr &gt;= MAX_INCLUDE_DEPTH )
                {
                fprintf( stderr, &quot;Includes nested too deeply&quot; );
                exit( 1 );
                }

            include_stack[include_stack_ptr++] =
                YY_CURRENT_BUFFER;

            yyin = fopen( yytext, &quot;r&quot; );

            if ( ! yyin )
                error( ... );

            yy_switch_to_buffer(
                yy_create_buffer( yyin, YY_BUF_SIZE ) );

            BEGIN(INITIAL);
            }

    &lt;&lt;EOF&gt;&gt; {
            if ( --include_stack_ptr &lt; 0 )
                {
                yyterminate();
                }

            else
                yy_switch_to_buffer(
                     include_stack[include_stack_ptr] );
            }

</PRE>

<A NAME="lbAM">&nbsp;</A>
<H2>END-OF-FILE RULES</H2>

The special rule &quot;&lt;&lt;EOF&gt;&gt;&quot; indicates
actions which are to be taken when an end-of-file is
encountered and yywrap() returns non-zero (i.e., indicates
no further files to process).  The action must finish
by doing one of four things:
<DL COMPACT>
<DT>-<DD>
the special
<B>YY_NEW_FILE</B>

action, if
<I>yyin</I>

has been pointed at a new file to process;
<DT>-<DD>
a
<I>return</I>

statement;
<DT>-<DD>
the special
<B>yyterminate()</B>

action;
<DT>-<DD>
or, switching to a new buffer using
<B>yy_switch_to_buffer()</B>

as shown in the example above.
</DL>
<P>

&lt;&lt;EOF&gt;&gt; rules may not be used with other
patterns; they may only be qualified with a list of start
conditions.  If an unqualified &lt;&lt;EOF&gt;&gt; rule is given, it
applies to
<I>all</I>

start conditions which do not already have &lt;&lt;EOF&gt;&gt; actions.  To
specify an &lt;&lt;EOF&gt;&gt; rule for only the initial start condition, use
<PRE>

    &lt;INITIAL&gt;&lt;&lt;EOF&gt;&gt;

</PRE>

<P>

These rules are useful for catching things like unclosed comments.
An example:
<PRE>

    %x quote
    %%

    ...other rules for dealing with quotes...

    &lt;quote&gt;&lt;&lt;EOF&gt;&gt;   {
             error( &quot;unterminated quote&quot; );
             yyterminate();
             }
    &lt;&lt;EOF&gt;&gt;  {
             if ( *++filelist )
                 {
                 yyin = fopen( *filelist, &quot;r&quot; );
                 YY_NEW_FILE;
                 }
             else
                yyterminate();
             }

</PRE>

<A NAME="lbAN">&nbsp;</A>
<H2>MISCELLANEOUS MACROS</H2>

The macro

YY_USER_ACTION
can be redefined to provide an action
which is always executed prior to the matched rule's action.  For example,
it could be #define'd to call a routine to convert yytext to lower-case.
<P>

The macro
<B>YY_USER_INIT</B>

may be redefined to provide an action which is always executed before
the first scan (and before the scanner's internal initializations are done).
For example, it could be used to call a routine to read
in a data table or open a logging file.
<P>

In the generated scanner, the actions are all gathered in one large
switch statement and separated using
<B>YY_BREAK,</B>

which may be redefined.  By default, it is simply a &quot;break&quot;, to separate
each rule's action from the following rule's.
Redefining
<B>YY_BREAK</B>

allows, for example, C++ users to
#define YY_BREAK to do nothing (while being very careful that every
rule ends with a &quot;break&quot; or a &quot;return&quot;!) to avoid suffering from
unreachable statement warnings where because a rule's action ends with
&quot;return&quot;, the
<B>YY_BREAK</B>

is inaccessible.
<A NAME="lbAO">&nbsp;</A>
<H2>INTERFACING WITH YACC</H2>

One of the main uses of
<I>flex</I>

is as a companion to the
<I>yacc</I>

parser-generator.
<I>yacc</I>

parsers expect to call a routine named
<B>yylex()</B>

to find the next input token.  The routine is supposed to
return the type of the next token as well as putting any associated
value in the global
<B>yylval.</B>

To use
<I>flex</I>

with
<I>yacc,</I>

one specifies the
<B>-d</B>

option to
<I>yacc</I>

to instruct it to generate the file
<B>y.tab.h</B>

containing definitions of all the
<B>%tokens</B>

appearing in the
<I>yacc</I>

input.  This file is then included in the
<I>flex</I>

scanner.  For example, if one of the tokens is &quot;TOK_NUMBER&quot;,
part of the scanner might look like:
<PRE>

    %{
    #include &quot;y.tab.h&quot;
    %}

    %%

    [0-9]+        yylval = atoi( yytext ); return TOK_NUMBER;

</PRE>

<A NAME="lbAP">&nbsp;</A>
<H2>TRANSLATION TABLE</H2>

In the name of POSIX compliance,
<I>flex</I>

supports a
<I>translation table</I>

for mapping input characters into groups.
The table is specified in the first section, and its format looks like:
<PRE>

    %t
    1        abcd
    2        ABCDEFGHIJKLMNOPQRSTUVWXYZ
    52       0123456789
    6        \t\ \n
    %t

</PRE>

This example specifies that the characters 'a', 'b', 'c', and 'd'
are to all be lumped into group #1, upper-case letters
in group #2, digits in group #52, tabs, blanks, and newlines into
group #6, and
<I>no other characters will appear in the patterns.</I>

The group numbers are actually disregarded by
<I>flex;</I>

<B>%t</B>

serves, though, to lump characters together.  Given the above
table, for example, the pattern &quot;a(AA)*5&quot; is equivalent to &quot;d(ZQ)*0&quot;.
They both say, &quot;match any character in group #1, followed by
zero-or-more pairs of characters
from group #2, followed by a character from group #52.&quot;  Thus
<B>%t</B>

provides a crude way for introducing equivalence classes into
the scanner specification.
<P>

Note that the
<B>-i</B>

option (see below) coupled with the equivalence classes which
<I>flex</I>

automatically generates take care of virtually all the instances
when one might consider using
<B>%t.</B>

But what the hell, it's there if you want it.
<A NAME="lbAQ">&nbsp;</A>
<H2>OPTIONS</H2>

<I>flex</I>

has the following options:
<DL COMPACT>
<DT><B>-b</B>

<DD>
Generate backtracking information to
<I>lex.backtrack.</I>

This is a list of scanner states which require backtracking
and the input characters on which they do so.  By adding rules one
can remove backtracking states.  If all backtracking states
are eliminated and
<B>-f</B>

or
<B>-F</B>

is used, the generated scanner will run faster (see the
<B>-p</B>

flag).  Only users who wish to squeeze every last cycle out of their
scanners need worry about this option.  (See the section on PERFORMANCE
CONSIDERATIONS below.)
<DT><B>-c</B>

<DD>
is a do-nothing, deprecated option included for POSIX compliance.
<DT><DD>
<B>NOTE:</B>

in previous releases of
<I>flex</I>

<B>-c</B>

specified table-compression options.  This functionality is
now given by the
<B>-C</B>

flag.  To ease the the impact of this change, when
<I>flex</I>

encounters
<B>-c,</B>

it currently issues a warning message and assumes that
<B>-C</B>

was desired instead.  In the future this &quot;promotion&quot; of
<B>-c</B>

to
<B>-C</B>

will go away in the name of full POSIX compliance (unless
the POSIX meaning is removed first).
<DT><B>-d</B>

<DD>
makes the generated scanner run in
<I>debug</I>

mode.  Whenever a pattern is recognized and the global
<B>yy_flex_debug</B>

is non-zero (which is the default),
the scanner will write to
<I>stderr</I>

a line of the form:
<PRE>

    --accepting rule at line 53 (&quot;the matched text&quot;)

</PRE>

The line number refers to the location of the rule in the file
defining the scanner (i.e., the file that was fed to flex).  Messages
are also generated when the scanner backtracks, accepts the
default rule, reaches the end of its input buffer (or encounters
a NUL; at this point, the two look the same as far as the scanner's concerned),
or reaches an end-of-file.
<DT><B>-f</B>

<DD>
specifies (take your pick)
<I>full table</I>

or
<I>fast scanner.</I>

No table compression is done.  The result is large but fast.
This option is equivalent to
<B>-Cf</B>

(see below).
<DT><B>-i</B>

<DD>
instructs
<I>flex</I>

to generate a
<I>case-insensitive</I>

scanner.  The case of letters given in the
<I>flex</I>

input patterns will
be ignored, and tokens in the input will be matched regardless of case.  The
matched text given in
<I>yytext</I>

will have the preserved case (i.e., it will not be folded).
<DT><B>-n</B>

<DD>
is another do-nothing, deprecated option included only for
POSIX compliance.
<DT><B>-p</B>

<DD>
generates a performance report to stderr.  The report
consists of comments regarding features of the
<I>flex</I>

input file which will cause a loss of performance in the resulting scanner.
Note that the use of
<I>REJECT</I>

and variable trailing context (see the BUGS section in <A HREF="http://localhost/cgi-bin/man/man2html?1+flex">flex</A>(1))
entails a substantial performance penalty; use of
<I>yymore(),</I>

the
<B>^</B>

operator,
and the
<B>-I</B>

flag entail minor performance penalties.
<DT><B>-s</B>

<DD>
causes the
<I>default rule</I>

(that unmatched scanner input is echoed to
<I>stdout)</I>

to be suppressed.  If the scanner encounters input that does not
match any of its rules, it aborts with an error.  This option is
useful for finding holes in a scanner's rule set.
<DT><B>-t</B>

<DD>
instructs
<I>flex</I>

to write the scanner it generates to standard output instead
of
<B>lex.yy.c.</B>

<DT><B>-v</B>

<DD>
specifies that
<I>flex</I>

should write to
<I>stderr</I>

a summary of statistics regarding the scanner it generates.
Most of the statistics are meaningless to the casual
<I>flex</I>

user, but the
first line identifies the version of
<I>flex,</I>

which is useful for figuring
out where you stand with respect to patches and new releases,
and the next two lines give the date when the scanner was created
and a summary of the flags which were in effect.
<DT><B>-F</B>

<DD>
specifies that the

fast
scanner table representation should be used.  This representation is
about as fast as the full table representation

(-f),
and for some sets of patterns will be considerably smaller (and for
others, larger).  In general, if the pattern set contains both &quot;keywords&quot;
and a catch-all, &quot;identifier&quot; rule, such as in the set:
<PRE>

    &quot;case&quot;    return TOK_CASE;
    &quot;switch&quot;  return TOK_SWITCH;
    ...
    &quot;default&quot; return TOK_DEFAULT;
    [a-z]+    return TOK_ID;

</PRE>

then you're better off using the full table representation.  If only
the &quot;identifier&quot; rule is present and you then use a hash table or some such
to detect the keywords, you're better off using

-F.
<DT><DD>
This option is equivalent to
<B>-CF</B>

(see below).
<DT><B>-I</B>

<DD>
instructs
<I>flex</I>

to generate an
<I>interactive</I>

scanner.  Normally, scanners generated by
<I>flex</I>

always look ahead one
character before deciding that a rule has been matched.  At the cost of
some scanning overhead,
<I>flex</I>

will generate a scanner which only looks ahead
when needed.  Such scanners are called
<I>interactive</I>

because if you want to write a scanner for an interactive system such as a
command shell, you will probably want the user's input to be terminated
with a newline, and without
<B>-I</B>

the user will have to type a character in addition to the newline in order
to have the newline recognized.  This leads to dreadful interactive
performance.
<DT><DD>
If all this seems to confusing, here's the general rule: if a human will
be typing in input to your scanner, use
<B>-I,</B>

otherwise don't; if you don't care about squeezing the utmost performance
from your scanner and you
don't want to make any assumptions about the input to your scanner,
use
<B>-I.</B>

<DT><DD>
Note,
<B>-I</B>

cannot be used in conjunction with
<I>full</I>

or
<I>fast tables,</I>

i.e., the
<B>-f, -F, -Cf,</B>

or
<B>-CF</B>

flags.
<DT><B>-L</B>

<DD>
instructs
<I>flex</I>

not to generate
<B>#line</B>

directives.  Without this option,
<I>flex</I>

peppers the generated scanner
with #line directives so error messages in the actions will be correctly
located with respect to the original
<I>flex</I>

input file, and not to
the fairly meaningless line numbers of
<B>lex.yy.c.</B>

(Unfortunately
<I>flex</I>

does not presently generate the necessary directives
to &quot;retarget&quot; the line numbers for those parts of
<B>lex.yy.c</B>

which it generated.  So if there is an error in the generated code,
a meaningless line number is reported.)
<DT><B>-T</B>

<DD>
makes
<I>flex</I>

run in
<I>trace</I>

mode.  It will generate a lot of messages to
<I>stdout</I>

concerning
the form of the input and the resultant non-deterministic and deterministic
finite automata.  This option is mostly for use in maintaining
<I>flex.</I>

<DT><B>-8</B>

<DD>
instructs
<I>flex</I>

to generate an 8-bit scanner, i.e., one which can recognize 8-bit
characters.  On some sites,
<I>flex</I>

is installed with this option as the default.  On others, the default
is 7-bit characters.  To see which is the case, check the verbose
<B>(-v)</B>

output for &quot;equivalence classes created&quot;.  If the denominator of
the number shown is 128, then by default
<I>flex</I>

is generating 7-bit characters.  If it is 256, then the default is
8-bit characters and the
<B>-8</B>

flag is not required (but may be a good idea to keep the scanner
specification portable).  Feeding a 7-bit scanner 8-bit characters
will result in infinite loops, bus errors, or other such fireworks,
so when in doubt, use the flag.  Note that if equivalence classes
are used, 8-bit scanners take only slightly more table space than
7-bit scanners (128 bytes, to be exact); if equivalence classes are
not used, however, then the tables may grow up to twice their
7-bit size.
<DT><B>-C[efmF]</B>

<DD>
controls the degree of table compression.
<DT><DD>
<B>-Ce</B>

directs
<I>flex</I>

to construct
<I>equivalence classes,</I>

i.e., sets of characters
which have identical lexical properties (for example, if the only
appearance of digits in the
<I>flex</I>

input is in the character class
&quot;[0-9]&quot; then the digits '0', '1', ..., '9' will all be put
in the same equivalence class).  Equivalence classes usually give
dramatic reductions in the final table/object file sizes (typically
a factor of 2-5) and are pretty cheap performance-wise (one array
look-up per character scanned).
<DT><DD>
<B>-Cf</B>

specifies that the
<I>full</I>

scanner tables should be generated -
<I>flex</I>

should not compress the
tables by taking advantages of similar transition functions for
different states.
<DT><DD>
<B>-CF</B>

specifies that the alternate fast scanner representation (described
above under the
<B>-F</B>

flag)
should be used.
<DT><DD>
<B>-Cm</B>

directs
<I>flex</I>

to construct
<I>meta-equivalence classes,</I>

which are sets of equivalence classes (or characters, if equivalence
classes are not being used) that are commonly used together.  Meta-equivalence
classes are often a big win when using compressed tables, but they
have a moderate performance impact (one or two &quot;if&quot; tests and one
array look-up per character scanned).
<DT><DD>
A lone
<B>-C</B>

specifies that the scanner tables should be compressed but neither
equivalence classes nor meta-equivalence classes should be used.
<DT><DD>
The options
<B>-Cf</B>

or
<B>-CF</B>

and
<B>-Cm</B>

do not make sense together - there is no opportunity for meta-equivalence
classes if the table is not being compressed.  Otherwise the options
may be freely mixed.
<DT><DD>
The default setting is
<B>-Cem,</B>

which specifies that
<I>flex</I>

should generate equivalence classes
and meta-equivalence classes.  This setting provides the highest
degree of table compression.  You can trade off
faster-executing scanners at the cost of larger tables with
the following generally being true:
<PRE>

    slowest &amp; smallest
          -Cem
          -Cm
          -Ce
          -C
          -C{f,F}e
          -C{f,F}
    fastest &amp; largest

</PRE>

Note that scanners with the smallest tables are usually generated and
compiled the quickest, so
during development you will usually want to use the default, maximal
compression.
<DT><DD>
<B>-Cfe</B>

is often a good compromise between speed and size for production
scanners.
<DT><DD>
<B>-C</B>

options are not cumulative; whenever the flag is encountered, the
previous -C settings are forgotten.
<DT><B>-Sskeleton_file</B>

<DD>
overrides the default skeleton file from which
<I>flex</I>

constructs its scanners.  You'll never need this option unless you are doing
<I>flex</I>

maintenance or development.
</DL>
<A NAME="lbAR">&nbsp;</A>
<H2>PERFORMANCE CONSIDERATIONS</H2>

The main design goal of
<I>flex</I>

is that it generate high-performance scanners.  It has been optimized
for dealing well with large sets of rules.  Aside from the effects
of table compression on scanner speed outlined above,
there are a number of options/actions which degrade performance.  These
are, from most expensive to least:
<PRE>

    REJECT

    pattern sets that require backtracking
    arbitrary trailing context

    '^' beginning-of-line operator
    yymore()

</PRE>

with the first three all being quite expensive and the last two
being quite cheap.
<P>

<B>REJECT</B>

should be avoided at all costs when performance is important.
It is a particularly expensive option.
<P>

Getting rid of backtracking is messy and often may be an enormous
amount of work for a complicated scanner.  In principal, one begins
by using the
<B>-b </B>

flag to generate a
<I>lex.backtrack</I>

file.  For example, on the input
<PRE>

    %%
    foo        return TOK_KEYWORD;
    foobar     return TOK_KEYWORD;

</PRE>

the file looks like:
<PRE>

    State #6 is non-accepting -
     associated rule line numbers:
           2       3
     out-transitions: [ o ]
     jam-transitions: EOF [ \001-n  p-\177 ]

    State #8 is non-accepting -
     associated rule line numbers:
           3
     out-transitions: [ a ]
     jam-transitions: EOF [ \001-`  b-\177 ]

    State #9 is non-accepting -
     associated rule line numbers:
           3
     out-transitions: [ r ]
     jam-transitions: EOF [ \001-q  s-\177 ]

    Compressed tables always backtrack.

</PRE>

The first few lines tell us that there's a scanner state in
which it can make a transition on an 'o' but not on any other
character, and that in that state the currently scanned text does not match
any rule.  The state occurs when trying to match the rules found
at lines 2 and 3 in the input file.
If the scanner is in that state and then reads
something other than an 'o', it will have to backtrack to find
a rule which is matched.  With
a bit of headscratching one can see that this must be the
state it's in when it has seen &quot;fo&quot;.  When this has happened,
if anything other than another 'o' is seen, the scanner will
have to back up to simply match the 'f' (by the default rule).
<P>

The comment regarding State #8 indicates there's a problem
when &quot;foob&quot; has been scanned.  Indeed, on any character other
than a 'b', the scanner will have to back up to accept &quot;foo&quot;.
Similarly, the comment for State #9 concerns when &quot;fooba&quot; has
been scanned.
<P>

The final comment reminds us that there's no point going to
all the trouble of removing backtracking from the rules unless
we're using
<B>-f</B>

or
<B>-F,</B>

since there's no performance gain doing so with compressed scanners.
<P>

The way to remove the backtracking is to add &quot;error&quot; rules:
<PRE>

    %%
    foo         return TOK_KEYWORD;
    foobar      return TOK_KEYWORD;

    fooba       |
    foob        |
    fo          {
                /* false alarm, not really a keyword */
                return TOK_ID;
                }

</PRE>

<P>

Eliminating backtracking among a list of keywords can also be
done using a &quot;catch-all&quot; rule:
<PRE>

    %%
    foo         return TOK_KEYWORD;
    foobar      return TOK_KEYWORD;

    [a-z]+      return TOK_ID;

</PRE>

This is usually the best solution when appropriate.
<P>

Backtracking messages tend to cascade.
With a complicated set of rules it's not uncommon to get hundreds
of messages.  If one can decipher them, though, it often
only takes a dozen or so rules to eliminate the backtracking (though
it's easy to make a mistake and have an error rule accidentally match
a valid token.  A possible future
<I>flex</I>

feature will be to automatically add rules to eliminate backtracking).
<P>

<I>Variable</I>

trailing context (where both the leading and trailing parts do not have
a fixed length) entails almost the same performance loss as
<I>REJECT</I>

(i.e., substantial).  So when possible a rule like:
<PRE>

    %%
    mouse|rat/(cat|dog)   run();

</PRE>

is better written:
<PRE>

    %%
    mouse/cat|dog         run();
    rat/cat|dog           run();

</PRE>

or as
<PRE>

    %%
    mouse|rat/cat         run();
    mouse|rat/dog         run();

</PRE>

Note that here the special '|' action does
<I>not</I>

provide any savings, and can even make things worse (see
<B>BUGS</B>

in <A HREF="http://localhost/cgi-bin/man/man2html?1+flex">flex</A>(1)).
<P>

Another area where the user can increase a scanner's performance
(and one that's easier to implement) arises from the fact that
the longer the tokens matched, the faster the scanner will run.
This is because with long tokens the processing of most input
characters takes place in the (short) inner scanning loop, and
does not often have to go through the additional work of setting up
the scanning environment (e.g.,
<B>yytext)</B>

for the action.  Recall the scanner for C comments:
<PRE>

    %x comment
    %%
            int line_num = 1;

    &quot;/*&quot;         BEGIN(comment);

    &lt;comment&gt;[^*\n]*
    &lt;comment&gt;&quot;*&quot;+[^*/\n]*
    &lt;comment&gt;\n             ++line_num;
    &lt;comment&gt;&quot;*&quot;+&quot;/&quot;        BEGIN(INITIAL);

</PRE>

This could be sped up by writing it as:
<PRE>

    %x comment
    %%
            int line_num = 1;

    &quot;/*&quot;         BEGIN(comment);

    &lt;comment&gt;[^*\n]*
    &lt;comment&gt;[^*\n]*\n      ++line_num;
    &lt;comment&gt;&quot;*&quot;+[^*/\n]*
    &lt;comment&gt;&quot;*&quot;+[^*/\n]*\n ++line_num;
    &lt;comment&gt;&quot;*&quot;+&quot;/&quot;        BEGIN(INITIAL);

</PRE>

Now instead of each newline requiring the processing of another
action, recognizing the newlines is &quot;distributed&quot; over the other rules
to keep the matched text as long as possible.  Note that
<I>adding</I>

rules does
<I>not</I>

slow down the scanner!  The speed of the scanner is independent
of the number of rules or (modulo the considerations given at the
beginning of this section) how complicated the rules are with
regard to operators such as '*' and '|'.
<P>

A final example in speeding up a scanner: suppose you want to scan
through a file containing identifiers and keywords, one per line
and with no other extraneous characters, and recognize all the
keywords.  A natural first approach is:
<PRE>

    %%
    asm      |
    auto     |
    break    |
    ... etc ...
    volatile |
    while    /* it's a keyword */

    .|\n     /* it's not a keyword */

</PRE>

To eliminate the back-tracking, introduce a catch-all rule:
<PRE>

    %%
    asm      |
    auto     |
    break    |
    ... etc ...
    volatile |
    while    /* it's a keyword */

    [a-z]+   |
    .|\n     /* it's not a keyword */

</PRE>

Now, if it's guaranteed that there's exactly one word per line,
then we can reduce the total number of matches by a half by
merging in the recognition of newlines with that of the other
tokens:
<PRE>

    %%
    asm\n    |
    auto\n   |
    break\n  |
    ... etc ...
    volatile\n |
    while\n  /* it's a keyword */

    [a-z]+\n |
    .|\n     /* it's not a keyword */

</PRE>

One has to be careful here, as we have now reintroduced backtracking
into the scanner.  In particular, while
<I>we</I>

know that there will never be any characters in the input stream
other than letters or newlines,
<I>flex</I>

can't figure this out, and it will plan for possibly needing backtracking
when it has scanned a token like &quot;auto&quot; and then the next character
is something other than a newline or a letter.  Previously it would
then just match the &quot;auto&quot; rule and be done, but now it has no &quot;auto&quot;
rule, only a &quot;auto\n&quot; rule.  To eliminate the possibility of backtracking,
we could either duplicate all rules but without final newlines, or,
since we never expect to encounter such an input and therefore don't
how it's classified, we can introduce one more catch-all rule, this
one which doesn't include a newline:
<PRE>

    %%
    asm\n    |
    auto\n   |
    break\n  |
    ... etc ...
    volatile\n |
    while\n  /* it's a keyword */

    [a-z]+\n |
    [a-z]+   |
    .|\n     /* it's not a keyword */

</PRE>

Compiled with
<B>-Cf,</B>

this is about as fast as one can get a
<I>flex </I>

scanner to go for this particular problem.
<P>

A final note:
<I>flex</I>

is slow when matching NUL's, particularly when a token contains
multiple NUL's.
It's best to write rules which match
<I>short</I>

amounts of text if it's anticipated that the text will often include NUL's.
<A NAME="lbAS">&nbsp;</A>
<H2>INCOMPATIBILITIES WITH LEX AND POSIX</H2>

<I>flex</I>

is a rewrite of the Unix
<I>lex</I>

tool (the two implementations do not share any code, though),
with some extensions and incompatibilities, both of which
are of concern to those who wish to write scanners acceptable
to either implementation.  At present, the POSIX
<I>lex</I>

draft is
very close to the original
<I>lex</I>

implementation, so some of these
incompatibilities are also in conflict with the POSIX draft.  But
the intent is that except as noted below,
<I>flex</I>

as it presently stands will
ultimately be POSIX conformant (i.e., that those areas of conflict with
the POSIX draft will be resolved in
<I>flex's</I>

favor).  Please bear in
mind that all the comments which follow are with regard to the POSIX
<I>draft</I>

standard of Summer 1989, and not the final document (or subsequent
drafts); they are included so
<I>flex</I>

users can be aware of the standardization issues and those areas where
<I>flex</I>

may in the near future undergo changes incompatible with
its current definition.
<P>

<I>flex</I>

is fully compatible with
<I>lex</I>

with the following exceptions:
<DL COMPACT>
<DT>-<DD>
The undocumented
<I>lex</I>

scanner internal variable
<B>yylineno</B>

is not supported.  It is difficult to support this option efficiently,
since it requires examining every character scanned and reexamining
the characters when the scanner backs up.
Things get more complicated when the end of buffer or file is reached or a
NUL is scanned (since the scan must then be restarted with the proper line
number count), or the user uses the yyless(), unput(), or REJECT actions,
or the multiple input buffer functions.
<DT><DD>
The fix is to add rules which, upon seeing a newline, increment
yylineno.  This is usually an easy process, though it can be a drag if some
of the patterns can match multiple newlines along with other characters.
<DT><DD>
yylineno is not part of the POSIX draft.
<DT>-<DD>
The
<B>input()</B>

routine is not redefinable, though it may be called to read characters
following whatever has been matched by a rule.  If
<B>input()</B>

encounters an end-of-file the normal
<B>yywrap()</B>

processing is done.  A ``real'' end-of-file is returned by
<B>input()</B>

as
<I>EOF.</I>

<DT><DD>
Input is instead controlled by redefining the
<B>YY_INPUT</B>

macro.
<DT><DD>
The
<I>flex</I>

restriction that
<B>input()</B>

cannot be redefined is in accordance with the POSIX draft, but
<B>YY_INPUT</B>

has not yet been accepted into the draft (and probably won't; it looks
like the draft will simply not specify any way of controlling the
scanner's input other than by making an initial assignment to
<I>yyin).</I>

<DT>-<DD>
<I>flex</I>

scanners do not use stdio for input.  Because of this, when writing an
interactive scanner one must explicitly call fflush() on the
stream associated with the terminal after writing out a prompt.
With
<I>lex</I>

such writes are automatically flushed since
<I>lex</I>

scanners use
<B>getchar()</B>

for their input.  Also, when writing interactive scanners with
<I>flex,</I>

the
<B>-I</B>

flag must be used.
<DT>-<DD>
<I>flex</I>

scanners are not as reentrant as
<I>lex</I>

scanners.  In particular, if you have an interactive scanner and
an interrupt handler which long-jumps out of the scanner, and
the scanner is subsequently called again, you may get the following
message:
<PRE>

    fatal flex scanner internal error--end of buffer missed

</PRE>

To reenter the scanner, first use
<PRE>

    yyrestart( yyin );

</PRE>

<DT>-<DD>
<B>output()</B>

is not supported.
Output from the
<B>ECHO</B>

macro is done to the file-pointer
<I>yyout</I>

(default
<I>stdout).</I>

<DT><DD>
The POSIX draft mentions that an
<B>output()</B>

routine exists but currently gives no details as to what it does.
<DT>-<DD>
<I>lex</I>

does not support exclusive start conditions (%x), though they
are in the current POSIX draft.
<DT>-<DD>
When definitions are expanded,
<I>flex</I>

encloses them in parentheses.
With lex, the following:
<PRE>

    NAME    [A-Z][A-Z0-9]*
    %%
    foo{NAME}?      printf( &quot;Found it\n&quot; );
    %%

</PRE>

will not match the string &quot;foo&quot; because when the macro
is expanded the rule is equivalent to &quot;foo[A-Z][A-Z0-9]*?&quot;
and the precedence is such that the '?' is associated with
&quot;[A-Z0-9]*&quot;.  With
<I>flex,</I>

the rule will be expanded to
&quot;foo([A-Z][A-Z0-9]*)?&quot; and so the string &quot;foo&quot; will match.
Note that because of this, the
<B>^, $, &lt;s&gt;, /,</B>

and
<B>&lt;&lt;EOF&gt;&gt;</B>

operators cannot be used in a
<I>flex</I>

definition.
<DT><DD>
The POSIX draft interpretation is the same as
<I>flex's.</I>

<DT>-<DD>
To specify a character class which matches anything but a left bracket (']'),
in
<I>lex</I>

one can use &quot;[^]]&quot; but with
<I>flex</I>

one must use &quot;[^\]]&quot;.  The latter works with
<I>lex,</I>

too.
<DT>-<DD>
The
<I>lex</I>

<B>%r</B>

(generate a Ratfor scanner) option is not supported.  It is not part
of the POSIX draft.
<DT>-<DD>
If you are providing your own yywrap() routine, you must include a
&quot;#undef yywrap&quot; in the definitions section (section 1).  Note that
the &quot;#undef&quot; will have to be enclosed in %{}'s.
<DT><DD>
The POSIX draft
specifies that yywrap() is a function and this is very unlikely to change; so
<I>flex users are warned</I>

that
<B>yywrap()</B>

is likely to be changed to a function in the near future.
<DT>-<DD>
After a call to
<B>unput(),</B>

<I>yytext</I>

and
<I>yyleng</I>

are undefined until the next token is matched.  This is not the case with
<I>lex</I>

or the present POSIX draft.
<DT>-<DD>
The precedence of the
<B>{}</B>

(numeric range) operator is different.
<I>lex</I>

interprets &quot;abc{1,3}&quot; as &quot;match one, two, or
three occurrences of 'abc'&quot;, whereas
<I>flex</I>

interprets it as &quot;match 'ab'
followed by one, two, or three occurrences of 'c'&quot;.  The latter is
in agreement with the current POSIX draft.
<DT>-<DD>
The precedence of the
<B>^</B>

operator is different.
<I>lex</I>

interprets &quot;^foo|bar&quot; as &quot;match either 'foo' at the beginning of a line,
or 'bar' anywhere&quot;, whereas
<I>flex</I>

interprets it as &quot;match either 'foo' or 'bar' if they come at the beginning
of a line&quot;.  The latter is in agreement with the current POSIX draft.
<DT>-<DD>
To refer to yytext outside of the scanner source file,
the correct definition with
<I>flex</I>

is &quot;extern char *yytext&quot; rather than &quot;extern char yytext[]&quot;.
This is contrary to the current POSIX draft but a point on which
<I>flex</I>

will not be changing, as the array representation entails a
serious performance penalty.  It is hoped that the POSIX draft will
be emended to support the
<I>flex</I>

variety of declaration (as this is a fairly painless change to
require of
<I>lex</I>

users).
<DT>-<DD>
<I>yyin</I>

is
<I>initialized</I>

by
<I>lex</I>

to be
<I>stdin;</I>

<I>flex,</I>

on the other hand,
initializes
<I>yyin</I>

to NULL
and then
<I>assigns</I>

it to
<I>stdin</I>

the first time the scanner is called, providing
<I>yyin</I>

has not already been assigned to a non-NULL value.  The difference is
subtle, but the net effect is that with
<I>flex</I>

scanners,
<I>yyin</I>

does not have a valid value until the scanner has been called.
<DT>-<DD>
The special table-size declarations such as
<B>%a</B>

supported by
<I>lex</I>

are not required by
<I>flex</I>

scanners;
<I>flex</I>

ignores them.
<DT>-<DD>
The name

FLEX_SCANNER
is #define'd so scanners may be written for use with either
<I>flex</I>

or
<I>lex.</I>

</DL>
<P>

The following
<I>flex</I>

features are not included in
<I>lex</I>

or the POSIX draft standard:
<PRE>

    yyterminate()
    &lt;&lt;EOF&gt;&gt;
    YY_DECL
    #line directives
    %{}'s around actions
    yyrestart()
    comments beginning with '#' (deprecated)
    multiple actions on a line

</PRE>

This last feature refers to the fact that with
<I>flex</I>

you can put multiple actions on the same line, separated with
semi-colons, while with
<I>lex,</I>

the following
<PRE>

    foo    handle_foo(); ++num_foos_seen;

</PRE>

is (rather surprisingly) truncated to
<PRE>

    foo    handle_foo();

</PRE>

<I>flex</I>

does not truncate the action.  Actions that are not enclosed in
braces are simply terminated at the end of the line.
<A NAME="lbAT">&nbsp;</A>
<H2>DIAGNOSTICS</H2>

<I>reject_used_but_not_detected undefined</I>

or
<I>yymore_used_but_not_detected undefined -</I>

These errors can occur at compile time.  They indicate that the
scanner uses
<B>REJECT</B>

or
<B>yymore()</B>

but that
<I>flex</I>

failed to notice the fact, meaning that
<I>flex</I>

scanned the first two sections looking for occurrences of these actions
and failed to find any, but somehow you snuck some in (via a #include
file, for example).  Make an explicit reference to the action in your
<I>flex</I>

input file.  (Note that previously
<I>flex</I>

supported a
<B>%used/%unused</B>

mechanism for dealing with this problem; this feature is still supported
but now deprecated, and will go away soon unless the author hears from
people who can argue compellingly that they need it.)
<P>

<I>flex scanner jammed -</I>

a scanner compiled with
<B>-s</B>

has encountered an input string which wasn't matched by
any of its rules.
<P>

<I>flex input buffer overflowed -</I>

a scanner rule matched a string long enough to overflow the
scanner's internal input buffer (16K bytes by default - controlled by
<B>YY_BUF_SIZE</B>

in &quot;flex.skel&quot;.  Note that to redefine this macro, you must first
<B>#undefine</B>

it).
<P>

<I>scanner requires -8 flag -</I>

Your scanner specification includes recognizing 8-bit characters and
you did not specify the -8 flag (and your site has not installed flex
with -8 as the default).
<P>

<I>fatal flex scanner internal error--end of buffer missed -</I>

This can occur in an scanner which is reentered after a long-jump
has jumped out (or over) the scanner's activation frame.  Before
reentering the scanner, use:
<PRE>

    yyrestart( yyin );

</PRE>

<P>

<I>too many %t classes! -</I>

You managed to put every single character into its own %t class.
<I>flex</I>

requires that at least one of the classes share characters.
<A NAME="lbAU">&nbsp;</A>
<H2>DEFICIENCIES / BUGS</H2>

See <A HREF="http://localhost/cgi-bin/man/man2html?1+flex">flex</A>(1).
<A NAME="lbAV">&nbsp;</A>
<H2>SEE ALSO</H2>

<P>

<A HREF="http://localhost/cgi-bin/man/man2html?1+flex">flex</A>(1), <A HREF="http://localhost/cgi-bin/man/man2html?1+lex">lex</A>(1), <A HREF="http://localhost/cgi-bin/man/man2html?1+yacc">yacc</A>(1), <A HREF="http://localhost/cgi-bin/man/man2html?1+sed">sed</A>(1), <A HREF="http://localhost/cgi-bin/man/man2html?1+awk">awk</A>(1).
<P>

M. E. Lesk and E. Schmidt,
<I>LEX - Lexical Analyzer Generator</I>

<A NAME="lbAW">&nbsp;</A>
<H2>AUTHOR</H2>

Vern Paxson, with the help of many ideas and much inspiration from
Van Jacobson.  Original version by Jef Poskanzer.  The fast table
representation is a partial implementation of a design done by Van
Jacobson.  The implementation was done by Kevin Gong and Vern Paxson.
<P>

Thanks to the many
<I>flex</I>

beta-testers, feedbackers, and contributors, especially Casey
Leedom, <A HREF="mailto:benson@odi.com">benson@odi.com</A>, Keith Bostic,
Frederic Brehm, Nick Christopher, Jason Coughlin,
Scott David Daniels, Leo Eskin,
Chris Faylor, Eric Goldman, Eric
Hughes, Jeffrey R. Jones, Kevin B. Kenny, Ronald Lamprecht,
Greg Lee, Craig Leres, Mohamed el Lozy, Jim Meyering, Marc Nozell, Esmond Pitt,
Jef Poskanzer, Jim Roskind,
Dave Tallman, Frank Whaley, Ken Yap, and those whose names
have slipped my marginal mail-archiving skills but whose contributions
are appreciated all the same.
<P>

Thanks to Keith Bostic, John Gilmore, Craig Leres, Bob
Mulcahy, Rich Salz, and Richard Stallman for help with various distribution
headaches.
<P>

Thanks to Esmond Pitt and Earle Horton for 8-bit character support;
to Benson Margulies and Fred
Burke for C++ support; to Ove Ewerlid for the basics of support for
NUL's; and to Eric Hughes for the basics of support for multiple buffers.
<P>

Work is being done on extending
<I>flex</I>

to generate scanners in which the
state machine is directly represented in C code rather than tables.
These scanners may well be substantially faster than those generated
using -f or -F.  If you are working in this area and are interested
in comparing notes and seeing whether redundant work can be avoided,
contact Ove Ewerlid (<A HREF="mailto:ewerlid@mizar.DoCS.UU.SE">ewerlid@mizar.DoCS.UU.SE</A>).
<P>

This work was primarily done when I was at the Real Time Systems Group
at the Lawrence Berkeley Laboratory in Berkeley, CA.  Many thanks to all there
for the support I received.
<P>

Send comments to:
<PRE>

     Vern Paxson
      Computer Systems Engineering
      Bldg. 46A, Room 1123
      Lawrence Berkeley Laboratory
      University of California
      Berkeley, CA 94720

      <A HREF="mailto:vern@ee.lbl.gov">vern@ee.lbl.gov</A>
      ucbvax!ee.lbl.gov!vern

</PRE>

<P>

<HR>
<A NAME="index">&nbsp;</A><H2>Index</H2>
<DL>
<DT><A HREF="#lbAB">NAME</A><DD>
<DT><A HREF="#lbAC">SYNOPSIS</A><DD>
<DT><A HREF="#lbAD">DESCRIPTION</A><DD>
<DT><A HREF="#lbAE">SOME SIMPLE EXAMPLES</A><DD>
<DT><A HREF="#lbAF">FORMAT OF THE INPUT FILE</A><DD>
<DT><A HREF="#lbAG">PATTERNS</A><DD>
<DT><A HREF="#lbAH">HOW THE INPUT IS MATCHED</A><DD>
<DT><A HREF="#lbAI">ACTIONS</A><DD>
<DT><A HREF="#lbAJ">THE GENERATED SCANNER</A><DD>
<DT><A HREF="#lbAK">START CONDITIONS</A><DD>
<DT><A HREF="#lbAL">MULTIPLE INPUT BUFFERS</A><DD>
<DT><A HREF="#lbAM">END-OF-FILE RULES</A><DD>
<DT><A HREF="#lbAN">MISCELLANEOUS MACROS</A><DD>
<DT><A HREF="#lbAO">INTERFACING WITH YACC</A><DD>
<DT><A HREF="#lbAP">TRANSLATION TABLE</A><DD>
<DT><A HREF="#lbAQ">OPTIONS</A><DD>
<DT><A HREF="#lbAR">PERFORMANCE CONSIDERATIONS</A><DD>
<DT><A HREF="#lbAS">INCOMPATIBILITIES WITH LEX AND POSIX</A><DD>
<DT><A HREF="#lbAT">DIAGNOSTICS</A><DD>
<DT><A HREF="#lbAU">DEFICIENCIES / BUGS</A><DD>
<DT><A HREF="#lbAV">SEE ALSO</A><DD>
<DT><A HREF="#lbAW">AUTHOR</A><DD>
</DL>
<HR>
This document was created by
<A HREF="http://localhost/cgi-bin/man/man2html">man2html</A>,
using the manual pages.<BR>
Time:  GMT, April 13, 2002
</BODY>
</HTML>
