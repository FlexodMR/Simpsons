/*===========================================================================
    Automatically generated by Jeeves, don't edit.  Edit p3ddel.sc instead

    File: Param.cpp 

    Command line parameters for p3ddel

   This tool deletes chunks from P3D files, either by chunk ID, or by name.

    Copyright (c) 2015 Radical Entertainment, Inc.  All rights reserved.

===========================================================================*/

#include "Param.hpp"
#include "toollib.hpp"
#include "version.hpp"

#include <constants\version.hpp>

#include <stdlib.h>
#include <stdio.h>
#include <string.h>
#include <getopt.h>
#include <time.h>
#include <ctype.h>

#ifdef P3DWIN95  
    #define WIN32_LEAN_AND_MEAN
    #define WIN32_EXTRA_LEAN
    #include <windows.h>
    #include <io.h>
#else
    #include <unistd.h>
#endif

static int htoi ( const char* str );

Parameters::~Parameters()
{
    strdelete( OutFile );
}

Parameters::Parameters(int argc, char* argv[]) :
    MeshDeletePattern( ),
    MeshKeepPattern( ),
    SkinDeletePattern( ),
    SkinKeepPattern( ),
    CompositeDeletePattern( ),
    CompositeKeepPattern( ),
    MaterialDeletePattern( ),
    MaterialKeepPattern( ),
    TextureDeletePattern( ),
    TextureKeepPattern( ),
    AnimDeletePattern( ),
    AnimKeepPattern( ),
    Files( )
{
    Argc = argc;
    Argv = argv;
    WriteHistory = TRUE;

    Recurse = false;
    isPattern = false;

    Verbosity = 0;
    int Hist = 0;

        OutFile           = NULL;
        DelDuplicate      = FALSE;
        CompareEverything = FALSE;
        CompareID         = FALSE;

    char ch;
    
    int option_index = 0;
    static struct option long_options[] = {
      {"help",no_argument,NULL,0},
      {0,0,0,0}
    };
    while ((ch = getopt_long(argc, argv, "?hHvVRP:nd:k:g:G:s:S:c:C:m:M:t:T:a:A:o:DEe",long_options,&option_index)) != EOF)
    {
        switch(ch)
        {
            // Handle the long arguments first
            case 0:
            switch(option_index)
            {
                case 0:   // help
                    Usage();
                    break;
                default:
                    printf("ERROR! Bad index from getopt_long!\\n");
                    exit(-1);
            }
            break;
            
            // Now the short arguments
            case 'd':
            {
                int hexval = htoi(optarg);
                DeleteList.Append(hexval);
                break;
            }
            case 'k':
            {
                int hexval = htoi(optarg);
                KeepList.Append(hexval);
                break;
            }
            case 'g':
                MeshDeletePattern.Append(optarg);
                break;
            case 'G':
                MeshKeepPattern.Append(optarg);
                break;
            case 's':
                SkinDeletePattern.Append(optarg);
                break;
            case 'S':
                SkinKeepPattern.Append(optarg);
                break;
            case 'c':
                CompositeDeletePattern.Append(optarg);
                break;
            case 'C':
                CompositeKeepPattern.Append(optarg);
                break;
            case 'm':
                MaterialDeletePattern.Append(optarg);
                break;
            case 'M':
                MaterialKeepPattern.Append(optarg);
                break;
            case 't':
                TextureDeletePattern.Append(optarg);
                break;
            case 'T':
                TextureKeepPattern.Append(optarg);
                break;
            case 'a':
                AnimDeletePattern.Append(optarg);
                break;
            case 'A':
                AnimKeepPattern.Append(optarg);
                break;
            case 'D':
                DelDuplicate = TRUE;
                break;
            case 'E':
                CompareEverything = TRUE;
                break;
            case 'e':
                CompareID = TRUE;
                break;
            case 'o':
                OutFile = strnew(optarg);
                break;
            case 'V':
                Verbosity+=100;
                break;
            case 'v':
                Verbosity++;
                break;
            case 'n':
                WriteHistory = FALSE;
                break;
            case 'H':
                Hist++;
                break;
         case 'R':
            Recurse = TRUE;
            break;
         case 'P':
            isPattern = TRUE;
            FilePattern = strnew(optarg);
            break;
            case 'h':
                Usage();
                break;
            case '?':
            default:
                ShortUsage();
                break;
        }
    }   
    if(Hist){
        VersionHistory(Hist);
    }

    for(int i=optind;i<argc;i++)
    {
#ifdef P3DWIN95

      filebuildup(argv[i]);

#else
        Files.Append(argv[i]);
#endif
    }

    if(Files.Count() ==0)
    {
        ShortUsage();
    }
}

void
Parameters::ShortUsage()
{
    printf("p3ddel version %s\n",version);
    printf("Using ATG %s Changelist %s %s\n", ATG_VERSION, compileChangelist, compileTime);
    puts( "\nCopyright Radical Entertainment 2015\n\n"
            "   Usage: p3ddel [options] <inputfile> [<inputfile> ...]\n\n"

         "This tool deletes chunks from P3D files, either by chunk ID, or by name.\n"
            "\n"
            "Try p3ddel --help for more info.\n");
    exit(1);
}

void
Parameters::Usage()
{
    printf("p3ddel version %s\n",version);
    printf("Using ATG %s Changelist %s %s\n", ATG_VERSION, compileChangelist, compileTime);
    puts( "\nCopyright Radical Entertainment 2015\n\n"
            "   Usage: p3ddel [options] <inputfile> [<inputfile> ...]\n\n"
         "This tool deletes chunks from P3D files, either by chunk ID, or by name.\n"
            "\n"
            "Support for filename wildcards is provided.\n"
            "\n"
            "Possible options are:\n"
         "-d ID       Delete chunks matching ID \n"
         "-k ID       Keep chunks matching ID (deleting everything else)\n"
         "-g Pattern  Delete geometries matching Pattern\n"
         "-G Pattern  Delete geometries not matching Pattern\n"
         "-s Pattern  Delete skins matching Pattern\n"
         "-S Pattern  Delete skins not matching Pattern\n"
         "-c Pattern  Delete composite drawables matching Pattern\n"
         "-C Pattern  Delete composite drawables not matching Pattern\n"
         "-m Pattern  Delete materials / shaders matching Pattern\n"
         "-M Pattern  Delete materials / shaders not matching Pattern\n"
         "-t Pattern  Delete textures matching Pattern\n"
         "-T Pattern  Delete textures not matching Pattern\n"
         "-a Pattern  Delete animations matching Pattern\n"
         "-A Pattern  Delete animations not matching Pattern\n"
         "-o File     Write output to File.\n"
         "-D          Delete duplicate chunks (just compares names by default)\n"
         "-E          Check entire contents when removing duplicate chunks\n"
         "-e          Check chunk ID when removing duplicate chunks (overrides\n"
         "             -E)\n"
            "\n"
            "Standard options:\n"
            "  -v            Verbose output (more v's for more output)\n"
            "  -V            Maximum verbosity\n"
            "  -n            Suppress the P3D_HISTORY chunk\n"
            "  -H            Show version History\n"
            "  -h --help     Print this message\n"
        );
    exit(1);
}
void
Parameters::VersionHistory(int count)
{
    printf("Using ATG %s Changelist %s %s\n", ATG_VERSION, compileChangelist, compileTime);
    puts( "Copyright Radical Entertainment 2015\n");

    for(int x=0; versioninfo[x] && (x<10*count); x++){
          printf("%s\n",versioninfo[x]);
    }
    exit(0);
}

void
Parameters::filebuildup(char* filename)
{
    // This funky code is all to handle wildcards on sub-Unix operating systems
    if(strchr(filename,'*') || strchr(filename,'?') || !strcmp(filename,".") ){
        char Path[1024];
        char Path2[1024];
        char fullPath[1024];

        strcpy(Path,filename);

        if( strrchr(Path,'\\') || strrchr(Path,'/') )
        {
            strcpy(fullPath, filename);
        }
        else
        {
            strcpy(Path,".");    
            strcpy(fullPath, Path);
        }

        if (fullPath[strlen(fullPath)-1] != '\\')
        {
            int length = strlen(fullPath);

            fullPath[length] = '\\';
            fullPath[length+1] = '\0';
        }

        strcat(fullPath, filename);

        _finddata_t fd;


        long handle = _findfirst( fullPath, &fd );

        if( handle == -1 && !Recurse ){
            printf( "%s: No Match", fullPath );
            exit( -1 );
        }

        while( handle != -1 ){
            if ( !strcmp(fd.name,".") || !strcmp(fd.name,"..") )
            {
               if(_findnext( handle, &fd ) == -1) break;
               continue;
            }

            // filename is not a directory
            if ( !(fd.attrib & 0x10) ){
               char buf[1024];

               sprintf(buf,"%s\\%s",Path,fd.name);

               char* pathname = buf;
               Files.Append(pathname);
            }

            if(_findnext( handle, &fd ) == -1) break;
        }

        // if we are doing recursion then look at the directories
        if(Recurse){
            strcpy(fullPath, Path);
            strcat(fullPath, "\\*");

            long handle = _findfirst( fullPath, &fd );

            if( handle == -1 && !Recurse )
            {
               printf( "%s: No Match", filename );
               exit( -1 );
            }

            while( handle != -1 ){
               if ( !strcmp(fd.name,".") || !strcmp(fd.name,"..") )
               {
                  if(_findnext( handle, &fd ) == -1) break;
                  continue;
               }

               // filename is actually a directory
               if ( fd.attrib & 0x10 )
               {
                  // buildup the appropriate pathname to pass into the recursive function
                  strcpy(Path2,Path);
                  strcat(Path2,"\\");
                  strcat(Path2,fd.name);
                  strcat(Path2,"\\");

                  filebuildup(Path2);
               }

               if(_findnext( handle, &fd ) == -1) break;
            }
        }
    } 
    else{
        Files.Append(filename);
    }
}

tlDataChunk*
Parameters::HistoryChunk()
{
    tlHistory history;
    char buf[512];
    sprintf(buf,"p3ddel version %s (with ATG %s)", version, ATG_VERSION);
    history.AddLine(buf);
    char* b = buf;
    int i;
    for( i = 0; i < Argc; i++)
    {
        if(b + strlen(Argv[i]) > buf + 251)       // 252 is the largest multiple of 4 less than 256
        {
            // terminate the string as a precaution
            buf[252] = 0;
            history.AddLine(buf);
            b = buf;
        }
        b += sprintf(b,"%s ",Argv[i]);
    }
    // remove the last space
    if( i > 0 )
    {
        *(b-1) = 0;
    }
    // terminate the string as a precaution
    buf[252] = 0;
    history.AddLine(buf);

    // Logon name and date info
    time_t ltime;
    struct tm *now;
    time(&ltime);
    now = localtime(&ltime);
    strftime(buf, 256, "Run at %B %d, %Y, %H:%M:%S by ", now);

#ifdef P3DWIN95
    DWORD size = 256;
    char lbuf[256];
    GetUserName(lbuf, &size);

    strcat(buf, lbuf);
#else
    char* loginname = getlogin();
    if(loginname)
    {
        strcat(buf, loginname);
    } else {
        strcat(buf, "Unknown");
    }
#endif
    history.AddLine(buf);
    
    return history.Chunk();
}

// hextodec converts '0'-'F' to 0 to 16
// This is ugly code. 

static int 
hextodec ( int chr )
{
     return isdigit(chr) ? (chr - '0') : ((chr & ~('a' - 'A')) - 'A' + 10);
}

// Like atoi, but expect the input in hex,

static int 
htoi ( const char* str )
{
    int result = 0;;
    const char* s = str;

    while(*s)
    {
        result <<= 4;
        result += hextodec(*s);
        s++;
    }

    return result;
}

