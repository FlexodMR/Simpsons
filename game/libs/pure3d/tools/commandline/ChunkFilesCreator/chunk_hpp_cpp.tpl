@CODEBEGIN
    std::map<string, string> typemap;
    std::map<string, string> typeinit;
    std::map<string, string> typeget;
    std::map<string, string> typeput;
    std::map<string, string> typeprint;
    std::map<string, string> typeprintlong;
    std::map<string, string> typekeyword;
    std::map<string, int> typebulkread;
    std::map<string, string> type_field_value;
    std::map<string, string> included_subchunk_id;
    typemap["string"] = "char*"; 
    typemap["longstring"] = "char*";
    typemap["COLOUR" ] = "unsigned long";
    typemap["FOURCC"] = "unsigned long";
    typemap["ULONG"] = "unsigned long";
    typemap["UBYTE"] = "unsigned char";
    typemap["UWORD"] = "unsigned short";
    typemap["WORD"] =  "short";
    typemap["float"] = "float";
 
    typeinit["string"] = "NULL"; 
    typeinit["longstring"] = "NULL";
    typeinit["COLOUR" ] = "0";
    typeinit["FOURCC"] = "0";
    typeinit["ULONG"] = "0";
    typeinit["UBYTE"] = "0";
    typeinit["UWORD"] = "0";
    typeinit["WORD"] =  "0";
    typeinit["float"] = "0.0f";
 
    typeget["string"] = "GetPString"; 
    typeget["longstring"] = "GetLongString";
    typeget["COLOUR" ] = "GetLong";
    typeget["FOURCC"] = "GetLong";
    typeget["ULONG"] = "GetLong";
    typeget["UBYTE"] = "GetChar";
    typeget["UWORD"] = "GetWord";
    typeget["WORD"] =  "GetWord";
    typeget["float"] = "GetFloat";
 
    typeput["string"] = "PutPString"; 
    typeput["longstring"] = "PutLongString";
    typeput["COLOUR" ] = "PutLong";
    typeput["FOURCC"] = "PutLong";
    typeput["ULONG"] = "PutLong";
    typeput["UBYTE"] = "PutChar";
    typeput["UWORD"] = "PutWord";
    typeput["WORD"] =  "PutWord";
    typeput["float"] = "PutFloat";
 
    typeprint["string"] = "\\\"%s\\\""; 
    typeprint["longstring"] = "\\\"%s\\\"";
    typeprint["COLOUR" ] = "%08lx";
    typeprint["FOURCC"] = "%08lx";
    typeprint["ULONG"] = "%ld";
    typeprint["UBYTE"] = "%d";
    typeprint["UWORD"] = "%d";
    typeprint["WORD"] =  "%d";
    typeprint["float"] = "%f";
 
    typeprintlong["string"] = "\\\"%s\\\""; 
    typeprintlong["longstring"] = "\\\"%s\\\"";
    typeprintlong["COLOUR" ] = "0x%08lx";
    typeprintlong["FOURCC"] = "0x%08lx";
    typeprintlong["ULONG"] = "%12ld";
    typeprintlong["UBYTE"] = "%12d";
    typeprintlong["UWORD"] = "%12d";
    typeprintlong["WORD"] =  "%12d";
    typeprintlong["float"] = "%12f";
 
    typekeyword["string"] = "pstring"; 
    typekeyword["longstring"] = "longstring";
    typekeyword["COLOUR" ] = "int  ";
    typekeyword["FOURCC"] = "int  ";
    typekeyword["ULONG"] = "int  ";
    typekeyword["UBYTE"] = "byte ";
    typekeyword["UWORD"] = "short";
    typekeyword["WORD"] =  "short";
    typekeyword["float"] = "float";
 
    typebulkread["string"] = 0; 
    typebulkread["longstring"] = 0;
    typebulkread["COLOUR" ] = 1;
    typebulkread["FOURCC"] = 1;
    typebulkread["ULONG"] = 1;
    typebulkread["UBYTE"] = 1;
    typebulkread["UWORD"] = 1;
    typebulkread["WORD"] =  1;
    typebulkread["float"] = 1;
 
    type_field_value["string"] = "%s"; 
    type_field_value["longstring"] = "%s";
    type_field_value["COLOUR" ] = "0x%08lx";
    type_field_value["FOURCC"] = "0x%08lx";
    type_field_value["ULONG"] = "%ld";
    type_field_value["UBYTE"] = "%d";
    type_field_value["UWORD"] = "%d";
    type_field_value["WORD"] =  "%d";
    type_field_value["float"] = "%f";
    // start writing out HPP file
    OpenOutputFile( Param->IncOutputDir, ".hpp" );
@CODEEND

// Automatically generated by Jeeves, don't edit.  Edit ${schemaFileName} instead

#ifndef _${pureSchemaFileName}_HPP_
#define _${pureSchemaFileName}_HPP_

#ifdef WIN32
#pragma warning(disable:4786)
#endif

#include "tlDataChunk.hpp"

// things included by ${schemaFileName}
@CODE   ListPropertyPrintOut( 0, "includehpp", "#include <%s>\n" );

//class referred by ${schemaFileName}
@CODE   ListPropertyPrintOut( 0, "declaretype", "class %s;\n" );
@CODE   ObjectPrintOut( 0, "chunk", "class %s;\n" );
@CODE   ObjectPrintOut( 0, "struct", "struct %s;\n" );

@CODE   int i, j;
@CODE   //print out all structs
@CODE   for( i = 0; i < AST->ObjectsCount(  ); ++i ){
@CODE       Object * o = AST->objects[ i ];
@CODE       if( strcmp( o->className, "struct" ) != 0 )
@CODE           continue;

struct ${o->name}
{
    // Data Members
    @CODE // compute longest type
    @CODE int len = o->MaxMemberTypeLength( &typemap );
    @CODE for( j = 0; j < o->MembersCount( ); ++j ){
        @CODE Member *m = o->members[ j ];
        @CODE char type[ MAX_LINE_LEN ], name[ MAX_LINE_LEN ], alignedType[ MAX_LINE_LEN ];        
        @CODE memset( type, 0, MAX_LINE_LEN );
        @CODE memset( name, 0, MAX_LINE_LEN );
        @CODE memset( alignedType, 0, MAX_LINE_LEN );       
        @CODE GetTrueMemberType( m, type );
        @CODE bool typemapped = FindMemberTypeMapping( m, type, &typemap );    
        @CODE AlignString( type, len, true, alignedType );
        @CODE StringLower( name, m->name );

    ${alignedType} ${name};
@CODE       }


    // Methods
    ~${o->name}();    
    void Read(tlFile* f);
    void Write(tlFile* f);
    void Print(int print_index, int indent = 0);
    void PrintFormatted(int print_index, int indent = 0);

    const char* GetType() const;
    int         GetFieldCount() const;
    const char* GetFieldName(int) const;
    bool        GetFieldValue(char*, int) const;
    static bool GetFieldUpdatable();
    bool        SetFieldValue(const char* new_val);

    void Init();
    ${o->name}& operator=(const ${o->name}&); 
    int  operator==(const ${o->name}& a);
};
@CODE   }			//end of printing out struct list

@CODE //now create all chunks
@CODE   for( i = 0; i < AST->ObjectsCount(  ); ++i ){
@CODE       int len;
@CODE       Object * o = AST->objects[ i ];
@CODE       if( strcmp( o->className, "chunk" ) != 0 )
@CODE           continue;


class ${o->name} : public tlDataChunk 
{
@CODE       // compute longest type
@CODE       len = o->MaxMemberTypeLength( &typemap );
public:

    // Methods
    ${o->name}(); 
    ${o->name}(tlReadChunk16* ch); 
    ${o->name}(const ${o->name}& ch); 
    ~${o->name}();

    void Init();

    ${o->name}& operator=(const ${o->name}&); 
    virtual bool operator==(const tlDataChunk&);    // Returns true if the chunks are identical
    virtual bool NameCompare(const tlDataChunk&);   // Returns true if the chunks are the
                                                                    // same type and have the same name

    static tlDataChunk* Create(tlReadChunk16* ch);
    virtual long Size( );
    void   Write(tlFile* f);
    void   Print(int indent = 0,
                     unsigned int printdepth = 0xffffffff,
                     unsigned int typemask = 0xffffffff);
    void   PrintFormatted(int indent = 0);

    const char* GetType() const;
    int         GetFieldCount() const;
    bool        GetFieldIsArray(int) const;
    int         GetFieldArrayCount(int) const;
    const char* GetFieldType(int) const;
    const char* GetFieldName(int) const;
    bool        GetFieldValue(int, char*, int) const;
    bool        GetFieldArrayValue(int, int, char*, int) const;
    bool        GetFieldUpdatable(int) const;
    bool        SetFieldValue(int, const char*);
    bool        SetFieldArrayValue(int, int, const char*);

    static tlDataChunk* LoadSubChunk(tlFile* f);
    tlDataChunk* Copy(); 

    virtual int SortPriority() {return ${o->name}::sortPriority;}

    // Accessor Methods;
@CODE	// compute longest type
@CODE       len = o->MaxMemberTypeLength( &typemap );
@CODE       for( j = 0; j < o->MembersCount( ); ++j ){
    @CODE Member *m = o->members[ j ];
    @CODE char voidtype[ MAX_LINE_LEN ], type[ MAX_LINE_LEN ], name[ MAX_LINE_LEN ], alignedType[ MAX_LINE_LEN ], tmp[ MAX_LINE_LEN ], basetype[ MAX_LINE_LEN ];    
    @CODE memset( voidtype, 0, MAX_LINE_LEN );
    @CODE memset( type, 0, MAX_LINE_LEN );
    @CODE memset( name, 0, MAX_LINE_LEN );
    @CODE memset( alignedType, 0, MAX_LINE_LEN );
    @CODE memset( tmp, 0, MAX_LINE_LEN );    
    @CODE GetTrueMemberType( m, type );
    @CODE bool typemapped = FindMemberTypeMapping( m, type, &typemap );  
    @CODE strcpy( basetype, type );  
    @CODE if( m->IsType( "string" ) || m->IsType("longstring") || AST->HasProperty( "class", type ) ){
        @CODE  strcpy( tmp, "const " );
        @CODE  strcat( tmp, type );
        @CODE  strcpy( type, tmp );
    @CODE }    
    @CODE if( m->IsType( "array" ) ){
        @CODE strcat( type, "*" );
    @CODE }    
    @CODE if( (!m->IsType( "array" )) && AST->HasProperty( "class", basetype ) ){
        @CODE strcat( type, "&" );
    @CODE }
    @CODE strcpy( name, m->name );
    @CODE _strlwr( name );
    @CODE AlignString( type, len, true, alignedType );

    ${alignedType} ${m->name}( );
    ${alignedType} Get${m->name}() { return ${m->name}(); }
@CODE           AlignString( "void", len, true, voidtype );
@CODE           if( m->IsType( "array" ) ){
    ${voidtype} Set${m->name}(${type}, int count);
@CODE           }
@CODE           else{
    ${voidtype} Set${m->name}(${type});
@CODE           }	
@CODE       }		//end of creating all Get/Set attribute methods

private:

    // Static data
    static int sortPriority;

    // Data Members
@CODE       for( j = 0; j < o->MembersCount( ); ++j ){
    @CODE Member *m = o->members[ j ];
    @CODE char type[ MAX_LINE_LEN ],  alignedType[ MAX_LINE_LEN ];        
    @CODE memset( type, 0, MAX_LINE_LEN );    
    @CODE memset( alignedType, 0, MAX_LINE_LEN );       
    @CODE GetTrueMemberType( m, type );
    @CODE bool typemapped = FindMemberTypeMapping( m, type, &typemap );        
    @CODE if( m->IsType( "array" ) ){
        @CODE strcat( type, "*" );
    @CODE }    
    @CODE AlignString( type, len, true, alignedType );
    @CODE char lowname[ MAX_LINE_LEN ];
    @CODE StringLower( lowname, m->name );
    ${alignedType} ${lowname};
@CODE       }		//end of creating all Get/Set attribute methods

};
@CODE   }		//end of printing out chunk list

#endif

@CODE   // start writing out CPP file
@CODE   GetIncludedChunkID( AST, &included_subchunk_id );
@CODE   OpenOutputFile( Param->SrcOutputDir, ".cpp" );
// Automatically generated by Jeeves, don't edit.  Edit ${schemaFileName} instead

#include "${pureSchemaFileName}.hpp"
#include "tlString.hpp"
#include "tlFile.hpp"
#include "tlChunk16.hpp"

#include <stdio.h>
#include <stdlib.h>
#include <assert.h>
#include <memory.h>
#include <string.h>


// things included by ${schemaFileName}
@CODE   //print out all structs related code
@CODE   for( i = 0; i < AST->ObjectsCount(  ); ++i ){
@CODE       Object * o = AST->objects[ i ];
@CODE       if( strcmp( o->className, "struct" ) != 0 )
@CODE           continue;
// ${o->name}

${o->name}::~${o->name}()
{
@CODE   MemberPrintOut( o, 4, "string", "strdelete( %s );\n" );
@CODE   MemberPrintOut( o, 4, "longstring", "strdelete( %s );\n" );   
}

void
${o->name}::Read(tlFile*f )
{
@CODE   if( o->HasMemberType( "string" ) ){
    char buf[P3DMAXNAME];
@CODE   }
@CODE   for( j = 0; j < o->MembersCount( ); ++j ){
@CODE       Member *m = o->members[ j ];
@CODE       char  name[ MAX_LINE_LEN ];
@CODE       memset( name, 0, MAX_LINE_LEN  );
@CODE       strcpy( name, m->name );
@CODE       _strlwr( name );
@CODE       if( m->IsType( "string" ) ){
    f->GetPString( buf );
    ${name} = strnew( buf );
@CODE       }
@CODE       else if( typeget.find( m->GetTypeName( ) ) != typeget.end( ) ){
    ${name} = f->${typeget[ m->GetTypeName( ) ].c_str( )}();        
@CODE       }
@CODE       else{
    ${name}.Read( f );
@CODE       }
@CODE   }
}

void
${o->name}::Write(tlFile*f )
{
@CODE   for( j = 0; j < o->MembersCount( ); ++j ){
@CODE       Member *m = o->members[ j ];
@CODE       char  name[ MAX_LINE_LEN ];
@CODE       memset( name, 0, MAX_LINE_LEN  );
@CODE       strcpy( name, m->name );
@CODE       _strlwr( name );
@CODE       if( typeput.find( m->GetTypeName( ) ) != typeput.end( ) ){
    f->${typeput[ m->GetTypeName( ) ].c_str( )}( ${name} );
@CODE       }
@CODE       else{
    ${name}.Write( f );
@CODE       }
@CODE   }
}

void
${o->name}::Print(int print_index, int indent)
{
    printf("%*s%d\n", indent, "", (int)print_index);
    @CODE int longest = o->MaxMemberNameLength( );
    @CODE for( j = 0; j < o->MembersCount( ); ++j ){
        @CODE  Member *m = o->members[ j ];
        @CODE  char prstr[ MAX_LINE_LEN ];
        @CODE  memset( prstr, 0, MAX_LINE_LEN );
        @CODE  strcpy( prstr, "%d" );
        @CODE  bool typeprinted = FindMemberTypeMapping( m, prstr , &typeprint );
        @CODE  char name[ MAX_LINE_LEN ];
        @CODE  memset( name, 0, MAX_LINE_LEN );
        @CODE char lowname[ MAX_LINE_LEN ];
        @CODE memset( lowname, 0, MAX_LINE_LEN );
        @CODE strcpy( lowname, m->name );
        @CODE _strlwr( lowname );
        @CODE AlignString( m->name, longest, 1, name );        
    printf("%*s  ${name} = ${prstr}\n", indent, "", ${lowname});
    @CODE }   
}

void
${o->name}::PrintFormatted(int print_index, int indent)
{
    @CODE for( j = 0; j < o->MembersCount( ); ++j ){
        @CODE Member *m = o->members[ j ];
        @CODE char prstr[ MAX_LINE_LEN ];
        @CODE char prkey[ MAX_LINE_LEN ];
        @CODE memset( prstr, 0, MAX_LINE_LEN );
        @CODE memset( prkey, 0, MAX_LINE_LEN );
        @CODE strcpy( prstr, "%d" );
        @CODE bool typelongprinted = FindMemberTypeMapping( m, prstr, &typeprintlong );
        @CODE bool typekeyworded = FindMemberTypeMapping( m, prkey, &typekeyword );
        @CODE char name[ MAX_LINE_LEN ];
        @CODE memset( name, 0, MAX_LINE_LEN );
        @CODE char lowname[ MAX_LINE_LEN ];
        @CODE memset( lowname, 0, MAX_LINE_LEN );
        @CODE strcpy( lowname, m->name );
        @CODE _strlwr( lowname );
        @CODE AlignString( m->name, longest, 1, name );
    printf("%*s ${prkey} ${prstr}  # ${name}\n", indent, "", ${lowname});
    @CODE  }
}

const char* 
${o->name}::GetType() const
{
    return "${o->name}";
}

int 
${o->name}::GetFieldCount() const
{
@CODE   {
@CODE   char buffer[ MAX_LINE_LEN ];
@CODE   memset( buffer, 0, MAX_LINE_LEN );
@CODE   sprintf( buffer, "%d", o->MembersCount( ) );
    return ${buffer};
@CODE   }
}

bool 
${o->name}::GetFieldValue(char* val, int len) const
{
    char buf[65536];
    int val_length = 0, cur_length;
    bool length_exceeded = false;

    val[0] = 0;

    @CODE for( j = 0; j < o->MembersCount( ); ++j ){
        @CODE Member *m = o->members[ j ];
        @CODE char prstr[ MAX_LINE_LEN ];
        @CODE memset( prstr, 0, MAX_LINE_LEN );
        @CODE char name[ MAX_LINE_LEN ];
        @CODE memset( name, 0, MAX_LINE_LEN );
        @CODE strcpy( prstr, "%d" );
        @CODE bool mapped = FindMemberTypeMapping( m, prstr,  &type_field_value );
        @CODE strcpy( name, m->name );
        @CODE _strlwr( name );
        @CODE if( m->IsType("FOURCC") ){
    sprintf(buf, "${m->name}= %s, ", tlFourCC(${name}).AsChar());
        @CODE }
        @CODE else{
    sprintf(buf, "${m->name}= ${prstr}, ", ${name});
        @CODE }
    cur_length = strlen(buf);
    if (val_length + cur_length <= len)
    {
        strcat(val, buf);
        val_length += cur_length;
    }
    else
    {
        length_exceeded = true;
    }

    @CODE }

    if (length_exceeded)
    {
        if (val_length + 3 <= len)
        {
            strcat(val, "...");
        }
    }
    else if ((val_length > 2) && (val[val_length-2] == ','))
    {
        val[val_length-2] = 0;
    }

    return true;
}

bool 
${o->name}::GetFieldUpdatable()
{
    return false;
}

bool 
${o->name}::SetFieldValue(const char* new_val)
{
    return false;
}

void
${o->name}::Init()
{
@CODE   for( j = 0; j < o->MembersCount( ); ++j ){
@CODE       Member *m = o->members[ j ];
@CODE       if( m->IsType( "Chunk" ) )
@CODE           continue;
@CODE       char  name[ MAX_LINE_LEN ];
@CODE       char  init[ MAX_LINE_LEN ];
@CODE       memset( init, 0, MAX_LINE_LEN  );
@CODE       StringLower( name, m->name );
@CODE       bool mapped = FindMemberTypeMapping( m, init, &typeinit );
@CODE       if( m->IsType( "array" ) )
@CODE           strcpy( init, "NULL" );
@CODE       if( mapped ){
    ${name} = ${init};
@CODE       }
@CODE       else{
    ${name}.Init( );
@CODE       }
@CODE   }

}

${o->name}&
${o->name}::operator=(const ${o->name}& a)
{
@CODE   for( j = 0; j < o->MembersCount( ); ++j ){
@CODE       Member *m = o->members[ j ];
@CODE       if( m->IsType( "Chunk" ) )
@CODE           continue;
@CODE       char  name[ MAX_LINE_LEN ];
@CODE       memset( name, 0, MAX_LINE_LEN  );
@CODE       strcpy( name, m->name );
@CODE       _strlwr( name ); 
@CODE       if( m->IsType( "string" ) ){
    ${name} = strnew(a.${name});
@CODE       }
@CODE       else{
    ${name} = a.${name};
@CODE       }
@CODE   }
    return *this;
}

int
${o->name}::operator==(const ${o->name}& a)
{
@CODE   for( j = 0; j < o->MembersCount( ); ++j ){
@CODE       Member *m = o->members[ j ];
@CODE       char  name[ MAX_LINE_LEN ];
@CODE       memset( name, 0, MAX_LINE_LEN  );
@CODE       strcpy( name, m->name );
@CODE       _strlwr( name ); 
@CODE       if( m->IsType( "string" ) ){
    if(strcmp(${name}, a.${name}) != 0)
@CODE       }
@CODE       else{
    if(!(${name} == a.${name}))
    {
        return false;
    }
@CODE       }
@CODE   }

    return true;
}

@CODE   }           //end print out struct code

@CODE   //now start print out all chunk codes
@CODE   // .................................

@CODE   //print out all chunk related code
@CODE   for( i = 0; i < AST->ObjectsCount(  ); ++i ){
@CODE       char buffer[ 1024 ];
@CODE       Object * o = AST->objects[ i ];
@CODE       if( strcmp( o->className, "chunk" ) != 0 )
@CODE           continue;
// ${o->name}

int ${o->name}::sortPriority = -1;

${o->name}::${o->name}()
{
    Init();
}

${o->name}::${o->name}(const ${o->name}& ch)
{
    Init();
    *this = ch;
}

${o->name}::~${o->name}()
{
@CODE   bool needi = false;
@CODE   for( j = 0; j < o->MembersCount( ); ++j ){
@CODE       if( o->members[ j ]->IsArrayType( "string" ) || o->members[ j ]->IsArrayType( "longstring" ) )
@CODE           needi = true;
@CODE   }
@CODE   if( needi ){
    unsigned int i;

@CODE   }

@CODE for( j = 0; j < o->MembersCount( ); ++j ){
    @CODE Member *m = o->members[ j ];
    @CODE char  name[ MAX_LINE_LEN ];
    @CODE memset( name, 0, MAX_LINE_LEN  );
    @CODE strcpy( name, o->members[ j ]->name );
    @CODE _strlwr( name );
    @CODE if( o->members[ j ]->IsArrayType( "string" ) || o->members[ j ]->IsArrayType( "longstring" ) ){
        @CODE char arraySize[ MAX_LINE_LEN ];
        @CODE   char temp[ MAX_LINE_LEN ];
        @CODE   StringLower( temp, m->GetTypeParam( 1 ) );
        @CODE   PureString( temp, arraySize );
    for( i = 0; i < ${arraySize} ; i++ )
    {
        if(${name}[i] != NULL)
        {
            strdelete(${name}[i]);
        }
    }
    @CODE }       // end of deleting string array members
    @CODE else if( o->members[ j ]->IsType( "string" ) || o->members[ j ]->IsType( "longstring" ) ){ 
    if(${name} != NULL){
        strdelete(${name});
    }
    @CODE }       // end of deleting none array string members
    @CODE if( o->members[ j ]->IsType( "array" ) ){
    if(${name} != NULL){
        delete[] ${name};
    }
    @CODE }
@CODE }
}

${o->name}::${o->name}(tlReadChunk16* ch)
{
    assert(ch->GetID() == ${o->GetProperty("chunk_id")});
    ident = ${o->GetProperty("chunk_id")};

    tlFile* f = ch->GetFile();
@CODE   needi = false;
@CODE   bool needbuf = false;
@CODE   for( j = 0; j < o->MembersCount( ); ++j ){
@CODE       if( o->members[ j ]->IsType( "array" ) )
@CODE           needi = true;
@CODE       if( o->members[ j ]->IsType( "string" ) || o->members[ j ]->IsArrayType( "string" ))
@CODE           needbuf = true;
@CODE   }
@CODE   if( needi ){
    unsigned int i;
@CODE   }
@CODE   if( needbuf ){
    char buf[P3DMAXNAME];
@CODE   }

@CODE   for( j = 0; j < o->MembersCount( ); ++j ){
@CODE       Member *m = o->members[ j ];
@CODE       char  name[ MAX_LINE_LEN ];
@CODE       memset( name, 0, MAX_LINE_LEN  );
@CODE       strcpy( name, o->members[ j ]->name );
@CODE       _strlwr( name );
@CODE       char  membertype[ MAX_LINE_LEN ];
@CODE       char  truetype[ MAX_LINE_LEN ];
@CODE       char memberget[ MAX_LINE_LEN ];
@CODE       memset( membertype, 0, MAX_LINE_LEN  );
@CODE       memset( memberget, 0, MAX_LINE_LEN  );
@CODE       GetTrueMemberType( m, truetype );
@CODE       if( !FindMemberTypeMapping( m, membertype, &typemap ) )
@CODE           strcpy( membertype, truetype );
@CODE       FindMemberTypeMapping( m, memberget, &typeget );
@CODE       if( m->IsArrayType( "string" ) ){
@CODE           char arraySize[ MAX_LINE_LEN ];
@CODE           char temp[ MAX_LINE_LEN ];
@CODE           StringLower( temp, m->GetTypeParam( 1 ) );
@CODE           PureString( temp, arraySize );
    ${name} = new ${membertype}[${arraySize}];
    for(i = 0; i < ${arraySize}; i++)
    {
        f->GetPString(buf);
        ${name}[i] = strnew(buf);
    }
@CODE       }
@CODE       else if( o->members[ j ]->IsType( "string" ) ){
    f->GetPString(buf);
    ${name} = strnew(buf);
@CODE       }
@CODE       else if( o->members[ j ]->IsType( "array" ) ){
        @CODE char arraySize[ MAX_LINE_LEN ];
        @CODE   char temp[ MAX_LINE_LEN ];
        @CODE   StringLower( temp, m->GetTypeParam( 1 ) );
        @CODE   PureString( temp, arraySize );
    ${name} = new ${membertype}[${arraySize}];
    for(i = 0; i < ${arraySize}; i++)
    {
@CODE           if ( strlen( memberget ) > 0 ){
        ${name}[i] = f->${memberget}();
@CODE           }
@CODE           else{             
        ${name}[i].Read(f);
@CODE           }                         
    }
@CODE       }       // end of array
@CODE       else{   //none array
@CODE           if (strlen( memberget ) > 0){
    ${name} = f->${memberget}();
@CODE           }
@CODE           else{
    ${name}.Read(f);
@CODE           }
@CODE       }
@CODE   }       //end of for loop for all members
    while (!ch->EndOfChunk())
    {
        AppendSubChunk(LoadSubChunk(f));
    }
    if(sortPriority == -1)
    {
        sortPriority = FindPriority(${o->GetPropertyParam( "chunk_id" )});
    }
}

void
${o->name}::Init()
{
    ident = ${o->GetPropertyParam( "chunk_id" )};
@CODE   for( j = 0; j < o->MembersCount( ); ++j ){
@CODE       char  name[ MAX_LINE_LEN ];
@CODE       memset( name, 0, MAX_LINE_LEN  );
@CODE       strcpy( name, o->members[ j ]->name );
@CODE       _strlwr( name );
@CODE       char  memberinit[ MAX_LINE_LEN ];
@CODE       memset( memberinit, 0, MAX_LINE_LEN  );
@CODE       if( o->members[ j ]->IsType( "array" ) ){
@CODE           strcpy( memberinit, "NULL" );
@CODE       }
@CODE       else if( typeinit.find( o->members[ j ]->GetTypeName( ) ) != typeinit.end( ) ){
@CODE           strcpy( memberinit, typeinit[ o->members[ j ]->GetTypeName( ) ].c_str( ) );
@CODE       }
@CODE       if( strlen( memberinit ) > 0 ){
    ${name} = ${memberinit};
@CODE       }
@CODE       else{
    ${name}.Init( );
@CODE       }
@CODE   }
               
    if(sortPriority == -1)
    {
        sortPriority = FindPriority(${o->GetPropertyParam( "chunk_id" )});
    }
}

long 
${o->name}::Size( )
{

    long s = 2*sizeof( long );

    int i;

@CODE   for( j = 0; j < o->MembersCount( ); ++j ){
@CODE       Member *m = o->members[ j ];
@CODE       char  name[ MAX_LINE_LEN ];
@CODE       memset( name, 0, MAX_LINE_LEN  );
@CODE       strcpy( name, o->members[ j ]->name );
@CODE       _strlwr( name );
@CODE       char  membertype[ MAX_LINE_LEN ];
@CODE       char memberget[ MAX_LINE_LEN ];
@CODE       memset( membertype, 0, MAX_LINE_LEN  );
@CODE       memset( memberget, 0, MAX_LINE_LEN  );
@CODE       if( typemap.find( o->members[ j ]->GetTypeName( ) ) != typemap.end( ) ){
@CODE           strcpy( membertype, typemap[ o->members[ j ]->GetTypeName( ) ].c_str( ) );
@CODE       }
@CODE       else{
@CODE           strcpy( membertype, o->members[ j ]->GetTypeName( ) );
@CODE       }
@CODE       if( typeget.find( o->members[ j ]->GetTypeName( ) ) != typeget.end( ) ){
@CODE           strcpy( membertype, typeget[ o->members[ j ]->GetTypeName( ) ].c_str( ) );
@CODE       }
@CODE       if( o->members[ j ]->IsArrayType( "string" ) ){
@CODE           char arraySize[ MAX_LINE_LEN ];
@CODE           char temp[ MAX_LINE_LEN ];
@CODE           StringLower( temp, m->GetTypeParam( 1 ) );
@CODE           PureString( temp, arraySize ); 
    for(i = 0; i < (int) ${arraySize}; i++)
    {
        s += strlen( ${name}[ i] );
    }
@CODE       }
@CODE       else if( o->members[ j ]->IsType( "string" ) ){  
    s += strlen( ${name} );
@CODE       } 
@CODE       else if( o->members[ j ]->IsType( "array" ) ){  
@CODE           char arraySize[ MAX_LINE_LEN ];
@CODE           char temp[ MAX_LINE_LEN ];
@CODE           StringLower( temp, m->GetTypeParam( 1 ) );
@CODE           PureString( temp, arraySize ); 
    for(i = 0; i < (int)${arraySize}; i++)
    {
        s += sizeof( ${name}[i ] );
    }
@CODE       }
@CODE       else{
    s += sizeof( ${name} );
@CODE       }
@CODE   }
    for( i=0; i < SubChunkCount( ); i++){
        s += GetSubChunk(i)->Size();
    }

    return s;
}

${o->name}&
${o->name}::operator=(const ${o->name}& a)
{
@CODE   if (o->HasMemberType("array")){
    unsigned int i;
@CODE   }    

    if(ident != a.ident)
    {
        assert(ident != a.ident);
        return *this;
    }

@CODE   for( j = 0; j < o->MembersCount( ); ++j ){
@CODE       Member *m = o->members[ j ];
@CODE       char  name[ MAX_LINE_LEN ];
@CODE       memset( name, 0, MAX_LINE_LEN  );
@CODE       strcpy( name, m->name );
@CODE       _strlwr( name );
@CODE       char  membertype[ MAX_LINE_LEN ];
@CODE       char  truetype[  MAX_LINE_LEN ];
@CODE       char memberinit[ MAX_LINE_LEN ];
@CODE       memset( membertype, 0, MAX_LINE_LEN  );
@CODE       memset( memberinit, 0, MAX_LINE_LEN  );
@CODE       GetTrueMemberType( m, truetype );
@CODE       bool typemapped = FindMemberTypeMapping( m, membertype, &typemap );
@CODE       if( !typemapped )
@CODE           strcpy( membertype, truetype );
@CODE       bool typeinited = FindMemberTypeMapping( m, memberinit, &typeinit );
@CODE       if( m->IsType( "array" ) )
@CODE           strcpy( memberinit, "NULL" );
@CODE       if( m->IsType( "array" ) ){
@CODE           char arraySize[ MAX_LINE_LEN ];
@CODE           char temp[ MAX_LINE_LEN ];
@CODE           StringLower( temp, m->GetTypeParam( 1 ) );
@CODE           PureString( temp, arraySize );
    if(${name})
    {
        delete ${name};
    }
    ${name} = new ${membertype}[${arraySize}];
    for( i = 0; i < ${arraySize} ; i++ )
    {
@CODE           if( m->IsArrayType("string") || m->IsArrayType("longstring") ){
        ${name}[i] = strnew(a.${name}[i]);
@CODE   }
@CODE           else{
        ${name}[i] = a.${name}[i];
@CODE           }        
    }
@CODE       }   //if array
@CODE       else{
@CODE           if( m->IsType("string") || m->IsType("longstring") ){
    ${name} = strnew(a.${name});
@CODE           }
@CODE           else{
    ${name} = a.${name};
@CODE           }        
@CODE       }
@CODE   }

    int subch;

    for(subch = 0; subch < subcount; subch++)
    {
        RemoveSubChunk(subch);
    }

    for(subch = 0; subch < a.subcount; subch++)
    {
        AppendSubChunk(a.GetSubChunk(subch)->Copy());
    }
    
    return *this;
}

bool
${o->name}::operator==(const tlDataChunk& a)
{
@CODE   if( o->HasMemberType( "array" ) ){
    unsigned int i;
@CODE   }

    const ${o->name}* aptr = dynamic_cast<const ${o->name}*>(&a);

    if(aptr == NULL)
    {
        return false;
    }

    if(ident != aptr->ident)
    {
        return false;
    }


@CODE   for( j = 0; j < o->MembersCount( ); ++j ){
@CODE       Member *m = o->members[ j ];
@CODE       char  name[ MAX_LINE_LEN ];
@CODE       memset( name, 0, MAX_LINE_LEN  );
@CODE       strcpy( name, m->name );
@CODE       _strlwr( name );
@CODE       if( m->IsType( "array" ) ){
@CODE           char arraySize[ MAX_LINE_LEN ];
@CODE           char temp[ MAX_LINE_LEN ];
@CODE           StringLower( temp, m->GetTypeParam( 1 ) );
@CODE           PureString( temp, arraySize );   
    for(i = 0; i < ${arraySize}; i++)
    {
@CODE   if( m->IsArrayType( "string" ) ){
        if(strcmp(${name}[i], aptr->${name}[i]) != 0)
@CODE   }
@CODE   else{
        if(!(${name}[i] == aptr->${name}[i]))
@CODE   }      
        {
            return false;
        }
    }
@CODE   }
@CODE   else{
    @CODE   if(m->IsType("string")){
    if(strcmp(${name}, aptr->${name}) != 0)
    @CODE   }   
    @CODE   else{
    if(!(${name} == aptr->${name}))
    @CODE   }      
    {
        return false;
    }
@CODE   }
@CODE   }

    // check the subchunks
    if(subcount != aptr->subcount)
    {
        return false;
    }

    for(int subch = 0; subch < subcount; subch++)
    {
        if(!((*GetSubChunk(subch)) == (*aptr->GetSubChunk(subch))))
        {
            return false;
        }
    }
    return true;
}

bool
${o->name}::NameCompare(const tlDataChunk& a)
{
 @CODE char name[ MAX_LINE_LEN ];
 @CODE memset( name, 0, MAX_LINE_LEN );
 @CODE for( j = 0; j < o->MembersCount( ); ++j ){
 @CODE     Member *m = o->members[ j ];
 @CODE     if( m->IsType("string") && strcmp( "Name", m->name ) == 0 ){
 @CODE       strcpy( name, m->name );
 @CODE       _strlwr( name );
 @CODE     }
 @CODE }

 @CODE if (strlen( name ) > 0){
    const ${o->name}* aptr = dynamic_cast<const ${o->name}*>(&a);

    if(aptr == NULL)
    {
        return false;
    }

    if(ident != aptr->ident)
    {
        return false;
    }

    if(strcmp(${name}, aptr->${name}) != 0)
    {
        return false;
    }
    return true;
 @CODE }else{
    // This chunk has no name, so we must compare the bits
    return operator==(a);
 @CODE }
}


tlDataChunk*
${o->name}::Create(tlReadChunk16* ch)
{
    tlDataChunk* dtCh = new ${o->name}(ch);
    return dtCh;
}

void
${o->name}::Write(tlFile* f)
{
    tlWriteChunk16 ch(f, ident);

@CODE   if( o->HasMemberType( "array" ) ){
    unsigned int i;
@CODE   }
@CODE   for( j = 0; j < o->MembersCount( ); ++j ){
@CODE       Member *m = o->members[ j ];
@CODE       char  name[ MAX_LINE_LEN ];
@CODE       memset( name, 0, MAX_LINE_LEN  );
@CODE       strcpy( name, m->name );
@CODE       _strlwr( name );
@CODE       char  membertype[ MAX_LINE_LEN ];
@CODE       char memberput[ MAX_LINE_LEN ];
@CODE       memset( membertype, 0, MAX_LINE_LEN  );
@CODE       memset( memberput, 0, MAX_LINE_LEN  );
@CODE       char  truetype[  MAX_LINE_LEN ];
@CODE       GetTrueMemberType( m, truetype );
@CODE       bool typemapped = FindMemberTypeMapping( m, membertype, &typemap );
@CODE       bool typeputted = FindMemberTypeMapping( m, memberput, &typeput );
@CODE       if( m->IsType( "array" ) ){
    @CODE  char arraySize[ MAX_LINE_LEN ];
    @CODE   char temp[ MAX_LINE_LEN ];
    @CODE   StringLower( temp, m->GetTypeParam( 1 ) );
    @CODE   PureString( temp, arraySize );
    for(i = 0; i < ${arraySize} ; i++)
    {
@CODE           if (typeputted){
        f->${memberput}(${name}[i]);
@CODE           }
@CODE           else{                                 
        ${name}[i].Write(f);
@CODE           }                
    }
@CODE       }  
@CODE       else{
@CODE           if (typeputted){
        f->${memberput}(${name});
@CODE           }
@CODE           else{                                 
        ${name}.Write(f);
@CODE           }                
@CODE       }
@CODE   }

    ch.ContentFinish();
    for(int subch = 0; subch < subcount; subch++)
    {
        GetSubChunk(subch)->Write(f);
    }
}

void
${o->name}::Print(int indent, unsigned int printdepth, unsigned int typemask)
{
@CODE   if( o->HasMemberType( "array" ) ){
    unsigned int i;
@CODE   }

    if ( printdepth == 0 )
    {
        return;
    }

    printf("%*s${o->name} (%4x)\n",indent,"",(int) ident);
@CODE   int longest = o->MaxMemberNameLength( );
@CODE   for( j = 0; j < o->MembersCount( ); ++j ){
@CODE       Member *m = o->members[ j ];
@CODE       char prstr[ MAX_LINE_LEN ];
@CODE       memset( prstr, 0, MAX_LINE_LEN );
@CODE       strcpy( prstr, "%d" );
@CODE       bool typeprinted = FindMemberTypeMapping( m, prstr, &typeprint );
@CODE       char name[ MAX_LINE_LEN ];
@CODE       memset( name, 0, MAX_LINE_LEN );
@CODE       char lowname[ MAX_LINE_LEN ];
@CODE       memset( lowname, 0, MAX_LINE_LEN );
@CODE       strcpy( lowname, m->name );
@CODE       _strlwr( lowname );
@CODE       AlignString( m->name, longest, 1, name );
@CODE       if( m->IsType( "array" ) ){
    @CODE  char arraySize[ MAX_LINE_LEN ];
    @CODE   char temp[ MAX_LINE_LEN ];
    @CODE   StringLower( temp, m->GetTypeParam( 1 ) );
    @CODE   PureString( temp, arraySize );
    printf("%*s  ${m->name}:\n",indent,"");
    for( i=0; i < ${arraySize}; i++)
    {
@CODE           if (typeprinted){
         printf("%*s    %d ${prstr}\n",indent,"",i,${lowname}[i]);
@CODE           }
@CODE           else{
         ${lowname}[i].Print(i, indent + 4);
@CODE           }                  
    }
@CODE       }
@CODE       else{
@CODE           if (typeprinted){
    printf("%*s  ${name} = ${prstr}\n",indent,"",${lowname});
@CODE           }
@CODE           else{
    printf("%*s  ${name}:\n",indent,"");
    ${lowname}.Print(0, indent+4);
@CODE           }
@CODE       }
@CODE   }

    if(subcount)
    {
        printf("%*s  SubChunks (%d):\n",indent,"",subcount);
        for(int subch = 0; subch < subcount; subch++)
        {
            GetSubChunk(subch)->Print(indent+4, printdepth-1, typemask);
        }
    }
}

void
${o->name}::PrintFormatted(int indent)
{
    @CODE if( o->HasMemberType( "array" ) ){
    unsigned int i;
    @CODE }
    printf("%*schunk 0x%04x  \n",indent,"",(int) ident);
    @CODE for( j = 0; j < o->MembersCount( ); ++j ){
        @CODE Member *m = o->members[ j ];
        @CODE char prstr[ MAX_LINE_LEN ];
        @CODE char prkey[ MAX_LINE_LEN ];
        @CODE memset( prstr, 0, MAX_LINE_LEN );
        @CODE memset( prkey, 0, MAX_LINE_LEN );
        @CODE strcpy( prstr, "%d" );
        @CODE bool typelongprinted = FindMemberTypeMapping( m, prstr,  &typeprintlong );
        @CODE bool typekeyworded = FindMemberTypeMapping( m, prkey, &typekeyword );
        @CODE char name[ MAX_LINE_LEN ];
        @CODE char lowname[ MAX_LINE_LEN ];
        @CODE memset( name, 0, MAX_LINE_LEN );
        @CODE memset( lowname, 0, MAX_LINE_LEN );
        @CODE strcpy( lowname, m->name );
        @CODE AlignString( m->name, longest, 1, name );
        @CODE _strlwr( lowname );
        @CODE if( m->IsType( "array" ) ){
            @CODE   char arraySize[ MAX_LINE_LEN ];
            @CODE   char temp[ MAX_LINE_LEN ];
            @CODE   StringLower( temp, m->GetTypeParam( 1 ) );
            @CODE   PureString( temp, arraySize );
            @CODE   if( typelongprinted ){
    printf("%*s  repeat 1 ${prkey} # ${name}\n",indent,"");
            @CODE   }
            @CODE   else{   
    printf("%*s  # ${name}\n",indent,""); 
            @CODE   }
    for( i=0; i < ${arraySize}; i++)
    {
            @CODE if (typelongprinted){
         printf("%*s    ${prstr}\n",indent,"",${lowname}[i]);
            @CODE }
            @CODE else{
         ${lowname}[i].PrintFormatted(i,indent+4);
            @CODE }        
    }
            @CODE if (typelongprinted){
    printf("%*s  endrepeat\n",indent,"");
            @CODE }
        @CODE }
        @CODE else{       //non array
            @CODE if (typelongprinted){
    printf("%*s  ${prkey} ${prstr} # ${name}\n",indent,"",${lowname});
            @CODE }
            @CODE else{
    printf("%*s  # ${name}:\n",indent,"");
    ${lowname}.PrintFormatted(0, indent+4);
            @CODE }
        @CODE }       
    @CODE }
    if(subcount)
    {
        for(int i=0;i<subcount;i++)
        {
            GetSubChunk(i)->PrintFormatted(indent+2);
        }
    }
    printf("%*sendchunk\n",indent,"");
}

const char* 
${o->name}::GetType() const
{
    return "${o->name}";
}

int 
${o->name}::GetFieldCount() const
{
@CODE char countstr[ MAX_LINE_LEN ];
@CODE memset( countstr, 0, MAX_LINE_LEN );
@CODE sprintf( countstr, "%d", o->MembersCount( ) );
    return ${countstr};
}

bool 
${o->name}::GetFieldIsArray(int fieldIndex) const
{
@CODE int attr_array_count = 0;
@CODE int attr_total_count = o->MembersCount( );
@CODE for( j = 0; j < o->MembersCount( ); ++j ){
@CODE   if( o->members[ j ]->IsType( "array" ) )
@CODE       ++attr_array_count;
@CODE }

@CODE if (attr_array_count > 0)
@CODE {
    switch(fieldIndex)
    {
    @CODE int attr_count = 0;    
    @CODE for( j = 0; j < o->MembersCount( ); ++j ){
    @CODE   char tmpstr[ MAX_LINE_LEN ];
    @CODE   memset( tmpstr, 0, MAX_LINE_LEN );
    @CODE   sprintf( tmpstr, "%d", attr_count );
        case ${tmpstr}:
        @CODE if (o->members[ j ]->IsType( "array" ) )
        @CODE {
            return true;
        @CODE }
        @CODE else
        @CODE {
            return false;
        @CODE }

        @CODE attr_count++;
    @CODE }
        default:
            return false;
    }
@CODE }
@CODE else
@CODE {
    return false;
@CODE }
}

int 
${o->name}::GetFieldArrayCount(int fieldIndex) const
{
@CODE if (attr_array_count > 0)
@CODE {
    switch(fieldIndex)
    {
    @CODE int attr_count = 0;
    @CODE for( j = 0; j < o->MembersCount( ); ++j ){
        @CODE   char tmpstr[ MAX_LINE_LEN ];
        @CODE   memset( tmpstr, 0, MAX_LINE_LEN );
        @CODE   sprintf( tmpstr, "%d", attr_count );
        @CODE if (o->members[ j ]->IsType( "array" ) )
        @CODE {        
        case ${tmpstr}:
            @CODE char lowname[ MAX_LINE_LEN ]; 
            @CODE   char temp[ MAX_LINE_LEN ];
            @CODE   StringLower( temp, o->members[ j ]->GetTypeParam( 1 ) );
            @CODE   PureString( temp, lowname );                       
            return ${lowname};

        @CODE }
        @CODE attr_count++;
    @CODE }
        default:
            return 0;
    }
@CODE }
@CODE else
@CODE {
    return 0;
@CODE }
}

const char* 
${o->name}::GetFieldType(int fieldIndex) const
{
@CODE if (attr_total_count > 0)
@CODE {
    switch(fieldIndex)
    {
    @CODE int attr_count = 0;
    @CODE for( j = 0; j < o->MembersCount( ); ++j ){
        @CODE   Member *m = o->members[ j ];
        @CODE   char tmpstr[ MAX_LINE_LEN ];
        @CODE   memset( tmpstr, 0, MAX_LINE_LEN );
        @CODE   sprintf( tmpstr, "%d", attr_count );
        case ${tmpstr}:
        @CODE   if( m->IsType( "array" ) ){
            return "${m->GetTypeParam( 0 )}";
        @CODE   }
        @CODE   else{
            return "${m->GetTypeName( )}";
        @CODE   }

        @CODE attr_count++;
    @CODE }
        default:
            return 0;
    }
@CODE }
@CODE else
@CODE {
    return 0;
@CODE }
}

const char* 
${o->name}::GetFieldName(int fieldIndex) const
{
@CODE if (attr_total_count > 0)
@CODE {
    switch(fieldIndex)
    {
    @CODE int attr_count = 0;
    @CODE for( j = 0; j < o->MembersCount( ); ++j ){
        @CODE   Member *m = o->members[ j ];
        @CODE   char tmpstr[ MAX_LINE_LEN ];
        @CODE   memset( tmpstr, 0, MAX_LINE_LEN );
        @CODE   sprintf( tmpstr, "%d", attr_count );
        case ${tmpstr}:
            return "${m->name}";

        @CODE attr_count++;
    @CODE }
        default:
            return 0;
    }
@CODE }
@CODE else
@CODE {
    return 0;
@CODE }
}

bool 
${o->name}::GetFieldValue(int fieldIndex, char* val, int len) const
{
@CODE if(attr_total_count > 0)
@CODE {
    @CODE bool need_buf = false;
    @CODE for( j = 0; j < o->MembersCount( ); ++j ){
        @CODE Member *m = o->members[ j ];
        @CODE if (!m->IsType("array")){
            @CODE char tmp[ MAX_LINE_LEN ];
            @CODE if ( FindMemberTypeMapping( m, tmp, &type_field_value) ){
                @CODE need_buf = true;            
            @CODE }
        @CODE }
    @CODE }
    @CODE if (need_buf)
    @CODE {
    char buf[65536];

    @CODE }
    switch(fieldIndex)
    {
    @CODE int attr_count = 0;
    @CODE for( j = 0; j < o->MembersCount( ); ++j ){
        @CODE   Member *m = o->members[ j ];
        @CODE   char tmpstr[ MAX_LINE_LEN ];
        @CODE   memset( tmpstr, 0, MAX_LINE_LEN );
        @CODE   sprintf( tmpstr, "%d", attr_count );
        case ${tmpstr}:
        @CODE   if ( m->IsType( "array" ) )
            return false;
        @CODE   else{
            @CODE char prstr[ MAX_LINE_LEN ];
            @CODE memset( prstr, 0, MAX_LINE_LEN );
            @CODE char name[ MAX_LINE_LEN ];
            @CODE memset( name, 0, MAX_LINE_LEN );
            @CODE strcpy( prstr, "%d" );
            @CODE bool mapped = FindMemberTypeMapping( m, prstr, &type_field_value );
            @CODE strcpy( name, m->name );
            @CODE _strlwr( name );                        
            @CODE if ( mapped){
                @CODE if (m->IsType("FOURCC")){
            sprintf(buf, "%s", tlFourCC(${name}).AsChar());
                @CODE }
                @CODE else{
            sprintf(buf, "${prstr}", ${name});
                @CODE }
            strncpy(val, buf, len);
            return true;
            @CODE }
            @CODE else{
            return ${name}.GetFieldValue(val, len);
            @CODE }
        @CODE   }

        @CODE attr_count++;
    @CODE }
        default:
            return false;
    }
@CODE }
@CODE else
@CODE {
    return false;
@CODE }
}

bool 
${o->name}::GetFieldArrayValue(int fieldIndex, int arrayIndex, char *val, int len) const
{
@CODE if(attr_array_count > 0)
@CODE {
    @CODE bool need_buf = false;
    @CODE for( j = 0; j < o->MembersCount( ); ++j){
        @CODE Member *m = o->members[ j ];
        @CODE char buffer[ MAX_LINE_LEN ];
        @CODE if ( m->IsType( "array" ) ){
            @CODE if( FindMemberTypeMapping( m, buffer, &type_field_value ) ){            
                @CODE need_buf = true;
            @CODE }
        @CODE }
    @CODE }
    @CODE if (need_buf)
    @CODE {
    char buf[65536];

    @CODE }
    switch(fieldIndex)
    {
    @CODE int attr_count = 0;
    @CODE for( j = 0; j < o->MembersCount( ); ++j){
        @CODE Member *m = o->members[ j ];
        @CODE   char tmpstr[ MAX_LINE_LEN ];
        @CODE   memset( tmpstr, 0, MAX_LINE_LEN );
        @CODE   sprintf( tmpstr, "%d", attr_count );
        case ${tmpstr}:        
            @CODE if ( m->IsType( "array" ) ){
                @CODE char prstr[ MAX_LINE_LEN ];
                @CODE memset( prstr, 0, MAX_LINE_LEN );
                @CODE char name[ MAX_LINE_LEN ];
                @CODE memset( name, 0, MAX_LINE_LEN );
                @CODE strcpy( prstr, "%d" );
                @CODE bool mapped = FindMemberTypeMapping( m, prstr, &type_field_value );
                @CODE strcpy( name, m->name );
                @CODE _strlwr( name );


                @CODE if(mapped){
            sprintf(buf, "${prstr}", ${name}[arrayIndex]);
            strncpy(val, buf, len);
            return true;
                @CODE }
                @CODE else{
            return ${name}[arrayIndex].GetFieldValue(val, len);
                @CODE }
            @CODE }
            @CODE else{
            return false;
            @CODE }

        @CODE attr_count++;
    @CODE }
        default:
            return false;
    }
@CODE }
@CODE else
@CODE {
    return false;
@CODE }
}

bool 
${o->name}::GetFieldUpdatable(int fieldIndex) const
{
@CODE if(attr_total_count > 0)
@CODE {
    @CODE int attr_count = 0;
    switch(fieldIndex)
    {
    @CODE for( j = 0; j < o->MembersCount( ); ++j){
        @CODE Member *m = o->members[ j ];
        @CODE   char tmpstr[ MAX_LINE_LEN ];
        @CODE   memset( tmpstr, 0, MAX_LINE_LEN );
        @CODE   sprintf( tmpstr, "%d", attr_count );
        case ${tmpstr}:     
        @CODE if( m->IsType("string") )
            return true;
        @CODE else{
            @CODE if( m->IsType("float") )
            return true;
            @CODE else{
              @CODE if(m->IsType("longstring") )
            return false;
              @CODE else{
                 @CODE char buffer[ MAX_LINE_LEN ];
                 @CODE GetTrueMemberType( m, buffer );
                 @CODE if ( FindMemberTypeMapping( m, buffer, &type_field_value ) )
                 @CODE {
            return true;
                 @CODE }
                 @CODE else
                 @CODE {
                     @CODE const char *scope_op = "::";
                     @CODE if ( FindMemberTypeMapping( m, buffer,  &typemap ) )
                     @CODE {
            return ${typemap[buffer].c_str( )}${scope_op}GetFieldUpdatable();
                     @CODE }
                     @CODE else
                     @CODE {
            return ${buffer}${scope_op}GetFieldUpdatable();
                     @CODE }
                 @CODE }
             @CODE }
          @CODE }
        @CODE }

        @CODE attr_count++;
    @CODE }
        default:
            return false;
    }
@CODE }
@CODE else
@CODE {
    return false;
@CODE }
}

bool 
${o->name}::SetFieldValue(int fieldIndex, const char* new_val)
{
@CODE if(attr_total_count > 0)
@CODE {
    switch(fieldIndex)
    {
    @CODE int attr_count = 0;
    @CODE for( j = 0; j < o->MembersCount( ); ++j ){
        @CODE   Member *m = o->members[ j ];
        @CODE   char tmpstr[ MAX_LINE_LEN ];
        @CODE   memset( tmpstr, 0, MAX_LINE_LEN );
        @CODE   sprintf( tmpstr, "%d", attr_count );
        case ${tmpstr}:
        @CODE if ( m->IsType( "array" ) )
            return false;
        @CODE else{            
            @CODE char name[ MAX_LINE_LEN ];
            @CODE memset( name, 0, MAX_LINE_LEN );            
            @CODE strcpy( name, m->name );
            @CODE _strlwr( name );
            @CODE if( m->IsType( "string" ) || m->IsType( "longstring") ){
            strdelete(${name});
            ${name} = strnew(new_val);
            return true;
            @CODE }
            @CODE else{
                @CODE if(m->IsType("float")){
        {
            char* end_ptr;
            ${typemap[m->GetTypeName( )].c_str( )} tmp;
            tmp = (${typemap[m->GetTypeName( )].c_str( )})strtod(new_val, &end_ptr);
            if (*end_ptr == 0)
            {
                ${name} = tmp;
                return true;
            }
            return false;
        }
                @CODE }
                @CODE else{
                  @CODE if( m->IsType("FOURCC") ){
        {
            ${name} = (${typemap[m->GetTypeName( )].c_str( )}) tlFourCC(new_val);
            return true;
        }
                  @CODE }
                  @CODE else{
                      @CODE if( m->IsType( "WORD") ){
        {
            char* end_ptr;
            ${typemap[m->GetTypeName( )].c_str( )} tmp;
            tmp = (${typemap[m->GetTypeName( )].c_str( )})strtol(new_val, &end_ptr, 0);
            if (*end_ptr == 0)
            {
                ${name} = tmp;
                return true;
            }
            return false;
        }
                      @CODE }
                      @CODE else{
                          @CODE if ( FindMemberTypeMapping( m, buffer, &type_field_value ) )
                          @CODE {
        {
            char* end_ptr;
            ${typemap[m->GetTypeName( )].c_str( )} tmp;
            tmp = (${typemap[m->GetTypeName( )].c_str( )})strtoul(new_val, &end_ptr, 0);
            if (*end_ptr == 0)
            {
                ${name} = tmp;
                return true;
            }
            return false;
        }
                          @CODE }
                          @CODE else
                          @CODE {
            return ${name}.SetFieldValue(new_val);
                          @CODE }
                      @CODE }
                  @CODE }
              @CODE }
          @CODE }
        @CODE }
        @CODE attr_count++;
    @CODE }
        default:
            return false;
    }
@CODE }
@CODE else
@CODE {
    return false;
@CODE }
}

bool 
${o->name}::SetFieldArrayValue(int fieldIndex, int arrayIndex, const char* new_val)
{
@CODE if (attr_array_count > 0)
@CODE {
    switch(fieldIndex)
    {
    @CODE int attr_count = 0;
    @CODE for( j = 0; j < o->MembersCount( ); ++j ){
        @CODE   Member *m = o->members[ j ];
        @CODE   char tmpstr[ MAX_LINE_LEN ];
        @CODE   memset( tmpstr, 0, MAX_LINE_LEN );
        @CODE   sprintf( tmpstr, "%d", attr_count );
        case ${tmpstr}:
        @CODE if (m->IsType("array")){
           @CODE char name[ MAX_LINE_LEN ];
            @CODE memset( name, 0, MAX_LINE_LEN );            
            @CODE strcpy( name, m->name );
            @CODE _strlwr( name );
            @CODE char truetype[ MAX_LINE_LEN ];
            @CODE GetTrueMemberType( m, truetype );
            @CODE if(m->IsArrayType("string") || m->IsArrayType( "longstring")){
            if (${name}[arrayIndex]) strdelete(${name}[arrayIndex]);
            ${name}[arrayIndex] = strnew(new_val);
            return true;
            @CODE }
            @CODE else{
                @CODE if(m->IsArrayType("float")){
        {
            char* end_ptr;
            ${typemap[truetype].c_str( )} tmp;
            tmp = (${typemap[truetype].c_str( )})strtod(new_val, &end_ptr);
            if (*end_ptr == 0)
            {
                ${name}[arrayIndex] = tmp;
                return true;
            }
            return false;
        }
                @CODE }
                @CODE else{
                    @CODE if(m->IsArrayType("ULONG") || m->IsArrayType("COLOUR") || m->IsArrayType("FOURCC") ){
        {
            char* end_ptr;
            ${typemap[truetype].c_str( )} tmp;
            tmp = (${typemap[truetype].c_str( )})strtoul(new_val, &end_ptr, 0);
            if (*end_ptr == 0)
            {
                ${name}[arrayIndex] = tmp;
                return true;
            }
            return false;
        }
                    @CODE }
                    @CODE else{
                        @CODE char buffer[ MAX_LINE_LEN ];
                        @CODE if ( FindMemberTypeMapping( m, buffer, &type_field_value ) )
                        @CODE {
        {
            char* end_ptr;
            ${typemap[truetype].c_str( )} tmp;
            tmp = (${typemap[truetype].c_str( )})strtol(new_val, &end_ptr, 0);
            if (*end_ptr == 0)
            {
                ${name}[arrayIndex] = tmp;
                return true;
            }
            return false;
        }
                        @CODE }
                        @CODE else
                        @CODE {
            return ${name}[arrayIndex].SetFieldValue(new_val);
                        @CODE }
                    @CODE }
                @CODE }
            @CODE }
        @CODE }
        @CODE else{
            return false;
        @CODE }

        @CODE attr_count++;
    @CODE }
        default:
            return false;
    }
@CODE }
@CODE else
@CODE {
    return false;
@CODE }
}

tlDataChunk*
${o->name}::Copy()
{
    return new ${o->name}(*this);
}

tlDataChunk*
${o->name}::LoadSubChunk(tlFile* f)
{
    tlDataChunk *dch;
    tlReadChunk16  ch(f);
    ch.ReadNext();
    unsigned int id = ch.GetID();
 
    @CODE if ( o->HasProperty( "subchunk" ) ){
    switch(id)
    {
    @CODE for( j = 0; j < o->PropertiesCount( ); ++j ){ 
        @CODE Property *p = o->properties[ j ];
        @CODE if( !p->IsType( "subchunk" ) )
        @CODE   continue;
        @CODE char subchunkid[ MAX_LINE_LEN ];
        @CODE memset( subchunkid, 0, MAX_LINE_LEN ); 
        @CODE if( included_subchunk_id.find( p->GetParam( 0 ) )!= included_subchunk_id.end( ) ){
            @CODE strcpy( subchunkid, included_subchunk_id[ p->GetParam( 0 ) ].c_str( ) );
        @CODE }
        @CODE else{
            @CODE strcpy( subchunkid, AST->GetObjectProperty( "chunk", p->GetParam( 0 ), "chunk_id" ) );
        @CODE }
    case ${subchunkid}:
        dch = new ${p->GetParam( 0 )}(&ch);
        break;
    @CODE }
    default:
        dch = new tlDataChunk(id);
        int size = ch.GetDataSize();
        char* buf = new char[size];
        f->GetBytes(buf, size);
        dch->SetData(buf, size);
        delete buf;
    }
    @CODE }
    @CODE else{
    dch = new tlDataChunk(id);
    int size = ch.GetDataSize();
    char* buf = new char[size];
    f->GetBytes(buf, size);
    dch->SetData(buf, size);
    delete buf;
    @CODE }
    ch.Skip();
    return dch;
}

// Accessor Methods for ${o->name}
@CODE for( j = 0; j < o->MembersCount( ); ++j ){
    @CODE Member *m = o->members[ j ];
    @CODE char attr[ MAX_LINE_LEN ], type[ MAX_LINE_LEN ], name[ MAX_LINE_LEN ], basetype[ MAX_LINE_LEN ], tmp[ MAX_LINE_LEN ];    
    @CODE memset( attr, 0, MAX_LINE_LEN );
    @CODE memset( type, 0, MAX_LINE_LEN );
    @CODE memset( name, 0, MAX_LINE_LEN );
    @CODE memset( basetype, 0, MAX_LINE_LEN );
    @CODE memset( tmp, 0, MAX_LINE_LEN );    
    @CODE GetTrueMemberType( m, type );
    @CODE bool typemapped = FindMemberTypeMapping( m, type, &typemap );
    @CODE strcpy( basetype, type );
    @CODE if( m->IsType( "string" ) || m->IsType( "longstring" ) || AST->HasProperty( "class", type ) ){
        @CODE  strcpy( tmp, "const " );
        @CODE  strcat( tmp, type );
        @CODE  strcpy( type, tmp );
    @CODE }    
    @CODE if( m->IsType( "array" ) ){
        @CODE strcat( type, "*" );
    @CODE }    
    @CODE if( (!m->IsType( "array" )) && AST->HasProperty( "class", basetype ) ){
        @CODE strcat( type, "&" );
    @CODE }
    @CODE strcpy( name, m->name );
    @CODE _strlwr( name );

${type} 
${o->name}::${m->name}()
{
    return ${name};
}

@CODE if ( m->IsType("array") ){
void 
${o->name}::Set${m->name}(${type} val, int count)
{
    if(${name})
    {
        delete[] ${name};
    }      
    ${basetype}* newval = new ${basetype}[count];
    for(int i = 0; i < count ; i++)
    {
        @CODE if ( m->IsArrayType("string") || m->IsArrayType("longstring")){
        newval[i] = strnew(val[i]);
        @CODE }
        @CODE else{
        newval[i] = val[i];
        @CODE }
    }
    ${name} = newval;
}
@CODE }
@CODE else{
void 
${o->name}::Set${m->name}(${type} val)
{
    @CODE if ( m->IsType("string") || m->IsType("longstring")){
    strdelete(${name});
    ${name} = strnew(val);
    @CODE }
    @CODE else{
    ${name} = val;
    @CODE }
}
@CODE }
@CODE }
@CODE } // chunk_list
@CODE // delete sytax tree
@CODE if( AST )
    @CODE delete AST;
