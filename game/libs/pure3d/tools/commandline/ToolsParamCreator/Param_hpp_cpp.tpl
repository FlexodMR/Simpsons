@CODE   std::map<string, string> typemap;
@CODE   std::map<string, string> defaultmap;
@CODE   std::map<string, string> getmap;
@CODE   std::map<string, string> symbolmap;
@CODE   std::map<string, string> printfmap;
@CODE   std::map<string, string> longopt;
@CODE char year[ MAX_LINE_LEN ] = "";
@CODE GetYear( year );
@CODE const char * toolname = GetToolObjectName( AST );
@CODE const char * description = AST->GetObjectProperty( "tool", NULL, "description" );
@CODE char pureDescription[ MAX_LINE_LEN ];
@CODE PureString( description, pureDescription );
@CODE char wrappeddescription[ MAX_LINE_LEN ];
@CODE strcpy( wrappeddescription, "   " );
@CODE strcat( wrappeddescription, pureDescription );
@CODE typemap[ "string" ] = "char*";
@CODE typemap[ "BOOL" ]  = "int";
@CODE typemap[ "Pattern" ] = "tlStringTable";
@CODE typemap[ "IntList" ] = "tlTable<int>";
@CODE typemap[ "HexList" ] = "tlTable<int>";
@CODE typemap[ "hexint" ]  = "int";
@CODE            
@CODE defaultmap[ "string" ] = "NULL";
@CODE defaultmap[ "BOOL" ] = "FALSE";
@CODE defaultmap[ "double" ] = "0.0";
@CODE defaultmap[ "float" ] = "0.0f";
@CODE defaultmap[ "int" ]   = "0";
@CODE defaultmap[ "hexint" ] = "0";
@CODE              
@CODE getmap[ "string" ] = "strnew";
@CODE getmap[ "double"  ] = "(double)atof";
@CODE getmap[ "float"   ] = "(float)atof";
@CODE getmap[ "int"     ] = "atoi";
@CODE getmap[ "hexint"  ] = "htoi";
@CODE        
@CODE symbolmap[ "string" ] = "$"; 
@CODE symbolmap[ "BOOL"   ] = "$";
@CODE symbolmap[ "Pattern" ] = "@";
@CODE symbolmap[ "IntList" ] = "@";
@CODE symbolmap[ "HexList" ] = "@";
@CODE symbolmap[ "hexint"  ] = "$";
@CODE         
@CODE printfmap[ "string" ] = "\"%s\""; 
@CODE printfmap[ "BOOL"   ] = "%d";
@CODE printfmap[ "double" ] = "%lf";
@CODE printfmap[ "float"  ] = "%f";
@CODE printfmap[ "int"    ] = "%d";
@CODE printfmap[ "hexint" ] = "0x%x";
@CODE            
@CODE bool needshex = ( AST->HasProperty( "type", "HexList" ) || AST->HasProperty( "type", "hexint" ) );
@CODE int i;
@CODE //create param.hpp file
@CODE printf( "Generating Param.hpp\n" );
@CODE OpenOutputFile( "Param.hpp" );
/*===========================================================================
    Automatically generated by Jeeves, don't edit.  Edit ${toolname}.sc instead

    File: Param.hpp 

    Command line parameters for ${toolname}

    ${wrappeddescription}

    Copyright (c) ${year} Radical Entertainment, Inc.  All rights reserved.

===========================================================================*/

#ifndef _PARAM_HPP
#define _PARAM_HPP

#include "tlTable.hpp"
#include "tlStringTable.hpp"

class tFile;
class tlDataChunk;

class Parameters
{

public:
    tlStringTable Files;

    Parameters(int argc, char* argv[]);
    ~Parameters();

    void          ShortUsage();                  //: Print a short usage message
    void          Usage();                       //: Print a usage message
    void          VersionHistory(int count = 1); //: Print version history
    tlDataChunk*  HistoryChunk();                //: Return a File History chunk

    // Tool specific parameters

@CODE // compute longest parameter type name
@CODE int longesttype = 4;
@CODE int longestparam = 1;
@CODE for( i = 0; i < AST->ObjectsCount( ); ++i ){
    @CODE Object *o = AST->objects[ i ];
    @CODE if( !o->IsType( "parameter" ) )
            @CODE continue;
    @CODE if( o->HasProperty( "type", "none" ) )
        @CODE   continue;
    @CODE char paramtype[ MAX_LINE_LEN ];
    @CODE strcpy( paramtype, o->GetProperty( "type" ) );
    @CODE if( typemap.find( o->GetProperty( "type" ) ) != typemap.end( ) ){
        @CODE strcpy( paramtype, typemap[ o->GetProperty( "type" ) ].c_str( ) );
    @CODE }
    @CODE longesttype = max( longesttype, strlen(paramtype) );
    @CODE longestparam = max( longestparam, strlen( o->name ) );
@CODE }
@CODE for( i = 0; i < AST->ObjectsCount( ); ++i ){
    @CODE Object *o = AST->objects[ i ];
    @CODE if( !o->IsType( "parameter" ) )
            @CODE continue;
    @CODE if( o->HasProperty( "type", "none" ) )
        @CODE   continue;
    @CODE char paramtype[ MAX_LINE_LEN ];
    @CODE strcpy( paramtype, o->GetProperty( "type" ) );
    @CODE if( typemap.find( o->GetProperty( "type" ) ) != typemap.end( ) ){
        @CODE strcpy( paramtype, typemap[ o->GetProperty( "type" ) ].c_str( ) );
    @CODE }
    @CODE char alignedtype[ MAX_LINE_LEN ];
    @CODE AlignString( paramtype, longesttype, 1, alignedtype );    
    @CODE char name[MAX_LINE_LEN];
    @CODE strcpy( name,  o->name );    
    @CODE if ( o->HasProperty("description") ){
      @CODE char alignedname[ MAX_LINE_LEN ];
      @CODE AlignString( name, longestparam + 1, 1, alignedname );
      @CODE strcpy( name, alignedname );      
      @CODE char lead[ MAX_LINE_LEN ] = "   ";
      @CODE strcat( lead, alignedtype );
      @CODE strcat( lead, " " );
      @CODE strcat( lead, name );
      @CODE strcat( lead, ";//: " );
      @CODE char alignment[ MAX_LINE_LEN ];
      @CODE memset( alignment, 0, MAX_LINE_LEN );
      @CODE memset( alignment, ' ', longesttype + longestparam + 5 );
      @CODE strcat( alignment, "//  " );
      @CODE char puredesc[ MAX_LINE_LEN ];
      @CODE PureString( o->GetProperty( "description" ), puredesc );
      @CODE char desc[ MAX_LINE_LEN ];
      @CODE Wrap( lead, alignment, "", puredesc, desc, 80);      
${desc}
    @CODE }
    @CODE else{
    ${alignedtype} ${name};
    @CODE }
@CODE }

    // Standard parameters implemented by all tools

    int         Verbosity;                    //: How much noise should this program make?
    int         WriteHistory;                 //: Should the tool write a history chunk?

private:

   void filebuildup(char* filename);

   bool     isPattern;
   bool     Recurse;
   char* FilePattern;

    int      Argc;
    char**   Argv;
};

extern Parameters* Param;

#endif
@CODE CloseOutputFile( );
@CODE //create param.cpp file
@CODE printf( "Generating Param.cpp\n" );
@CODE OpenOutputFile( "Param.cpp" );
/*===========================================================================
    Automatically generated by Jeeves, don't edit.  Edit ${toolname}.sc instead

    File: Param.cpp 

    Command line parameters for ${toolname}

${wrappeddescription}

    Copyright (c) ${year} Radical Entertainment, Inc.  All rights reserved.

===========================================================================*/

#include "Param.hpp"
#include "toollib.hpp"
#include "version.hpp"

#include <constants\version.hpp>

#include <stdlib.h>
#include <stdio.h>
#include <string.h>
#include <getopt.h>
#include <time.h>
@CODE if (needshex){
#include <ctype.h>
@CODE }

#ifdef P3DWIN95  
    #define WIN32_LEAN_AND_MEAN
    #define WIN32_EXTRA_LEAN
    #include <windows.h>
    #include <io.h>
#else
    #include <unistd.h>
#endif

@CODE if (needshex){
static int htoi ( const char* str );

@CODE }
Parameters::~Parameters()
{
@CODE for( i = 0; i < AST->ObjectsCount( ); ++i ){
    @CODE Object *o = AST->objects[ i ];
    @CODE if( !o->IsType( "parameter" ) )
            @CODE continue;
    @CODE if( o->HasProperty( "type", "string" ) ){
    strdelete( ${o->name} );
    @CODE }
@CODE }
}

@CODE // compute longest parameter type name
@CODE longesttype = 4;
@CODE longestparam = 1;
@CODE for( i = 0; i < AST->ObjectsCount( ); ++i ){
    @CODE Object *o = AST->objects[ i ];
    @CODE if( !o->IsType( "parameter" ) )
            @CODE continue;
    @CODE if( o->HasProperty( "type", "Pattern" ) || strstr( o->GetProperty( "type" ), "List" ) )
    @CODE   continue;
    @CODE int len = strlen( o->name );
    @CODE longestparam = max( longestparam, len  );
    @CODE if( typemap.find( o->GetProperty( "type" ) ) != typemap.end( ) ){
        @CODE len = strlen( typemap[ o->GetProperty( "type" ) ].c_str( ) );
    @CODE }
    @CODE else{
        @CODE len = strlen( o->GetProperty( "type" ) );
    @CODE }
    @CODE longestparam = max( longestparam, len );
@CODE }
@CODE // find out which constructors to call
Parameters::Parameters(int argc, char* argv[]) :
@CODE for( i = 0; i < AST->ObjectsCount( ); ++i ){
    @CODE Object *o = AST->objects[ i ];
    @CODE if( !o->IsType( "parameter" ) )
            @CODE continue;
    @CODE if( o->HasProperty( "type", "Pattern" ) ){
    ${o->name}( ),
    @CODE }
@CODE }
    Files( )
{
    Argc = argc;
    Argv = argv;
    WriteHistory = TRUE;

    Recurse = false;
    isPattern = false;

    Verbosity = 0;
    int Hist = 0;

    @CODE for( i = 0; i < AST->ObjectsCount( ); ++i ){
        @CODE Object *o = AST->objects[ i ];
        @CODE if( !o->IsType( "parameter" ) )
            @CODE continue;
        @CODE if( o->HasProperty( "type", "Pattern" ) || o->HasProperty( "type", "none" ) || strstr( o->GetProperty( "type" ), "List" ) )
            @CODE   continue;
        @CODE char defaultName[ MAX_LINE_LEN ] = "";
        @CODE FindMapping( defaultName, o->GetProperty( "type" ), &defaultmap );        
        @CODE o->GetProperty( "default", defaultName );        
        @CODE char name[ MAX_LINE_LEN ];
        @CODE AlignString( o->name, longestparam, 1, name );        
        ${name} = ${defaultName};
    @CODE }

    char ch;
    @CODE // compute getopt string
    @CODE char getopt[ MAX_LINE_LEN ] = "?hHvVRP:n";   // standard params
    @CODE for( i = 0; i < AST->ObjectsCount( ); ++i ){
        @CODE Object *o = AST->objects[ i ];
        @CODE if( !o->IsType( "parameter" ) )
            @CODE continue;
        @CODE if( o->HasProperty( "type", "BOOL" ) ){
            @CODE if( o->HasProperty( "short" ) )
                @CODE strcat( getopt, o->GetProperty( "short" ) );
        @CODE }
        @CODE else{ // not bool type parameter
            @CODE if( o->HasProperty( "short" ) ){
                @CODE strcat( getopt, o->GetProperty( "short" ) );
                @CODE strcat( getopt, ":" );
            @CODE }
        @CODE } 
    @CODE }
    
    @CODE int longopt_count = 0;
    @CODE char longopt_idx[ MAX_LINE_LEN ];
    @CODE for( i = 0; i < AST->ObjectsCount( ); ++i ){
        @CODE Object *o = AST->objects[ i ];
        @CODE if( !o->IsType( "parameter" ) )
            @CODE continue;
        @CODE if( o->HasProperty( "long" ) ){
            @CODE sprintf( longopt_idx, "%d", longopt_count++ );
            @CODE longopt[ o->name ] = longopt_idx;
        @CODE }
    @CODE }
    @CODE sprintf( longopt_idx, "%d", longopt_count++ );
    @CODE longopt["help"] = longopt_idx;
    int option_index = 0;
    static struct option long_options[] = {
    @CODE for( i = 0; i < AST->ObjectsCount( ); ++i ){
        @CODE Object *o = AST->objects[ i ];
        @CODE if( !o->IsType( "parameter" ) )
            @CODE continue;
        @CODE char argument[MAX_LINE_LEN] = "";
        @CODE if( o->HasProperty( "long" ) ){
            @CODE if( o->HasProperty( "type", "BOOL" ) )
                @CODE strcpy( argument, "no_argument" );
            @CODE else
                @CODE strcpy( argument, "required_argument" );
        @CODE }
        @CODE if( strlen( argument ) > 0 ){
      {${o->GetProperty("long")},${argument},NULL,0},
        @CODE }
    @CODE }
      {"help",no_argument,NULL,0},
      {0,0,0,0}
    };
    while ((ch = getopt_long(argc, argv, "${getopt}",long_options,&option_index)) != EOF)
    {
        switch(ch)
        {
            // Handle the long arguments first
            case 0:
            switch(option_index)
            {
                @CODE for( i = 0; i < AST->ObjectsCount( ); ++i ){
                    @CODE char longOption[ MAX_LINE_LEN ];
                    @CODE Object *o = AST->objects[ i ]; 
                    @CODE if( !o->IsType( "parameter" ) )
                        @CODE continue;                                      
                    @CODE if( !o->HasProperty( "long" ) )
                        @CODE continue;
                    @CODE PureString( o->GetProperty( "long" ), longOption );
                case ${longopt[o->name].c_str( )}:   // ${longOption}
                @CODE if ( o->HasProperty( "type", "BOOL") ){
                    @CODE if ( o->HasProperty( "process" ) ){
            ${ o->GetProperty( "process" ) }
                    @CODE }
                    @CODE else{
                    ${o->name} = TRUE;
                    @CODE }
                @CODE }
                @CODE if ( o->HasProperty( "type","Pattern") ){
                   @CODE if ( o->HasProperty( "process" ) ){
            ${ o->GetProperty( "process" ) }
                    @CODE }
                    @CODE else{
                    ${o->name}.Append(optarg);
                    @CODE }
                @CODE }
              @CODE if ( o->HasProperty( "type","IntList") ){
                   @CODE if ( o->HasProperty( "process" ) ){
            ${ o->GetProperty( "process" ) }
                    @CODE }
                    @CODE else{
                {
                    int val = atoi(optarg);
                    ${o->name}.Append(val);
                }
                    @CODE }
              @CODE }
              @CODE if ( o->HasProperty( "type","HexList") ){
                   @CODE if ( o->HasProperty( "process" ) ){
            ${ o->GetProperty( "process" ) }
                    @CODE }
                    @CODE else{
                {
                    int hexval = htoi(optarg);
                    ${o->name}.Append(hexval);
                }
                    @CODE }
                @CODE }
                @CODE if (getmap.find( o->GetProperty( "type" ) ) != getmap.end( )){
                    @CODE char getarg[ MAX_LINE_LEN ] = "atoi";
                    @CODE FindMapping( getarg, o->GetProperty( "type" ), &getmap );
                    @CODE o->GetProperty( "getarg", getarg );
                    @CODE if ( o->HasProperty( "process" ) ){
                ${ o->GetProperty( "process" ) }
                    @CODE }
                    @CODE else{
                        ${o->name} = ${getarg}(optarg);
                    @CODE }
                @CODE }
                @CODE if (o->HasProperty( "type","none") && o->HasProperty("process")){
                ${ o->GetProperty( "process" ) }
                @CODE }
                    break;
                @CODE }
                case ${longopt["help"].c_str( )}:   // help
                    Usage();
                    break;
                default:
                    printf("ERROR! Bad index from getopt_long!\\n");
                    exit(-1);
            }
            break;
            
            // Now the short arguments
            @CODE for( i = 0; i < AST->ObjectsCount( ); ++i ){
                @CODE Object *o = AST->objects[ i ];
                @CODE if( !o->IsType( "parameter" ) )
                    @CODE continue;
                @CODE if( o->HasProperty( "type", "BOOL" ) ){            
                    @CODE if ( o->HasProperty( "short") ){
            case '${o->GetProperty("short")}':
                        @CODE if (o->HasProperty("process")){
        ${ o->GetProperty( "process" ) }
                        @CODE }
                        @CODE else{
                ${o->name} = TRUE;
                        @CODE }
                break;
                    @CODE }
                @CODE }
                @CODE else if( o->HasProperty( "type", "Pattern" ) ){                                           
                    @CODE if ( o->HasProperty( "short") ){
            case '${o->GetProperty("short")}':
                        @CODE if (o->HasProperty("process")){
        ${ o->GetProperty( "process" ) }
                        @CODE }
                        @CODE else{
                ${o->name}.Append(optarg);
                        @CODE }
                break;
                    @CODE }
                @CODE }
                @CODE else if( o->HasProperty( "type", "IntList" ) ){            
                   @CODE if ( o->HasProperty( "short") ){
            case '${o->GetProperty("short")}':
                        @CODE if (o->HasProperty("process")){
        ${ o->GetProperty( "process" ) }
                        @CODE }
                        @CODE else{
            {
                int val = atoi(optarg);
                ${o->name}.Append(val);
            }
                        @CODE }
                break;
                    @CODE }
            @CODE } else if( o->HasProperty( "type", "HexList" ) ){
                @CODE if ( o->HasProperty( "short") ){
            case '${o->GetProperty("short")}':
                    @CODE if (o->HasProperty("process")){
        ${ o->GetProperty( "process" ) }
                    @CODE }
                    @CODE else{
            {
                int hexval = htoi(optarg);
                ${o->name}.Append(hexval);
                    @CODE }
                break;
            }
                @CODE }
            @CODE }
            @CODE else if( o->HasProperty( "type", "none" ) && o->HasProperty( "process" ) ){
                @CODE if ( o->HasProperty( "short") ){
            case '${o->GetProperty("short")}':
                    @CODE if (o->HasProperty("process")){
        ${ o->GetProperty( "process" ) }
                break;
                    @CODE }
                @CODE }
            @CODE }
        @CODE }
        @CODE for( i = 0; i < AST->ObjectsCount( ); ++i ){
            @CODE Object *o = AST->objects[ i ];
            @CODE if( !o->IsType( "parameter" ) )
                @CODE continue;
            @CODE char mappedstr[ MAX_LINE_LEN ];
            @CODE memset( mappedstr, 0, MAX_LINE_LEN );
            @CODE if( !FindMapping( mappedstr, o->GetProperty( "type" ), &getmap ) )
                @CODE continue;
            @CODE if ( o->HasProperty("short")){
                @CODE char getarg[ MAX_LINE_LEN ] = "atoi";
                @CODE FindMapping( getarg, o->GetProperty( "type" ), &getmap );
                @CODE if( o->HasProperty( "getarg" ) )
                    @CODE strcpy( getarg, o->GetProperty( "getarg" ) );                                
            case '${o->GetProperty("short")}':
                @CODE if (o->HasProperty("process")){
        ${ o->GetProperty( "process" ) }
                @CODE }
                @CODE else{
                ${o->name} = ${getarg}(optarg);
                @CODE }
                break;
            @CODE }
        @CODE }
            case 'V':
                Verbosity+=100;
                break;
            case 'v':
                Verbosity++;
                break;
            case 'n':
                WriteHistory = FALSE;
                break;
            case 'H':
                Hist++;
                break;
         case 'R':
            Recurse = TRUE;
            break;
         case 'P':
            isPattern = TRUE;
            FilePattern = strnew(optarg);
            break;
            case 'h':
                Usage();
                break;
            case '?':
            default:
                ShortUsage();
                break;
        }
    }   
    if(Hist){
        VersionHistory(Hist);
    }

    for(int i=optind;i<argc;i++)
    {
#ifdef P3DWIN95

      filebuildup(argv[i]);

#else
        Files.Append(argv[i]);
#endif
    }

    if(Files.Count() ==0)
    {
        ShortUsage();
    }
}

void
Parameters::ShortUsage()
{
    printf("${toolname} version %s\n",version);
    printf("Using ATG %s Changelist %s %s\n", ATG_VERSION, compileChangelist, compileTime);
    puts( "\nCopyright Radical Entertainment ${year}\n\n"
            "   Usage: ${toolname} [options] <inputfile> [<inputfile> ...]\n\n"
@CODE Wrap("         \"","         \"","\\n\"", pureDescription, wrappeddescription, 91);

${wrappeddescription}
            "\n"
            "Try ${toolname} --help for more info.\n");
    exit(1);
}

void
Parameters::Usage()
{
    printf("${toolname} version %s\n",version);
    printf("Using ATG %s Changelist %s %s\n", ATG_VERSION, compileChangelist, compileTime);
    puts( "\nCopyright Radical Entertainment ${year}\n\n"
            "   Usage: ${toolname} [options] <inputfile> [<inputfile> ...]\n\n"
@CODE Wrap("         \"","         \"","\\n\"", pureDescription, wrappeddescription, 90);
${wrappeddescription}
            "\n"
            "Support for filename wildcards is provided.\n"
            "\n"
            "Possible options are:\n"
            @CODE int longestarg = 2;
            @CODE for( i = 0; i < AST->ObjectsCount( ); ++i ){
                @CODE Object *o = AST->objects[ i ];
                @CODE if( !o->IsType( "parameter" ) )
                    @CODE continue;
                @CODE if( !o->HasProperty( "arg" ) )
                    @CODE continue;                
                @CODE char thisarg[ MAX_LINE_LEN ] = "";
                @CODE if( o->HasProperty( "short" ) ){
                    @CODE strcat( thisarg, "-");
                    @CODE strcat( thisarg, o->GetProperty( "short" ) );
                @CODE }
                @CODE if( o->HasProperty( "long" ) && o->HasProperty( "short" ) ){
                    @CODE strcat( thisarg, ", ");                    
                @CODE }
                @CODE if( o->HasProperty( "long" ) ){
                    @CODE strcat( thisarg, "--");
                    @CODE char longOption[ MAX_LINE_LEN ];
                    @CODE PureString( o->GetProperty( "long" ), longOption );
                    @CODE strcat( thisarg, longOption );
                @CODE }
                @CODE if( o->HasProperty( "arg" ) ){ 
                    @CODE strcat( thisarg, " " );                   
                    @CODE strcat( thisarg, o->GetProperty( "arg" ) );
                @CODE }                
                @CODE longestarg = max( longestarg, strlen(thisarg));
            @CODE }
            @CODE for( i = 0; i < AST->ObjectsCount( ); ++i ){
                @CODE Object *o = AST->objects[ i ];
                @CODE if( !o->IsType( "parameter" ) )
                    @CODE continue;
                @CODE char pad[ MAX_LINE_LEN ];
                @CODE memset( pad, 0, MAX_LINE_LEN );
                @CODE memset( pad, (int)' ', longestarg );                
                @CODE char param[ MAX_LINE_LEN ] = "";
                @CODE if( o->HasProperty( "short" ) ){
                    @CODE strcat( param, "-");
                    @CODE strcat( param, o->GetProperty( "short" ) );
                @CODE }
                @CODE if( o->HasProperty( "long" ) && o->HasProperty( "short" ) ){
                    @CODE strcat( param, ", ");                    
                @CODE }
                @CODE if( o->HasProperty( "long" ) ){
                    @CODE strcat( param, "--");
                    @CODE char longOption[ MAX_LINE_LEN ];
                    @CODE PureString( o->GetProperty( "long" ), longOption );
                    @CODE strcat( param, longOption );
                @CODE }
                @CODE if( o->HasProperty( "arg" ) ){  
                    @CODE strcat( param, " " );                  
                    @CODE strcat( param, o->GetProperty( "arg" ) );
                @CODE }                
                @CODE if (strlen(param) > 0){
                    @CODE char paddedparam[ MAX_LINE_LEN ];
                    @CODE AlignString( param, longestarg, 1, paddedparam);
                    @CODE memset( wrappeddescription, 0, MAX_LINE_LEN );
                    @CODE char lead[ MAX_LINE_LEN ];
                    @CODE char align[ MAX_LINE_LEN ];
                    @CODE strcpy( lead, "         \"");
                    @CODE strcat( lead, paddedparam );
                    @CODE strcat( lead, "  " );
                    @CODE strcpy( align, "         \"");
                    @CODE strcat( align, pad );
                    @CODE strcat( align, "  " );
                    @CODE char puredescript[ MAX_LINE_LEN ];
                    @CODE PureString( o->GetProperty( "description" ), puredescript );
                    @CODE Wrap( lead, align, "\\n\"", puredescript,  wrappeddescription, 80 );                    
${wrappeddescription}
                @CODE }
            @CODE }
            "\n"
            "Standard options:\n"
            "  -v            Verbose output (more v's for more output)\n"
            "  -V            Maximum verbosity\n"
            "  -n            Suppress the P3D_HISTORY chunk\n"
            "  -H            Show version History\n"
            "  -h --help     Print this message\n"
        );
    exit(1);
}
void
Parameters::VersionHistory(int count)
{
    printf("Using ATG %s Changelist %s %s\n", ATG_VERSION, compileChangelist, compileTime);
    puts( "Copyright Radical Entertainment ${year}\n");

    for(int x=0; versioninfo[x] && (x<10*count); x++){
          printf("%s\n",versioninfo[x]);
    }
    exit(0);
}

void
Parameters::filebuildup(char* filename)
{
    // This funky code is all to handle wildcards on sub-Unix operating systems
    if(strchr(filename,'*') || strchr(filename,'?') || !strcmp(filename,".") ){
        char Path[1024];
        char Path2[1024];
        char fullPath[1024];

        strcpy(Path,filename);

        if( strrchr(Path,'\\') || strrchr(Path,'/') )
        {
            strcpy(fullPath, filename);
        }
        else
        {
            strcpy(Path,".");    
            strcpy(fullPath, Path);
        }

        if (fullPath[strlen(fullPath)-1] != '\\')
        {
            int length = strlen(fullPath);

            fullPath[length] = '\\';
            fullPath[length+1] = '\0';
        }

        strcat(fullPath, filename);

        _finddata_t fd;


        long handle = _findfirst( fullPath, &fd );

        if( handle == -1 && !Recurse ){
            printf( "%s: No Match", fullPath );
            exit( -1 );
        }

        while( handle != -1 ){
            if ( !strcmp(fd.name,".") || !strcmp(fd.name,"..") )
            {
               if(_findnext( handle, &fd ) == -1) break;
               continue;
            }

            // filename is not a directory
            if ( !(fd.attrib & 0x10) ){
               char buf[1024];

               sprintf(buf,"%s\\%s",Path,fd.name);

               char* pathname = buf;
               Files.Append(pathname);
            }

            if(_findnext( handle, &fd ) == -1) break;
        }

        // if we are doing recursion then look at the directories
        if(Recurse){
            strcpy(fullPath, Path);
            strcat(fullPath, "\\*");

            long handle = _findfirst( fullPath, &fd );

            if( handle == -1 && !Recurse )
            {
               printf( "%s: No Match", filename );
               exit( -1 );
            }

            while( handle != -1 ){
               if ( !strcmp(fd.name,".") || !strcmp(fd.name,"..") )
               {
                  if(_findnext( handle, &fd ) == -1) break;
                  continue;
               }

               // filename is actually a directory
               if ( fd.attrib & 0x10 )
               {
                  // buildup the appropriate pathname to pass into the recursive function
                  strcpy(Path2,Path);
                  strcat(Path2,"\\");
                  strcat(Path2,fd.name);
                  strcat(Path2,"\\");

                  filebuildup(Path2);
               }

               if(_findnext( handle, &fd ) == -1) break;
            }
        }
    } 
    else{
        Files.Append(filename);
    }
}

tlDataChunk*
Parameters::HistoryChunk()
{
    tlHistory history;
    char buf[512];
    sprintf(buf,"${toolname} version %s (with ATG %s)", version, ATG_VERSION);
    history.AddLine(buf);
    char* b = buf;
    int i;
    for( i = 0; i < Argc; i++)
    {
        if(b + strlen(Argv[i]) > buf + 251)       // 252 is the largest multiple of 4 less than 256
        {
            // terminate the string as a precaution
            buf[252] = 0;
            history.AddLine(buf);
            b = buf;
        }
        b += sprintf(b,"%s ",Argv[i]);
    }
    // remove the last space
    if( i > 0 )
    {
        *(b-1) = 0;
    }
    // terminate the string as a precaution
    buf[252] = 0;
    history.AddLine(buf);

    // Logon name and date info
    time_t ltime;
    struct tm *now;
    time(&ltime);
    now = localtime(&ltime);
    strftime(buf, 256, "Run at %B %d, %Y, %H:%M:%S by ", now);

#ifdef P3DWIN95
    DWORD size = 256;
    char lbuf[256];
    GetUserName(lbuf, &size);

    strcat(buf, lbuf);
#else
    char* loginname = getlogin();
    if(loginname)
    {
        strcat(buf, loginname);
    } else {
        strcat(buf, "Unknown");
    }
#endif
    history.AddLine(buf);
    
    return history.Chunk();
}
@CODE if (needshex){

// hextodec converts '0'-'F' to 0 to 16
// This is ugly code. 

static int 
hextodec ( int chr )
{
     return isdigit(chr) ? (chr - '0') : ((chr & ~('a' - 'A')) - 'A' + 10);
}

// Like atoi, but expect the input in hex,

static int 
htoi ( const char* str )
{
    int result = 0;;
    const char* s = str;

    while(*s)
    {
        result <<= 4;
        result += hextodec(*s);
        s++;
    }

    return result;
}
@CODE }
@CODE if( AST )
    @CODE delete AST;

