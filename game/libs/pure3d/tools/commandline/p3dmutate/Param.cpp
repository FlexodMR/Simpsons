/*===========================================================================
    Automatically generated by Jeeves, don't edit.  Edit p3dmutate.sc instead

    File: Param.cpp 

    Command line parameters for p3dmutate

   Provides a generic way to modify chunk fields

    Copyright (c) 2015 Radical Entertainment, Inc.  All rights reserved.

===========================================================================*/

#include "Param.hpp"
#include "toollib.hpp"
#include "version.hpp"

#include <constants\version.hpp>

#include <stdlib.h>
#include <stdio.h>
#include <string.h>
#include <getopt.h>
#include <time.h>

#ifdef P3DWIN95  
    #define WIN32_LEAN_AND_MEAN
    #define WIN32_EXTRA_LEAN
    #include <windows.h>
    #include <io.h>
#else
    #include <unistd.h>
#endif

Parameters::~Parameters()
{
    strdelete( ChunkID );
    strdelete( NewChunkID );
    strdelete( ArrayIndex );
    strdelete( NewValue );
    strdelete( OutputFile );
}

Parameters::Parameters(int argc, char* argv[]) :
    ChunkName( ),
    ParentName( ),
    TopParentName( ),
    FieldName( ),
    FieldType( ),
    CurrentValue( ),
    Files( )
{
    Argc = argc;
    Argv = argv;
    WriteHistory = TRUE;

    Recurse = false;
    isPattern = false;

    Verbosity = 0;
    int Hist = 0;

        Query             = FALSE;
        Edit              = FALSE;
        Delete            = FALSE;
        ChunkID           = NULL;
        NewChunkID        = NULL;
        ArrayIndex        = NULL;
        NewValue          = NULL;
        PrefixFileName    = FALSE;
        MaxCount          = -1;
        AppendOnly        = FALSE;
        OutputFile        = NULL;
        IgnoreFieldFilter = FALSE;

    char ch;
    
    int option_index = 0;
    static struct option long_options[] = {
      {"query",no_argument,NULL,0},
      {"edit",no_argument,NULL,0},
      {"delete",no_argument,NULL,0},
      {"chunk-id",required_argument,NULL,0},
      {"new-chunk-id",required_argument,NULL,0},
      {"chunk-name",required_argument,NULL,0},
      {"parent-name",required_argument,NULL,0},
      {"top-parent-name",required_argument,NULL,0},
      {"field-name",required_argument,NULL,0},
      {"field-type",required_argument,NULL,0},
      {"array-index",required_argument,NULL,0},
      {"current-value",required_argument,NULL,0},
      {"new-value",required_argument,NULL,0},
      {"prefix-filename",no_argument,NULL,0},
      {"max-count",required_argument,NULL,0},
      {"Append",no_argument,NULL,0},
      {"output-file",required_argument,NULL,0},
      {"ignore-field-filter",no_argument,NULL,0},
      {"help",no_argument,NULL,0},
      {0,0,0,0}
    };
    while ((ch = getopt_long(argc, argv, "?hHvVRP:nqedi:N:m:r:p:f:t:x:c:a:Fk:Ao:I",long_options,&option_index)) != EOF)
    {
        switch(ch)
        {
            // Handle the long arguments first
            case 0:
            switch(option_index)
            {
                case 0:   // query
                    Query = TRUE;
                    break;
                case 1:   // edit
                    Edit = TRUE;
                    break;
                case 2:   // delete
                    Delete = TRUE;
                    break;
                case 3:   // chunk-id
                        ChunkID = strnew(optarg);
                    break;
                case 4:   // new-chunk-id
                        NewChunkID = strnew(optarg);
                    break;
                case 5:   // chunk-name
                    ChunkName.Append(optarg);
                    break;
                case 6:   // parent-name
                    ParentName.Append(optarg);
                    break;
                case 7:   // top-parent-name
                    TopParentName.Append(optarg);
                    break;
                case 8:   // field-name
                    FieldName.Append(optarg);
                    break;
                case 9:   // field-type
                    FieldType.Append(optarg);
                    break;
                case 10:   // array-index
                        ArrayIndex = strnew(optarg);
                    break;
                case 11:   // current-value
                    CurrentValue.Append(optarg);
                    break;
                case 12:   // new-value
                        NewValue = strnew(optarg);
                    break;
                case 13:   // prefix-filename
                    PrefixFileName = TRUE;
                    break;
                case 14:   // max-count
                        MaxCount = atoi(optarg);
                    break;
                case 15:   // Append
                    AppendOnly = TRUE;
                    break;
                case 16:   // output-file
                        OutputFile = strnew(optarg);
                    break;
                case 17:   // ignore-field-filter
                    IgnoreFieldFilter = TRUE;
                    break;
                case 18:   // help
                    Usage();
                    break;
                default:
                    printf("ERROR! Bad index from getopt_long!\\n");
                    exit(-1);
            }
            break;
            
            // Now the short arguments
            case 'q':
                Query = TRUE;
                break;
            case 'e':
                Edit = TRUE;
                break;
            case 'd':
                Delete = TRUE;
                break;
            case 'm':
                ChunkName.Append(optarg);
                break;
            case 'r':
                ParentName.Append(optarg);
                break;
            case 'p':
                TopParentName.Append(optarg);
                break;
            case 'f':
                FieldName.Append(optarg);
                break;
            case 't':
                FieldType.Append(optarg);
                break;
            case 'c':
                CurrentValue.Append(optarg);
                break;
            case 'F':
                PrefixFileName = TRUE;
                break;
            case 'A':
                AppendOnly = TRUE;
                break;
            case 'I':
                IgnoreFieldFilter = TRUE;
                break;
            case 'i':
                ChunkID = strnew(optarg);
                break;
            case 'N':
                NewChunkID = strnew(optarg);
                break;
            case 'x':
                ArrayIndex = strnew(optarg);
                break;
            case 'a':
                NewValue = strnew(optarg);
                break;
            case 'k':
                MaxCount = atoi(optarg);
                break;
            case 'o':
                OutputFile = strnew(optarg);
                break;
            case 'V':
                Verbosity+=100;
                break;
            case 'v':
                Verbosity++;
                break;
            case 'n':
                WriteHistory = FALSE;
                break;
            case 'H':
                Hist++;
                break;
         case 'R':
            Recurse = TRUE;
            break;
         case 'P':
            isPattern = TRUE;
            FilePattern = strnew(optarg);
            break;
            case 'h':
                Usage();
                break;
            case '?':
            default:
                ShortUsage();
                break;
        }
    }   
    if(Hist){
        VersionHistory(Hist);
    }

    for(int i=optind;i<argc;i++)
    {
#ifdef P3DWIN95

      filebuildup(argv[i]);

#else
        Files.Append(argv[i]);
#endif
    }

    if(Files.Count() ==0)
    {
        ShortUsage();
    }
}

void
Parameters::ShortUsage()
{
    printf("p3dmutate version %s\n",version);
    printf("Using ATG %s Changelist %s %s\n", ATG_VERSION, compileChangelist, compileTime);
    puts( "\nCopyright Radical Entertainment 2015\n\n"
            "   Usage: p3dmutate [options] <inputfile> [<inputfile> ...]\n\n"

         "Provides a generic way to modify chunk fields\n"
            "\n"
            "Try p3dmutate --help for more info.\n");
    exit(1);
}

void
Parameters::Usage()
{
    printf("p3dmutate version %s\n",version);
    printf("Using ATG %s Changelist %s %s\n", ATG_VERSION, compileChangelist, compileTime);
    puts( "\nCopyright Radical Entertainment 2015\n\n"
            "   Usage: p3dmutate [options] <inputfile> [<inputfile> ...]\n\n"
         "Provides a generic way to modify chunk fields\n"
            "\n"
            "Support for filename wildcards is provided.\n"
            "\n"
            "Possible options are:\n"
         "-q, --query                  Queries field values rather than updating\n"
         "                              them\n"
         "-e, --edit                   Updates field values (default behaviour)\n"
         "-d, --delete                 Deletes chunks rather than updating them\n"
         "-i, --chunk-id List          Specify list of chunk IDs to filter (eg. \n"
         "                             0x3050-0x3058,0x305A)\n"
         "-N, --new-chunk-id List      Convert chunks specified in ChunkID to\n"
         "                              these new IDs\n"
         "-m, --chunk-name Name        Specify chunk name filter (wildcards\n"
         "                              allowed, eg. Bone*)\n"
         "-r, --parent-name Name       Specify parent chunk name filter\n"
         "                              (wildcards allowed, eg. Skel*)\n"
         "-p, --top-parent-name Name   Specify top-level parent chunk name\n"
         "                              filter (wildcards allowed)\n"
         "-f, --field-name Name        Specify chunk field name filter\n"
         "                              (wildcards allowed, eg. *Name)\n"
         "-t, --field-type Type        Specify chunk field type filter\n"
         "                              (wildcards allowed, eg. *WORD)\n"
         "-x, --array-index List       Specify list of array indices to filter\n"
         "                              (eg. 10-20,23)\n"
         "-c, --current-value Value    Modify field only if current value\n"
         "                              matches filter (wildcards allowed)\n"
         "-a, --new-value Value        Specify new value for chunk field(s)\n"
         "-F, --prefix-filename Value  Prefix new value for chunk field(s) with \n"
         "                             current filename\n"
         "-k, --max-count Value        Limit number of fields updated/queried or\n"
         "                              number of chunks deleted to Value\n"
         "-A, --Append Value           Append new value not replace with.\n"
         "-o, --output-file Name       Specify output file name\n"
         "-I, --ignore-field-filter    Continue processing even if no field name\n"
         "                              filter is specified (normally this is an\n"
         "                              error)\n"
            "\n"
            "Standard options:\n"
            "  -v            Verbose output (more v's for more output)\n"
            "  -V            Maximum verbosity\n"
            "  -n            Suppress the P3D_HISTORY chunk\n"
            "  -H            Show version History\n"
            "  -h --help     Print this message\n"
        );
    exit(1);
}
void
Parameters::VersionHistory(int count)
{
    printf("Using ATG %s Changelist %s %s\n", ATG_VERSION, compileChangelist, compileTime);
    puts( "Copyright Radical Entertainment 2015\n");

    for(int x=0; versioninfo[x] && (x<10*count); x++){
          printf("%s\n",versioninfo[x]);
    }
    exit(0);
}

void
Parameters::filebuildup(char* filename)
{
    // This funky code is all to handle wildcards on sub-Unix operating systems
    if(strchr(filename,'*') || strchr(filename,'?') || !strcmp(filename,".") ){
        char Path[1024];
        char Path2[1024];
        char fullPath[1024];

        strcpy(Path,filename);

        if( strrchr(Path,'\\') || strrchr(Path,'/') )
        {
            strcpy(fullPath, filename);
        }
        else
        {
            strcpy(Path,".");    
            strcpy(fullPath, Path);
        }

        if (fullPath[strlen(fullPath)-1] != '\\')
        {
            int length = strlen(fullPath);

            fullPath[length] = '\\';
            fullPath[length+1] = '\0';
        }

        strcat(fullPath, filename);

        _finddata_t fd;


        long handle = _findfirst( fullPath, &fd );

        if( handle == -1 && !Recurse ){
            printf( "%s: No Match", fullPath );
            exit( -1 );
        }

        while( handle != -1 ){
            if ( !strcmp(fd.name,".") || !strcmp(fd.name,"..") )
            {
               if(_findnext( handle, &fd ) == -1) break;
               continue;
            }

            // filename is not a directory
            if ( !(fd.attrib & 0x10) ){
               char buf[1024];

               sprintf(buf,"%s\\%s",Path,fd.name);

               char* pathname = buf;
               Files.Append(pathname);
            }

            if(_findnext( handle, &fd ) == -1) break;
        }

        // if we are doing recursion then look at the directories
        if(Recurse){
            strcpy(fullPath, Path);
            strcat(fullPath, "\\*");

            long handle = _findfirst( fullPath, &fd );

            if( handle == -1 && !Recurse )
            {
               printf( "%s: No Match", filename );
               exit( -1 );
            }

            while( handle != -1 ){
               if ( !strcmp(fd.name,".") || !strcmp(fd.name,"..") )
               {
                  if(_findnext( handle, &fd ) == -1) break;
                  continue;
               }

               // filename is actually a directory
               if ( fd.attrib & 0x10 )
               {
                  // buildup the appropriate pathname to pass into the recursive function
                  strcpy(Path2,Path);
                  strcat(Path2,"\\");
                  strcat(Path2,fd.name);
                  strcat(Path2,"\\");

                  filebuildup(Path2);
               }

               if(_findnext( handle, &fd ) == -1) break;
            }
        }
    } 
    else{
        Files.Append(filename);
    }
}

tlDataChunk*
Parameters::HistoryChunk()
{
    tlHistory history;
    char buf[512];
    sprintf(buf,"p3dmutate version %s (with ATG %s)", version, ATG_VERSION);
    history.AddLine(buf);
    char* b = buf;
    int i;
    for( i = 0; i < Argc; i++)
    {
        if(b + strlen(Argv[i]) > buf + 251)       // 252 is the largest multiple of 4 less than 256
        {
            // terminate the string as a precaution
            buf[252] = 0;
            history.AddLine(buf);
            b = buf;
        }
        b += sprintf(b,"%s ",Argv[i]);
    }
    // remove the last space
    if( i > 0 )
    {
        *(b-1) = 0;
    }
    // terminate the string as a precaution
    buf[252] = 0;
    history.AddLine(buf);

    // Logon name and date info
    time_t ltime;
    struct tm *now;
    time(&ltime);
    now = localtime(&ltime);
    strftime(buf, 256, "Run at %B %d, %Y, %H:%M:%S by ", now);

#ifdef P3DWIN95
    DWORD size = 256;
    char lbuf[256];
    GetUserName(lbuf, &size);

    strcat(buf, lbuf);
#else
    char* loginname = getlogin();
    if(loginname)
    {
        strcat(buf, loginname);
    } else {
        strcat(buf, "Unknown");
    }
#endif
    history.AddLine(buf);
    
    return history.Chunk();
}

