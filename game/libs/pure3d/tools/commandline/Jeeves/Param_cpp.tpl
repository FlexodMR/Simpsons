@perl use Wrap;
@perl $Wrap::columns = 80;
@perl sub max { my($a,$b) = @_; ($a>$b)?($a):($b);}
@perl sub pad { my($len,$str) = @_; sprintf("%-${len}s",$str); }
@perl ($sec,$min,$hour,$mday,$mon,$year,$wday,$yday,$isdst) = localtime(time);
@perl $year = $year+1900;
@perl $toolname = $ROOT->{toolname};
@perl $perlscript = $ROOT->{perlscript};
@perl $perlscript = 0 unless defined $perlscript;
@perl $wrappeddescription = wrap("   ","   ","\n",$description);
@perl %typemap = ( "string" => "char*", 
@perl              "BOOL"   => "int",
@perl              "Pattern" => "tlStringTable",
@perl              "IntList" => "tlTable<int>",
@perl              "HexList" => "tlTable<int>",
@perl              "hexint" => "int",
@perl            );
@perl %defaultmap = ( "string" => "NULL", 
@perl                 "BOOL"   => "FALSE",
@perl                 "double" => "0.0",
@perl                 "float"  => "0.0f",
@perl                 "int"    => "0",
@perl                 "hexint"    => "0",
@perl               );
@perl %getmap = ( "string" => "strnew", 
@perl             "double" => "(double)atof",
@perl             "float"  => "(float)atof",
@perl             "int"    => "atoi",
@perl             "hexint"    => "htoi",
@perl           );
@perl %symbolmap = ( "string" => '$', 
@perl                "BOOL"   => '$',
@perl                "Pattern" => '@',
@perl                "IntList" => '@',
@perl                "HexList" => '@',
@perl                "hexint"    => '$',
@perl            );
@perl %printfmap = ( "string" => '\"%s\"', 
@perl                "BOOL"   => '%d',
@perl                "double" => "%lf",
@perl                "float"  => "%f",
@perl                "int"    => "%d",
@perl                "hexint"    => "0x%x",
@perl            );
@perl $needshex = 0;
@foreach param_list (($param_type eq "HexList") || ($param_type eq "hexint"))
    @perl $needshex = 1;
@end
@perl print "Generating Param.cpp\n";
@openfile Param.cpp 
/*===========================================================================
    Automatically generated by Jeeves, don't edit.  Edit ${toolname}.sc instead

    File: Param.cpp 

    Command line parameters for ${toolname}

$wrappeddescription

    Copyright (c) $year Radical Entertainment, Inc.  All rights reserved.

===========================================================================*/

#include "Param.hpp"
#include "toollib.hpp"
#include "version.hpp"
@if ($perlscript)
#include "script.hpp"
@endif

#include <stdlib.h>
#include <stdio.h>
#include <string.h>
#include <getopt.h>
#include <time.h>
@if ($needshex)
#include <ctype.h>
@endif

#ifdef P3DWIN95  
    #define WIN32_LEAN_AND_MEAN
    #define WIN32_EXTRA_LEAN
    #include <windows.h>
    #include <io.h>
#else
    #include <unistd.h>
#endif

@if ($needshex)
static int htoi ( const char* str );

@endif
Parameters::~Parameters()
{
    @if ($perlscript)
    strdelete(ScriptFile);
    @endif   
    @foreach param_list ($param_type eq "string")
    strdelete($param_name);
    @end
}

@// compute longest parameter type name
@perl my $longesttype = length("void");
@perl my $longestparam = length("a");
@foreach param_list (($param_type ne "Pattern") && !($param_type =~ m/List/))
    @perl my $type = $param_type;
    @perl $type = $typemap{$param_type} if defined $typemap{$param_type}; 
    @perl $type .= "*" if $array;
    @perl $longesttype = max($longesttype, length($type));
    @perl $longestparam = max($longestparam, length($param_name));
@end
@// find out which constructors to call
@perl my @clist = ();
@foreach param_list (($param_type eq "Pattern") || ($param_type =~ m/List/))
@perl push @clist , "$param_name()";
@end
@if (@clist)
@perl my $clist = join(",\n" . " " x 49,@clist);
Parameters::Parameters(int argc, char* argv[]) : Files(),
                                                                 $clist
@else
Parameters::Parameters(int argc, char* argv[]) : Files()
@endif
{
    Argc = argc;
    Argv = argv;
    WriteHistory = TRUE;

   Recurse = false;
   isPattern = false;

    Verbosity = 0;
    int Hist = 0;
    @if ($perlscript)
    ScriptFile = NULL;
    @endif

    @foreach param_list (($param_type ne "none") && ($param_type ne "Pattern") && !($param_type =~ m/List/))
    @perl my $default = 0;
    @perl $default = $defaultmap{$param_type} if defined $defaultmap{$param_type};
    @perl $default = $param_default if defined $param_default;
    @perl $name = pad($longestparam, $param_name);
    $name = $default;
    @end

    char ch;
    @// compute getopt string
   @perl my $getopt = "?hHvVRP:n";   # standard params
    @if ($perlscript)
    @perl $getopt .= "f:";
    @endif
    @foreach param_list ($param_type eq "BOOL")
    @if (defined ($param_short))
    @perl $getopt .= $param_short;
    @endif
    @end
    @foreach param_list ($param_type ne "BOOL")
    @if (defined($param_short))
    @perl $getopt .= "$param_short:";
    @endif
    @end
    @perl my $longopt_count = 0;
    @foreach param_list ($param_long) 
    @perl $longopt{$param_name} = $longopt_count++;
    @end
    @perl $longopt{'help'} = $longopt_count++;
    @if ($perlscript)
    @perl $longopt{'scripthelp'} = $longopt_count++;
    @endif
    int option_index = 0;
    static struct option long_options[] = {
      @foreach param_list ($param_long) 
      @perl my $argument = "required_argument";
      @perl $argument = "no_argument" if $param_type eq "BOOL";
      {"$param_long",$argument,NULL,0},
      @end
      {"help",no_argument,NULL,0},
      @if ($perlscript)
      {"scripthelp",no_argument,NULL,0},
      @endif
      {0,0,0,0}
    };
    while ((ch = getopt_long(argc, argv, "$getopt",long_options,&option_index)) != EOF)
    {
        switch(ch)
        {
            // Handle the long arguments first
            case 0:
            switch(option_index)
            {
                @foreach param_list ($param_long) 
                case $longopt{$param_name}:   // $param_long
                @if ($param_type eq "BOOL")
                @if ($param_process)
            $param_process
                @else
                    $param_name = TRUE;
                @endif
                @endif
                @if ($param_type eq "Pattern")
                @if ($param_process)
            $param_process
                @else
                    $param_name.Append(optarg);
                @endif
                @endif
                @if ($param_type eq "IntList")
                @if ($param_process)
            $param_process
                @else
                {
                    int val = atoi(optarg);
                    $param_name.Append(val);
                }
                @endif
                @endif
                @if ($param_type eq "HexList")
                @if ($param_process)
            $param_process
                @else
                {
                    int hexval = htoi(optarg);
                    $param_name.Append(hexval);
                }
                @endif
                @endif
                @if ($getmap{$param_type})
                @perl my $getarg = "atoi";
                @perl $getarg = $getmap{$param_type} if defined $getmap{$param_type};
                @perl $getarg = $param_getarg if defined $param_getarg;
                @if ($param_process)
            $param_process
                @else
                    $param_name = $getarg(optarg);
                @endif
                @endif
                @if (($param_type eq "none") && $param_process)
                $param_process
                @endif
                    break;
                @end
                case $longopt{help}:   // help
                    Usage();
                    break;
                @if ($perlscript)
                case $longopt{scripthelp}:   // scripthelp
                    ScriptHelp();
                    break;
                @endif
                default:
                    printf("ERROR! Bad index from getopt_long!\\n");
                    exit(-1);
            }
            break;
            
            // Now the short arguments
            @foreach param_list ($param_type eq "BOOL")
            @if (defined ($param_short))
            case '$param_short':
            @if ($param_process)
        $param_process
            @else
                $param_name = TRUE;
            @endif
                break;
            @endif
            @end
            @foreach param_list ($param_type eq "Pattern")
            @if (defined($param_short))
            case '$param_short':
            @if ($param_process)
        $param_process
            @else
                $param_name.Append(optarg);
            @endif
                break;
            @endif
            @end
            @foreach param_list ($param_type eq "IntList")
            @if (defined($param_short))
            case '$param_short':
            @if ($param_process)
        $param_process
            @else
            {
                int val = atoi(optarg);
                $param_name.Append(val);
            }
            @endif
                break;
            @endif
            @end
            @foreach param_list ($param_type eq "HexList")
            @if (defined($param_short))
            case '$param_short':
            {
            @if ($param_process)
        $param_process
            @else
                int hexval = htoi(optarg);
                $param_name.Append(hexval);
            @endif
                break;
            }
            @endif
            @end
            @foreach param_list ($getmap{$param_type})
            @if (defined($param_short))
            @perl my $getarg = "atoi";
            @perl $getarg = $getmap{$param_type} if defined $getmap{$param_type};
            @perl $getarg = $param_getarg if defined $param_getarg;
            case '$param_short':
            @if ($param_process)
        $param_process
            @else
                $param_name = $getarg(optarg);
            @endif
                break;
            @endif
            @end
            @foreach param_list (($param_type eq "none") && $param_process)
            @if (defined($param_short))
            case '$param_short':
        $param_process
                break;
            @endif
            @end
            @if ($perlscript)
            case 'f':
                ScriptFile = strnew(optarg);
                break;
            @endif
            case 'V':
                Verbosity+=100;
                break;
            case 'v':
                Verbosity++;
                break;
            case 'n':
                WriteHistory = FALSE;
                break;
            case 'H':
                Hist++;
                break;
         case 'R':
            Recurse = TRUE;
            break;
         case 'P':
            isPattern = TRUE;
            FilePattern = strnew(optarg);
            break;
            case 'h':
                Usage();
                break;
            case '?':
            default:
                ShortUsage();
                break;
        }
    }   
    if(Hist){
        VersionHistory(Hist);
    }

    for(int i=optind;i<argc;i++)
    {
#ifdef P3DWIN95

      filebuildup(argv[i]);

#else
        Files.Append(argv[i]);
#endif
    }

@if ($perlscript)
    if(ScriptFile)
    {
        if(Verbosity>0){
            printf("Processing script file '%s'\\n", ScriptFile);
        }
        RunScript(ScriptFile);
        GetScriptParams();
    }

@endif
    if(Files.Count() ==0)
    {
        ShortUsage();
    }
}

void
Parameters::ShortUsage()
{
    printf("$toolname version %s\\n",version);
    printf("Using toollib %s %s\\n", tlversion, tlCompileInfo);
    puts( "\\nCopyright Radical Entertainment $year\\n\\n"
            "   Usage: $toolname [options] <inputfile> [<inputfile> ...]\\n\\n"
@perl $Wrap::columns = 91;
@perl $wrappeddescription = wrap('         "','         "',"\\n\"\n",$description);
@perl chomp($wrappeddescription);
$wrappeddescription
            "\\n"
            "Try $toolname --help for more info.\\n");
    exit(1);
}

void
Parameters::Usage()
{
    printf("$toolname version %s\\n",version, tlversion);
    printf("Using toollib %s %s\\n", tlversion, tlCompileInfo);
    puts( "\\nCopyright Radical Entertainment $year\\n\\n"
            "   Usage: $toolname [options] <inputfile> [<inputfile> ...]\\n\\n"
@perl $Wrap::columns = 90;
@perl $wrappeddescription = wrap('         "','         "',"\\n\"\n",$description);
@perl chomp($wrappeddescription);
$wrappeddescription
            "\\n"
            "Support for filename wildcards is provided.\\n"
            "\\n"
            "Possible options are:\\n"
            @perl my $longestarg = length("-h");
            @foreach param_list (defined $param_arg)
                @perl $thisarg = " ";
                @perl $thisarg .= "-$param_short" if (defined ($param_short));
                @perl $thisarg .= ", " if (defined($param_short) && $param_long);
                @perl $thisarg .= "--$param_long" if ($param_long);
                @perl $thisarg .= " $param_arg" if ($param_arg);
                @perl $longestarg = max($longestarg, length($thisarg));
            @end
            @foreach param_list
            @perl $pad = " " x $longestarg;
            @perl my $param = " ";
            @perl $param .= "-$param_short" if (defined ($param_short));
            @perl $param .= ", " if (defined($param_short) && $param_long);
            @perl $param .= "--$param_long" if ($param_long);
            @perl $param .= " $param_arg" if ($param_arg);
            @if ($param)
              @perl my $paddedparam = pad($longestarg,"$param");
              @perl $wrappeddescription = wrap("         \"$paddedparam  ","         \"$pad  ","\\n\"\n",$param_description);
              @perl chomp($wrappeddescription);
$wrappeddescription
            @endif
            @end
            "\\n"
            "Standard options:\\n"
            @if ($perlscript)
            "  -f Script     Run named script file\\n"
            "  --scripthelp  Describe the variables available in the script file\\n"
            @endif
            "  -v            Verbose output (more v's for more output)\\n"
            "  -V            Maximum verbosity\\n"
            "  -n            Suppress the P3D_HISTORY chunk\\n"
            "  -H            Show version History\\n"
            "  -h --help     Print this message\\n"
        );
    exit(1);
}
@if ($perlscript)

void
Parameters::ScriptHelp()
{
    printf("$toolname version %s (using toollib %s)\\n",version, tlversion);
    puts( "Possible script options are:\\n"
            @perl my $longestname = 0;
            @foreach param_list ($param_type ne "none")
                @perl $longestname = max($longestname, length($param_name));
            @end
            @foreach param_list ($param_type ne "none")
                @perl $symbol = '$';
                @perl $symbol = $symbolmap{$param_type} if defined $symbolmap{$param_type};
                @perl $pad = " " x ($longestname - length($param_name));
                @perl $pad2 = " " x $longestname;
                @perl $wrappeddescription = wrap("         \"  $symbol$param_name $pad","         \"    $pad2","\\n\"\n",$param_description);
                @perl chomp($wrappeddescription);
$wrappeddescription
            @end
            "\\n"
            "Standard script options:\\n"
            "  \$Verbosity      Verbosity level\\n"
            "  \$WriteHistory   Write the P3D_HISTORY chunk\\n"
            "  \@Files          The input file list\\n"
        );
    exit(1);
}

void
Parameters::DumpScriptParams()
{
    printf("# Perl Script Params\\n");
    printf("# $toolname version %s (using toollib %s)\\n\\n",version, tlversion);
    @foreach param_list ($param_type ne "none")
    @perl $default = $defaultmap{$param_type} if defined $defaultmap{$param_type};
    @perl $default = $param_default if defined $param_default;
    @if (($param_type eq "Pattern") || ($param_type =~ m/List/))
    if($param_name.Count())
    {
        printf("\@$param_name = (");
        for( int i = 0; i < $param_name.Count() ; i++)
        {
            @if ($param_type eq "Pattern")
            printf("\\"%s\\", ", ${param_name}[i]);
            @endif
            @if ($param_type eq "HexList")
            printf("0x%X, ", ${param_name}[i]);
            @endif
            @if ($param_type eq "IntList")
            printf("%d, ", ${param_name}[i]);
            @endif
        }
        printf(");\\n");
    }
    @else
    @perl $printf = "%d";
    @perl $printf = $printfmap{$param_type} if defined $printfmap{$param_type};
    if($param_name != $default)
    {
        printf("\$$param_name = $printf;\\n",$param_name);
    }
    @endif
    @end
    if(Verbosity != 0)
    {
        printf("\$Verbosity = %d;\\n",Verbosity);
    }
    if(WriteHistory != 1)
    {
        printf("\$WriteHistory = %d;\\n",WriteHistory);
    }
    if(Files.Count())
    {
        printf("\@Files = (");
        for( int i = 0; i < Files.Count() ; i++)
        {
            printf("\\"%s\\", ", Files[i]);
        }
        printf(");\\n");
    }
    printf("# End of Script\\n");
}
@endif

void
Parameters::VersionHistory(int count)
{
    printf("$toolname version %s (with toollib %s)\\n\\n", version, tlversion);
    puts( "Copyright Radical Entertainment $year\\n");

    for(int x=0; versioninfo[x] && (x<10*count); x++){
          printf("%s\\n",versioninfo[x]);
    }
    exit(0);
}

void
Parameters::filebuildup(char* filename)
{
      // This funky code is all to handle wildcards on sub-Unix operating systems
      if(strchr(filename,'*') || strchr(filename,'?') || !strcmp(filename,".") || Recurse || isPattern)
      {
         char Path[1024];
         char Path2[1024];
         char fullPath[1024];

         strcpy(Path,filename);

         if( strrchr(Path,'\\\\') || strrchr(Path,'/') )
         {
            strcpy(fullPath, filename);

            if (!isPattern)
            {
               int length = strlen(fullPath);

               if (fullPath[strlen(fullPath)-1] != '\\\\')
               {
                  fullPath[length] = '\\\\';
               }

               fullPath[length+1] = '*';
               fullPath[length+2] = '\\0';

               strcat(fullPath, FilePattern);
            }
         }
         else
         {
            strcpy(Path,".");

            if ( isPattern )
            {
                strcpy(fullPath, Path);
            }
            else
            {
                strcpy(fullPath, "*");
            }
         }

         if (isPattern)
         {
            if (fullPath[strlen(fullPath)-1] != '\\\\')
            {
               int length = strlen(fullPath);

               fullPath[length] = '\\\\';
               fullPath[length+1] = '\\0';
            }

            strcat(fullPath, FilePattern);
         }

         _finddata_t fd;


         long handle = _findfirst( fullPath, &fd );

         if( handle == -1 && !Recurse )
         {
            printf( "%s: No Match", fullPath );
            exit( -1 );
         }

         while( handle != -1 )
         {
            if ( !strcmp(fd.name,".") || !strcmp(fd.name,"..") )
            {
               if(_findnext( handle, &fd ) == -1) break;
               continue;
            }

            // filename is not a directory
            if ( !(fd.attrib & 0x10) )
            {
               char buf[1024];

               sprintf(buf,"%s\\\\%s",Path,fd.name);

               char* pathname = buf;
               Files.Append(pathname);
            }

            if(_findnext( handle, &fd ) == -1) break;
         }

         // if we are doing recursion then look at the directories
         if(Recurse)
         {
            strcpy(fullPath, Path);
            strcat(fullPath, "\\\\*");

            long handle = _findfirst( fullPath, &fd );

            if( handle == -1 && !Recurse )
            {
               printf( "%s: No Match", filename );
               exit( -1 );
            }

            while( handle != -1 )
            {
               if ( !strcmp(fd.name,".") || !strcmp(fd.name,"..") )
               {
                  if(_findnext( handle, &fd ) == -1) break;
                  continue;
               }

               // filename is actually a directory
               if ( fd.attrib & 0x10 )
               {
                  // buildup the appropriate pathname to pass into the recursive function
                  strcpy(Path2,Path);
                  strcat(Path2,"\\\\");
                  strcat(Path2,fd.name);
                  strcat(Path2,"\\\\");

                  filebuildup(Path2);
               }

               if(_findnext( handle, &fd ) == -1) break;
            }
         }

      } 
      else
      {
         Files.Append(filename);
      }
}

tlDataChunk*
Parameters::HistoryChunk()
{
    tlHistory history;
    char buf[512];
    sprintf(buf,"$toolname version %s (with toollib %s)", version, tlversion);
    history.AddLine(buf);
    char* b = buf;
    int i;
    for( i = 0; i < Argc; i++)
    {
        if(b + strlen(Argv[i]) > buf + 251)       // 252 is the largest multiple of 4 less than 256
        {
            // terminate the string as a precaution
            buf[252] = 0;
            history.AddLine(buf);
            b = buf;
        }
        b += sprintf(b,"%s ",Argv[i]);
    }
    // remove the last space
    if( i > 0 )
    {
        *(b-1) = 0;
    }
    // terminate the string as a precaution
    buf[252] = 0;
    history.AddLine(buf);

    // Logon name and date info
    time_t ltime;
    struct tm *now;
    time(&ltime);
    now = localtime(&ltime);
    strftime(buf, 256, "Run at %B %d, %Y, %H:%M:%S by ", now);

#ifdef P3DWIN95
    DWORD size = 256;
    char lbuf[256];
    GetUserName(lbuf, &size);

    strcat(buf, lbuf);
#else
    char* loginname = getlogin();
    if(loginname)
    {
        strcat(buf, loginname);
    } else {
        strcat(buf, "Unknown");
    }
#endif
    history.AddLine(buf);
    
    return history.Chunk();
}
@if ($needshex)

// hextodec converts '0'-'F' to 0 to 16
// This is ugly code. 

static int 
hextodec ( int chr )
{
     return isdigit(chr) ? (chr - '0') : ((chr & ~('a' - 'A')) - 'A' + 10);
}

// Like atoi, but expect the input in hex,

static int 
htoi ( const char* str )
{
    int result = 0;;
    const char* s = str;

    while(*s)
    {
        result <<= 4;
        result += hextodec(*s);
        s++;
    }

    return result;
}
@endif
@if ($perlscript)
#include <EXTERN.h>               /* from the Perl distribution     */
#include <perl.h>                 /* from the Perl distribution     */

void
Parameters::GetScriptParams()
{
    SV* sv;
    AV* av;

    @foreach param_list ($param_type eq 'string')
    if(sv = perl_get_sv("$param_name", FALSE))
    {
        unsigned int len;
        $param_name = strnew(SvPV(sv,len));
    }

    @end
    @foreach param_list ($param_type eq 'BOOL')
    if(sv = perl_get_sv("$param_name", FALSE))
    {
        $param_name = SvIV(sv);
    }

    @end
    @foreach param_list ($param_type eq 'Pattern')
    if(av = perl_get_av("$param_name", FALSE))
    {
        for(I32 i = 0; i <= av_len(av) ; i++)
        {
            unsigned int len;
            char* name = SvPV(*av_fetch(av, i, 0),len);
            $param_name.Append(name);
        }
    }

    @end
    @foreach param_list ($param_type eq 'IntList')
    if(av = perl_get_av("$param_name", FALSE))
    {
        for(I32 i = 0; i <= av_len(av) ; i++)
        {
            unsigned int len;
            int val = SvIV(*av_fetch(av, i, 0));
            $param_name.Append(val);
        }
    }

    @end
    @foreach param_list ($param_type eq 'HexList')
    if(av = perl_get_av("$param_name", FALSE))
    {
        for(I32 i = 0; i <= av_len(av) ; i++)
        {
            unsigned int len;
            int val = SvIV(*av_fetch(av, i, 0));
            $param_name.Append(val);
        }
    }

    @end
    @foreach param_list ($param_type eq 'double')
    if(sv = perl_get_sv("$param_name", FALSE))
    {
        $param_name = (double) SvNV(sv);
    }

    @end
    @foreach param_list ($param_type eq 'float')
    if(sv = perl_get_sv("$param_name", FALSE))
    {
        $param_name = (float) SvNV(sv);
    }

    @end
    @foreach param_list ($param_type eq 'int')
    if(sv = perl_get_sv("$param_name", FALSE))
    {
        $param_name = SvIV(sv);
    }

    @end
    if(sv = perl_get_sv("Verbosity", FALSE))
    {
        Verbosity = SvIV(sv);
    }

    if(sv = perl_get_sv("WriteHistory", FALSE))
    {
        WriteHistory = !SvIV(sv);
    }

    if(av = perl_get_av("Files", FALSE))
    {
        for(I32 i = 0; i <= av_len(av) ; i++)
        {
            unsigned int len;
            char* name = SvPV(*av_fetch(av, i, 0),len);
            Files.Append(name);
        }
    }
}
@endif

