/*===========================================================================
    Automatically generated by Jeeves, don't edit.  Edit p3dimage.sc instead

    File: Param.cpp 

    Command line parameters for p3dimage

   This tool processes textures and images in a Pure3D file

    Copyright (c) 2015 Radical Entertainment, Inc.  All rights reserved.

===========================================================================*/

#include "Param.hpp"
#include "toollib.hpp"
#include "version.hpp"

#include <constants\version.hpp>

#include <stdlib.h>
#include <stdio.h>
#include <string.h>
#include <getopt.h>
#include <time.h>

#ifdef P3DWIN95  
    #define WIN32_LEAN_AND_MEAN
    #define WIN32_EXTRA_LEAN
    #include <windows.h>
    #include <io.h>
#else
    #include <unistd.h>
#endif

Parameters::~Parameters()
{
    strdelete( OutputFile );
}

Parameters::Parameters(int argc, char* argv[]) :
    NamePatterns( ),
    ExcludeNamePatterns( ),
    Files( )
{
    Argc = argc;
    Argv = argv;
    WriteHistory = TRUE;

    Recurse = false;
    isPattern = false;

    Verbosity = 0;
    int Hist = 0;

        NotAlpha        = FALSE;
        Saturation      = 0.0f;
        NTSCFix         = FALSE;
        NewBpp          = 0;
        Brightness      = 0.0f;
        ClampNTSC       = FALSE;
        Contrast        = 0.0f;
        DiceSprite      = TRUE;
        Dither          = FALSE;
        Format          = 0;
        Filter          = 0.0f;
        GameCubeImage   = FALSE;
        GammaCorrection = 0.0f;
        ImageFile       = FALSE;
        ImageOutputFile = FALSE;
        ClampAlpha      = FALSE;
        Lightness       = 0.0f;
        MinSpriteSize   = 32;
        MaxSpriteSize   = 256;
        HighlightNTSC   = FALSE;
        OutputFile      = NULL;
        Optimize        = FALSE;
        PS2Image        = FALSE;
        QuickSave       = FALSE;
        Query           = FALSE;
        Solid           = FALSE;
        ShowSize        = FALSE;
        SpriteExport    = FALSE;
        Upgrade         = FALSE;
        Hue             = 0.0f;
        XBoxImage       = FALSE;
        MaxImageSize2x2 = 256;
        DXT1Only        = FALSE;

    char ch;
    
    int option_index = 0;
    static struct option long_options[] = {
      {"saturation",required_argument,NULL,0},
      {"ntsc_fix",no_argument,NULL,0},
      {"bpp",required_argument,NULL,0},
      {"brightness",required_argument,NULL,0},
      {"clamp-ntsc",no_argument,NULL,0},
      {"contrast",required_argument,NULL,0},
      {"dice-sprite",no_argument,NULL,0},
      {"dither",no_argument,NULL,0},
      {"dxtn-format",required_argument,NULL,0},
      {"filter",required_argument,NULL,0},
      {"gamecube-image",no_argument,NULL,0},
      {"gamma",required_argument,NULL,0},
      {"image-file",no_argument,NULL,0},
      {"image-output-file",no_argument,NULL,0},
      {"1bit-alpha",no_argument,NULL,0},
      {"lightness",required_argument,NULL,0},
      {"min-sprite-size",required_argument,NULL,0},
      {"max-sprite-size",required_argument,NULL,0},
      {"highlight-ntsc",no_argument,NULL,0},
      {"output-file",required_argument,NULL,0},
      {"optimize",no_argument,NULL,0},
      {"ps2-image",no_argument,NULL,0},
      {"quick-encode",no_argument,NULL,0},
      {"query",no_argument,NULL,0},
      {"reduce-solid",no_argument,NULL,0},
      {"show-size",no_argument,NULL,0},
      {"sprite-export",no_argument,NULL,0},
      {"texture-name",required_argument,NULL,0},
      {"exclude-texture",required_argument,NULL,0},
      {"upgrade",no_argument,NULL,0},
      {"hue",required_argument,NULL,0},
      {"xbox-image",no_argument,NULL,0},
      {"max-image-size_2x2",required_argument,NULL,0},
      {"dxt1-only",no_argument,NULL,0},
      {"help",no_argument,NULL,0},
      {0,0,0,0}
    };
    while ((ch = getopt_long(argc, argv, "?hHvVRP:naA:b:B:cC:dDf:F:Gg:iIlL:m:M:No:OpqQrsSt:T:uU:xZ:1",long_options,&option_index)) != EOF)
    {
        switch(ch)
        {
            // Handle the long arguments first
            case 0:
            switch(option_index)
            {
                case 0:   // saturation
                        Saturation = (float)atof(optarg);
                    break;
                case 1:   // ntsc_fix
                    NTSCFix = TRUE;
                    break;
                case 2:   // bpp
                        NewBpp = atoi(optarg);
                    break;
                case 3:   // brightness
                        Brightness = (float)atof(optarg);
                    break;
                case 4:   // clamp-ntsc
                    ClampNTSC = TRUE;
                    break;
                case 5:   // contrast
                        Contrast = (float)atof(optarg);
                    break;
                case 6:   // dice-sprite
                    DiceSprite = TRUE;
                    break;
                case 7:   // dither
                    Dither = TRUE;
                    break;
                case 8:   // dxtn-format
                        Format = atoi(optarg);
                    break;
                case 9:   // filter
                        Filter = (float)atof(optarg);
                    break;
                case 10:   // gamecube-image
                    GameCubeImage = TRUE;
                    break;
                case 11:   // gamma
                        GammaCorrection = (float)atof(optarg);
                    break;
                case 12:   // image-file
                    ImageFile = TRUE;
                    break;
                case 13:   // image-output-file
                    ImageOutputFile = TRUE;
                    break;
                case 14:   // 1bit-alpha
                    ClampAlpha = TRUE;
                    break;
                case 15:   // lightness
                        Lightness = (float)atof(optarg);
                    break;
                case 16:   // min-sprite-size
                        MinSpriteSize = atoi(optarg);
                    break;
                case 17:   // max-sprite-size
                        MaxSpriteSize = atoi(optarg);
                    break;
                case 18:   // highlight-ntsc
                    HighlightNTSC = TRUE;
                    break;
                case 19:   // output-file
                        OutputFile = strnew(optarg);
                    break;
                case 20:   // optimize
                    Optimize = TRUE;
                    break;
                case 21:   // ps2-image
                    PS2Image = TRUE;
                    break;
                case 22:   // quick-encode
                    QuickSave = TRUE;
                    break;
                case 23:   // query
                    Query = TRUE;
                    break;
                case 24:   // reduce-solid
                    Solid = TRUE;
                    break;
                case 25:   // show-size
                    ShowSize = TRUE;
                    break;
                case 26:   // sprite-export
                    SpriteExport = TRUE;
                    break;
                case 27:   // texture-name
                    NamePatterns.Append(optarg);
                    break;
                case 28:   // exclude-texture
                    ExcludeNamePatterns.Append(optarg);
                    break;
                case 29:   // upgrade
                    Upgrade = TRUE;
                    break;
                case 30:   // hue
                        Hue = (float)atof(optarg);
                    break;
                case 31:   // xbox-image
                    XBoxImage = TRUE;
                    break;
                case 32:   // max-image-size_2x2
                        MaxImageSize2x2 = atoi(optarg);
                    break;
                case 33:   // dxt1-only
                    DXT1Only = TRUE;
                    break;
                case 34:   // help
                    Usage();
                    break;
                default:
                    printf("ERROR! Bad index from getopt_long!\\n");
                    exit(-1);
            }
            break;
            
            // Now the short arguments
            case 'a':
                NotAlpha = TRUE;
                break;
            case 'c':
                ClampNTSC = TRUE;
                break;
            case 'd':
                DiceSprite = TRUE;
                break;
            case 'D':
                Dither = TRUE;
                break;
            case 'G':
                GameCubeImage = TRUE;
                break;
            case 'i':
                ImageFile = TRUE;
                break;
            case 'I':
                ImageOutputFile = TRUE;
                break;
            case 'l':
                ClampAlpha = TRUE;
                break;
            case 'N':
                HighlightNTSC = TRUE;
                break;
            case 'O':
                Optimize = TRUE;
                break;
            case 'p':
                PS2Image = TRUE;
                break;
            case 'q':
                QuickSave = TRUE;
                break;
            case 'Q':
                Query = TRUE;
                break;
            case 'r':
                Solid = TRUE;
                break;
            case 's':
                ShowSize = TRUE;
                break;
            case 'S':
                SpriteExport = TRUE;
                break;
            case 't':
                NamePatterns.Append(optarg);
                break;
            case 'T':
                ExcludeNamePatterns.Append(optarg);
                break;
            case 'u':
                Upgrade = TRUE;
                break;
            case 'x':
                XBoxImage = TRUE;
                break;
            case '1':
                DXT1Only = TRUE;
                break;
            case 'A':
                Saturation = (float)atof(optarg);
                break;
            case 'b':
                NewBpp = atoi(optarg);
                break;
            case 'B':
                Brightness = (float)atof(optarg);
                break;
            case 'C':
                Contrast = (float)atof(optarg);
                break;
            case 'f':
                Format = atoi(optarg);
                break;
            case 'F':
                Filter = (float)atof(optarg);
                break;
            case 'g':
                GammaCorrection = (float)atof(optarg);
                break;
            case 'L':
                Lightness = (float)atof(optarg);
                break;
            case 'm':
                MinSpriteSize = atoi(optarg);
                break;
            case 'M':
                MaxSpriteSize = atoi(optarg);
                break;
            case 'o':
                OutputFile = strnew(optarg);
                break;
            case 'U':
                Hue = (float)atof(optarg);
                break;
            case 'Z':
                MaxImageSize2x2 = atoi(optarg);
                break;
            case 'V':
                Verbosity+=100;
                break;
            case 'v':
                Verbosity++;
                break;
            case 'n':
                WriteHistory = FALSE;
                break;
            case 'H':
                Hist++;
                break;
         case 'R':
            Recurse = TRUE;
            break;
         case 'P':
            isPattern = TRUE;
            FilePattern = strnew(optarg);
            break;
            case 'h':
                Usage();
                break;
            case '?':
            default:
                ShortUsage();
                break;
        }
    }   
    if(Hist){
        VersionHistory(Hist);
    }

    for(int i=optind;i<argc;i++)
    {
#ifdef P3DWIN95

      filebuildup(argv[i]);

#else
        Files.Append(argv[i]);
#endif
    }

    if(Files.Count() ==0)
    {
        ShortUsage();
    }
}

void
Parameters::ShortUsage()
{
    printf("p3dimage version %s\n",version);
    printf("Using ATG %s Changelist %s %s\n", ATG_VERSION, compileChangelist, compileTime);
    puts( "\nCopyright Radical Entertainment 2015\n\n"
            "   Usage: p3dimage [options] <inputfile> [<inputfile> ...]\n\n"

         "This tool processes textures and images in a Pure3D file\n"
            "\n"
            "Try p3dimage --help for more info.\n");
    exit(1);
}

void
Parameters::Usage()
{
    printf("p3dimage version %s\n",version);
    printf("Using ATG %s Changelist %s %s\n", ATG_VERSION, compileChangelist, compileTime);
    puts( "\nCopyright Radical Entertainment 2015\n\n"
            "   Usage: p3dimage [options] <inputfile> [<inputfile> ...]\n\n"
         "This tool processes textures and images in a Pure3D file\n"
            "\n"
            "Support for filename wildcards is provided.\n"
            "\n"
            "Possible options are:\n"
         "-a                             Don't modify images with alpha\n"
         "-A, --saturation Value         Increase (pos. value) or decrease (neg.\n"
         "                                value) the image saturation.\n"
         "--ntsc_fix                     Desaturate an image to avoid illegal\n"
         "                                NTSC colours, in apposed to clamping\n"
         "                                the colours.\n"
         "-b, --bpp Value                Force output images bits-per-pixel to\n"
         "                                Value\n"
         "-B, --brightness Value         Increase (pos. value) or decrease (neg.\n"
         "                                value) the image brightness.\n"
         "-c, --clamp-ntsc               Correct all illegal NTSC colours\n"
         "-C, --contrast Value           Increase (pos. value) or decrease (neg.\n"
         "                                value) the image contrast.\n"
         "-d, --dice-sprite              Cut the sprite into sections which are \n"
         "                               powers of two sized (on by default)\n"
         "-D, --dither                   With -b, dither an image when reducing \n"
         "                               the bit depth\n"
         "-f, --dxtn-format dxtn         Specify converted dxtn format(1, 3, 5, \n"
         "                               or 9 for Auto-detect)\n"
         "-F, --filter radius            Blur pixels within radius using\n"
         "                                Gaussian blur filter\n"
         "-G, --gamecube-image           Format images optimized for the\n"
         "                                GameCube; Also turns on DXT1Only\n"
         "-g, --gamma Value              Gamma correct images by Value\n"
         "-i, --image-file               Deprecated. Input files are image\n"
         "                                files, and not P3D files. Deprecated\n"
         "                                option - file detection is automatic.\n"
         "-I, --image-output-file        Write the output as an image.  The\n"
         "                                input file which must be an image is\n"
         "                                overwritten with the results.\n"
         "-l, --1bit-alpha               Clamps all of the alpha values in the\n"
         "                                image to 1 bit values\n"
         "-L, --lightness Value          Increase (pos. value) or decrease (neg.\n"
         "                                value) the image lightness.\n"
         "-m, --min-sprite-size          Specifies the minimum size a sprite\n"
         "                                chunk can be\n"
         "-M, --max-sprite-size          Specifies the maximum size a sprite\n"
         "                                chunk can be\n"
         "-N, --highlight-ntsc           Turn all illegal NTSC colours Hot Pink\n"
         "-o, --output-file name         Specify output file name\n"
         "-O, --optimize                 Reduce the bit depth of images if they \n"
         "                               use few enough colours\n"
         "-p, --ps2-image                Deprecated\n"
         "-q, --quick-encode             Quick encode with poor image quality;\n"
         "                                for debugging only\n"
         "-Q, --query                    Query image information.\n"
         "-r, --reduce-solid             Reduce the size and bit depth of solid \n"
         "                               colour images\n"
         "-s, --show-size                Print memory size statistics for each\n"
         "                                texture\n"
         "-S, --sprite-export            Export as Sprites instead of textures\n"
         "-t, --texture-name Pattern     Only process textures whose names match\n"
         "                                Pattern (eg. Brick*)\n"
         "-T, --exclude-texture Pattern  Do not process textures whose names\n"
         "                                match Pattern (eg. Brick*)\n"
         "-u, --upgrade                  With -b, convert to higher bit depths\n"
         "                                (eg. 4 bit to 8 bit)\n"
         "-U, --hue Value                Increase (pos. value) or decrease (neg.\n"
         "                                value) the image hue.\n"
         "-x, --xbox-image               Format images optimized for the X-Box\n"
         "-Z, --max-image-size_2x2       Specifies the maximum size a texture\n"
         "                                chunk can be where the hiehgt == width\n"
         "-1, --dxt1-only                Only convert to DXT1, if the image\n"
         "                                needs DXT3/5, leave it alone\n"
            "\n"
            "Standard options:\n"
            "  -v            Verbose output (more v's for more output)\n"
            "  -V            Maximum verbosity\n"
            "  -n            Suppress the P3D_HISTORY chunk\n"
            "  -H            Show version History\n"
            "  -h --help     Print this message\n"
        );
    exit(1);
}
void
Parameters::VersionHistory(int count)
{
    printf("Using ATG %s Changelist %s %s\n", ATG_VERSION, compileChangelist, compileTime);
    puts( "Copyright Radical Entertainment 2015\n");

    for(int x=0; versioninfo[x] && (x<10*count); x++){
          printf("%s\n",versioninfo[x]);
    }
    exit(0);
}

void
Parameters::filebuildup(char* filename)
{
    // This funky code is all to handle wildcards on sub-Unix operating systems
    if(strchr(filename,'*') || strchr(filename,'?') || !strcmp(filename,".") ){
        char Path[1024];
        char Path2[1024];
        char fullPath[1024];

        strcpy(Path,filename);

        if( strrchr(Path,'\\') || strrchr(Path,'/') )
        {
            strcpy(fullPath, filename);
        }
        else
        {
            strcpy(Path,".");    
            strcpy(fullPath, Path);
        }

        if (fullPath[strlen(fullPath)-1] != '\\')
        {
            int length = strlen(fullPath);

            fullPath[length] = '\\';
            fullPath[length+1] = '\0';
        }

        strcat(fullPath, filename);

        _finddata_t fd;


        long handle = _findfirst( fullPath, &fd );

        if( handle == -1 && !Recurse ){
            printf( "%s: No Match", fullPath );
            exit( -1 );
        }

        while( handle != -1 ){
            if ( !strcmp(fd.name,".") || !strcmp(fd.name,"..") )
            {
               if(_findnext( handle, &fd ) == -1) break;
               continue;
            }

            // filename is not a directory
            if ( !(fd.attrib & 0x10) ){
               char buf[1024];

               sprintf(buf,"%s\\%s",Path,fd.name);

               char* pathname = buf;
               Files.Append(pathname);
            }

            if(_findnext( handle, &fd ) == -1) break;
        }

        // if we are doing recursion then look at the directories
        if(Recurse){
            strcpy(fullPath, Path);
            strcat(fullPath, "\\*");

            long handle = _findfirst( fullPath, &fd );

            if( handle == -1 && !Recurse )
            {
               printf( "%s: No Match", filename );
               exit( -1 );
            }

            while( handle != -1 ){
               if ( !strcmp(fd.name,".") || !strcmp(fd.name,"..") )
               {
                  if(_findnext( handle, &fd ) == -1) break;
                  continue;
               }

               // filename is actually a directory
               if ( fd.attrib & 0x10 )
               {
                  // buildup the appropriate pathname to pass into the recursive function
                  strcpy(Path2,Path);
                  strcat(Path2,"\\");
                  strcat(Path2,fd.name);
                  strcat(Path2,"\\");

                  filebuildup(Path2);
               }

               if(_findnext( handle, &fd ) == -1) break;
            }
        }
    } 
    else{
        Files.Append(filename);
    }
}

tlDataChunk*
Parameters::HistoryChunk()
{
    tlHistory history;
    char buf[512];
    sprintf(buf,"p3dimage version %s (with ATG %s)", version, ATG_VERSION);
    history.AddLine(buf);
    char* b = buf;
    int i;
    for( i = 0; i < Argc; i++)
    {
        if(b + strlen(Argv[i]) > buf + 251)       // 252 is the largest multiple of 4 less than 256
        {
            // terminate the string as a precaution
            buf[252] = 0;
            history.AddLine(buf);
            b = buf;
        }
        b += sprintf(b,"%s ",Argv[i]);
    }
    // remove the last space
    if( i > 0 )
    {
        *(b-1) = 0;
    }
    // terminate the string as a precaution
    buf[252] = 0;
    history.AddLine(buf);

    // Logon name and date info
    time_t ltime;
    struct tm *now;
    time(&ltime);
    now = localtime(&ltime);
    strftime(buf, 256, "Run at %B %d, %Y, %H:%M:%S by ", now);

#ifdef P3DWIN95
    DWORD size = 256;
    char lbuf[256];
    GetUserName(lbuf, &size);

    strcat(buf, lbuf);
#else
    char* loginname = getlogin();
    if(loginname)
    {
        strcat(buf, loginname);
    } else {
        strcat(buf, "Unknown");
    }
#endif
    history.AddLine(buf);
    
    return history.Chunk();
}

