@CODE char year[ MAX_LINE_LEN ] = "";
@CODE GetYear( year );
@CODE const char * pureshadername = GetShaderObjectName( AST );
@CODE char shadername[ MAX_LINE_LEN ] = "P3D";
@CODE char description[ MAX_LINE_LEN ];
@CODE strcat( shadername, pureshadername );
@CODE char filename[ MAX_LINE_LEN ] = "p3d" ;
@CODE char headerfilename[ MAX_LINE_LEN ] = "p3d" ;
@CODE const char * shaderid = GetShaderProperty( AST, "id" );
@CODE const char *pddiname = GetShaderProperty( AST, "pddiShaderName" );
@CODE const char * registername= GetShaderProperty( AST, "registerName" );
@CODE PureString( GetShaderProperty( AST, "description" ), description );
@CODE strcat( filename, pureshadername );
@CODE strcat( filename, ".cpp" );
@CODE strcat( headerfilename, pureshadername );
@CODE strcat( headerfilename, ".hpp" );
@CODE int i;
@CODE printf( "Generating .\\src\\%s\n", headerfilename );
@CODE OpenOutputFile( "src\\", ".hpp" );
#ifndef __${shadername}_H__
#define __${shadername}_H__

/*===========================================================================
    Automatically generated by Jeeves, don't edit.  Edit ${shadername}.sc instead

    File: ${headerfilename}

    ${description}
    
    Copyright (c) ${year} Radical Entertainment, Inc.  All rights reserved.

===========================================================================*/
#include <maya/MPxNode.h>

//
// DESCRIPTION: ${description}
///////////////////////////////////////////////////////
class ${shadername} : public MPxNode
{
public:
    ${shadername}();
    virtual           ~${shadername}();

    virtual MStatus   compute( const MPlug&, MDataBlock& );
    virtual void      postConstructor();

    static void *     creator();
    static MStatus    initialize();
    static MTypeId    id;

protected:
    // All New Added Textures Go Here:
@CODE for( i = 0; i < AST->ObjectsCount( ); ++i ){
    @CODE Object * o = AST->objects[ i ];
    @CODE if( !o->IsType( "texture" ) )
        @CODE  continue;
    @CODE  if( !o->HasProperty( "attribute" ) || o->HasProperty( "attribute", "true" ) ){
    static MObject  a${o->name};
    static MObject  a${o->name}R;
    static MObject  a${o->name}G;
    static MObject  a${o->name}B;
    @CODE }

@CODE }   
    // All New Added Colors Go Here:
@CODE for( i = 0; i < AST->ObjectsCount( ); ++i ){
    @CODE Object * o = AST->objects[ i ];
    @CODE if( !o->IsType( "color" ) )
        @CODE  continue;
    @CODE  if( !o->HasProperty( "attribute" ) || o->HasProperty( "attribute", "true" ) ){
    static MObject  a${o->name}R;
    static MObject  a${o->name}G;
    static MObject  a${o->name}B;
    static MObject  a${o->name};
    @CODE }
    @CODE if (o->HasProperty( "fourCC" )){
    static MObject  aExport${o->GetProperty( "fourCC" )};        //export
    static MObject  aExport${o->GetProperty( "fourCC" )}R;        //export red
    static MObject  aExport${o->GetProperty( "fourCC" )}G;        //export green
    static MObject  aExport${o->GetProperty( "fourCC" )}B;        //export blud
    @CODE }

@CODE }
    // All New Added enums Go Here:
@CODE for( i = 0; i < AST->ObjectsCount( ); ++i ){
    @CODE Object * o = AST->objects[ i ];
    @CODE if( !o->IsType( "enum" ) )
        @CODE  continue;
    @CODE  if( !o->HasProperty( "attribute" ) || o->HasProperty( "attribute", "true" ) ){
    static MObject  a${o->name};
    @CODE }
    @CODE if (o->HasProperty( "fourCC" )){
    static MObject  aExport${o->GetProperty( "fourCC" )};        //export
    @CODE }

@CODE }   

    // All New Added floats Go Here:
@CODE for( i = 0; i < AST->ObjectsCount( ); ++i ){
    @CODE Object * o = AST->objects[ i ];
    @CODE if( !o->IsType( "float" ) )
        @CODE  continue;
    @CODE  if( !o->HasProperty( "attribute" ) || o->HasProperty( "attribute", "true" ) ){
    static MObject  a${o->name};
    @CODE }
    @CODE if (o->HasProperty( "fourCC" )){
    static MObject  aExport${o->GetProperty( "fourCC" )};        //export
    @CODE }

@CODE }   

    // All New Added UVs Go Here:    
@CODE for( i = 0; i < AST->ObjectsCount( ); ++i ){
    @CODE Object * o = AST->objects[ i ];
    @CODE if( !o->IsType( "uv" ) )
        @CODE  continue;
    @CODE  if( !o->HasProperty( "attribute" ) || o->HasProperty( "attribute", "true" ) ){
    static MObject  aU${o->name};
    static MObject  aV${o->name};
    static MObject  aUV${o->name};
    @CODE }
    @CODE if (o->HasProperty( "fourCC" )){
    static MObject  aExportUV${o->GetProperty( "fourCC" )};        //export
    static MObject  aExportU${o->GetProperty( "fourCC" )};        //export red
    static MObject  aExportV${o->GetProperty( "fourCC" )};        //export green
    @CODE }

@CODE }
  
    // All New Added ints Go Here:
@CODE for( i = 0; i < AST->ObjectsCount( ); ++i ){
    @CODE Object * o = AST->objects[ i ];
    @CODE if( !o->IsType( "int" ) )
        @CODE  continue;
    @CODE  if( !o->HasProperty( "attribute" ) || o->HasProperty( "attribute", "true" ) ){
    static MObject  a${o->name};
    @CODE }
    @CODE if (o->HasProperty( "fourCC" )){
    static MObject  aExport${o->GetProperty( "fourCC" )};        //export
    @CODE }

@CODE }  

    // All New Added  bools Go Here:
@CODE for( i = 0; i < AST->ObjectsCount( ); ++i ){
    @CODE Object * o = AST->objects[ i ];
    @CODE if( !o->IsType( "bool" ) )
        @CODE  continue;
    @CODE  if( !o->HasProperty( "attribute" ) || o->HasProperty( "attribute", "true" ) ){
    static MObject  a${o->name};
    @CODE }
    @CODE if (o->HasProperty( "fourCC" )){
    static MObject  aExport${o->GetProperty( "fourCC" )};        //export
    @CODE }

@CODE }  

    // All New Added  StringArray Go Here:
@CODE for( i = 0; i < AST->ObjectsCount( ); ++i ){
    @CODE Object * o = AST->objects[ i ];
    @CODE if( !o->IsType( "strarray" ) )
        @CODE  continue;
    @CODE  if( !o->HasProperty( "attribute" ) || o->HasProperty( "attribute", "true" ) ){
    static MObject  a${o->name};
    @CODE }
    @CODE if (o->HasProperty( "fourCC" )){
    static MObject  aExport${o->GetProperty( "fourCC" )};        //export
    @CODE }

@CODE } 
 
    // output 
    static MObject  aOutColorR;
    static MObject  aOutColorG;
    static MObject  aOutColorB;
    static MObject  aOutColor;

    static MObject  aOutTransR;
    static MObject  aOutTransG;
    static MObject  aOutTransB;
    static MObject  aOutTrans;

    // exporter API attributes
    static MObject  aIsTranslucent;
    static MObject  aVertexNeeds;
    static MObject  aVertexMask;

    // export
    static MObject  aPDDIShaderName;
    static MObject  aVertexShaderName;
    static MObject  aExport;

    // internal attributes
    static MObject  aPointCameraX;
    static MObject  aPointCameraY;
    static MObject  aPointCameraZ;
    static MObject  aPointCamera;
    static MObject  aNormalCameraX;
    static MObject  aNormalCameraY;
    static MObject  aNormalCameraZ;
    static MObject  aNormalCamera;
    static MObject  aTriangleNormalCameraX;
    static MObject  aTriangleNormalCameraY;
    static MObject  aTriangleNormalCameraZ;
    static MObject  aTriangleNormalCamera;
    static MObject  aLightDirectionX;
    static MObject  aLightDirectionY;
    static MObject  aLightDirectionZ;
    static MObject  aLightDirection;
    static MObject  aLightIntensityR;
    static MObject  aLightIntensityG;
    static MObject  aLightIntensityB;
    static MObject  aLightIntensity;
    static MObject  aLightAmbient;
    static MObject  aLightDiffuse;
    static MObject  aLightSpecular;
    static MObject  aLightShadowFraction;
    static MObject  aPreShadowIntensity;
    static MObject  aLightBlindData;
    static MObject  aLightData;

    static MObject  aObjectId;

private:
    static void exporterAttributes();
    MStatus compute_output( const MPlug&plug, MDataBlock& block );

    static int GetIntDefault( const char* attr, int nDefault = 0 );
    static float GetFloatDefault( const char* attr, float fDefault = 0.0f );
    static void GetColorDefault( const char* attr, float *cDefault );
    static void AfterOpen( void* clientData );

    MCallbackId afterOpenCallback;
    MCallbackId afterImportCallback;
};

#endif  //__${shadername}_H__
@CODE printf( "Generating .\\src\\%s\n", filename );
@CODE OpenOutputFile( "src\\", ".cpp" );
/*===========================================================================
    Automatically generated by Jeeves, don't edit.  Edit ${shadername}.sc instead

    File: ${filename}

    ${description}
    
    Copyright (c) ${year} Radical Entertainment, Inc.  All rights reserved.

===========================================================================*/
#include <math.h>
#include <maya/MString.h>
#include <maya/MTypeId.h>
#include <maya/MPlug.h>
#include <maya/MDataBlock.h>
#include <maya/MDataHandle.h>
#include <maya/MArrayDataHandle.h>
#include <maya/MFnCompoundAttribute.h>
#include <maya/MFnEnumAttribute.h>
#include <maya/MFnTypedAttribute.h>
#include <maya/MFnStringData.h>
#include <maya/MFnStringArrayData.h>
#include <maya/MFnNumericAttribute.h>
#include <maya/MFnLightDataAttribute.h>
#include <maya/MFloatVector.h>
#include <maya/MFileIO.h>       // required to detect file I/O
#include <maya/MGlobal.h>
#include <maya/MSceneMessage.h>
#include "${headerfilename}"


MTypeId ${shadername}::id( ${shaderid} );

int ${shadername}::GetIntDefault( const char* attr, int nDefault )
{
    const char* control = "int $p3dInt; if ( `optionVar -exists %s` ) $p3dInt = `optionVar -q %s`; else $p3dInt = %d;";

    char                        mel[256];
    sprintf( mel, control, attr, attr, nDefault );

    MGlobal::executeCommand( mel, nDefault, false, false );

    return nDefault;
}

float ${shadername}::GetFloatDefault( const char* attr, float fDefault )
{
    const char* control = "float $p3dFloat; if ( `optionVar -exists %s` ) $p3dFloat = `optionVar -q %s`; else $p3dFloat = %f;";

    char                        mel[256];
    sprintf( mel, control, attr, attr, fDefault );

    double                      dblResult;
    MGlobal::executeCommand( mel, dblResult, false, false );
    fDefault = (float)dblResult;

    return fDefault;
}

void ${shadername}::GetColorDefault( const char* attr, float* cDefault )
{
    const char* control = "float $p3dFloatArray[]; if ( `optionVar -exists %s` ) $p3dFloatArray = `optionVar -q %s`; else $p3dFloatArray = { %f, %f, %f };";

    char                        mel[256];
    sprintf( mel, control, attr, attr, cDefault[0], cDefault[1], cDefault[2] );

    MDoubleArray                dblResult;
    MGlobal::executeCommand( mel, dblResult, false, false );
    if ( dblResult.length() > 2 )
    {
        cDefault[0] = (float)dblResult[0];
        cDefault[1] = (float)dblResult[1];
        cDefault[2] = (float)dblResult[2];
    }
}

void ${shadername}::AfterOpen( void* clientData )
{
    ${shadername} *shader = (${shadername} *) clientData;
    MObject thisNode = shader->thisMObject();
    int i = 1;

    @CODE for( i = 0; i < AST->ObjectsCount( ); ++i ){
        @CODE Object * o = AST->objects[ i ];
        @CODE if( !o->IsType( "code" ) )
            @CODE  continue;
       @CODE if( o->HasProperty( "hook", "afteropen" ) ){
          @CODE char source[ MAX_CODE_BUFFER ];
          @CODE PureString( o->GetProperty( "source" ), source );
          ${source}
       @CODE }
    @CODE }

    // We are done with the callback for this specific shader.
    MSceneMessage::removeCallback( shader->afterOpenCallback );
    MSceneMessage::removeCallback( shader->afterImportCallback );
}

void ${shadername}::postConstructor( )
{
    // Must first check if a file is loading..
    // Maya does not save attributes whose values remain at their default.
    // The creation of all shader nodes -- including those while loading 
    // a scene -- would adopt the user settings and only those attributes
    // saved in  the scene file would be restored.
    // Result: Artists would get VERY upset.
    // In other words, don't diddle with them if a scene is being loaded!
    if ( !MFileIO::isReadingFile() )
    {
        MPlug                       plug;
        int                         nDefault = 0;
        float                       fDefault = 0.0f;
        bool                        bDefault = false;
        float                       cDefault[3] = { 0.0, 0.0, 0.0 };
    
    @CODE for( i = 0; i < AST->ObjectsCount( ); ++i ){
        @CODE Object * o = AST->objects[ i ];
        @CODE if( !o->IsType( "int" ) )
            @CODE  continue;
        @CODE  if( !o->HasProperty( "attribute" ) || o->HasProperty( "attribute", "true" ) ){        
        // Get default from optionVar "${shadername}_${o->GetProperty("long")}"
        @CODE if ( o->HasProperty( "value" ) ){
        nDefault = GetIntDefault( "${shadername}_${o->GetProperty("long")}", ${o->GetProperty("value")});
        @CODE }
        @CODE else{
        nDefault = GetIntDefault( "${shadername}_${o->GetProperty("long")}", 0 );
        @CODE }
        plug = MPlug( thisMObject(), a${o->name} );
        plug.setValue( nDefault );
        @CODE  }
    @CODE  }

    @CODE for( i = 0; i < AST->ObjectsCount( ); ++i ){
        @CODE Object * o = AST->objects[ i ];
        @CODE if( !o->IsType( "float" ) )
            @CODE  continue;
        @CODE  if( !o->HasProperty( "attribute" ) || o->HasProperty( "attribute", "true" ) ){        
        @CODE if ( o->HasProperty( "value" ) ){
        fDefault = GetFloatDefault( "${shadername}_${o->GetProperty("long")}", ${o->GetProperty("value")});
        @CODE }
        @CODE else{
        fDefault = GetFloatDefault( "${shadername}_${o->GetProperty("long")}", 0.0f );
        @CODE }
        plug = MPlug( thisMObject(), a${o->name} );
        plug.setValue( fDefault );
        @CODE  }        
    @CODE }

    @CODE for( i = 0; i < AST->ObjectsCount( ); ++i ){
        @CODE Object * o = AST->objects[ i ];
        @CODE if( !o->IsType( "bool" ) )
            @CODE  continue;
        @CODE  if( !o->HasProperty( "attribute" ) || o->HasProperty( "attribute", "true" ) ){        
        // Get default from optionVar "${shadername}_${o->GetProperty("long")}"
        @CODE if ( o->HasProperty( "value" ) ){
            @CODE if( o->HasProperty( "value", "true" ) ){
        bDefault = GetIntDefault( "${shadername}_${o->GetProperty("long")}", 1 ) != 0;
            @CODE }
            @CODE else {
        bDefault = GetIntDefault( "${shadername}_${o->GetProperty("long")}", 0 ) != 0;
            @CODE }
        @CODE }
        @CODE else{
        bDefault = GetIntDefault( "${shadername}_${o->GetProperty("long")}", 0 ) != 0;
        @CODE }
        plug = MPlug( thisMObject(), a${o->name} );
        plug.setValue( bDefault );
        @CODE  }
    @CODE  }

    @CODE for( i = 0; i < AST->ObjectsCount( ); ++i ){
        @CODE Object * o = AST->objects[ i ];
        @CODE if( !o->IsType( "enum" ) )
            @CODE  continue;
        @CODE  if( !o->HasProperty( "attribute" ) || o->HasProperty( "attribute", "true" ) ){        
        // Get default from optionVar "${shadername}_${o->GetProperty("long")}"
        @CODE if ( o->HasProperty( "default" ) ){
        nDefault = GetIntDefault( "${shadername}_${o->GetProperty("long")}", ${o->GetProperty("default")});
        @CODE }
        @CODE else{
        nDefault = GetIntDefault( "${shadername}_${o->GetProperty("long")}", 0 );
        @CODE }
        plug = MPlug( thisMObject(), a${o->name} );
        plug.setValue( nDefault );
        @CODE  }
    @CODE  }
    
    @CODE for( i = 0; i < AST->ObjectsCount( ); ++i ){
        @CODE Object * o = AST->objects[ i ];
        @CODE if( !o->IsType( "texture" ) )
            @CODE  continue;
        @CODE  if( !o->HasProperty( "attribute" ) || o->HasProperty( "attribute", "true" ) ){        
        // Get default from optionVar "${shadername}_${o->GetProperty( "long" )}
        @CODE if (o->HasProperty("value")){
        cDefault[0] = ${o->GetPropertyParam( "value", 0 )}f;
        cDefault[1] = ${o->GetPropertyParam( "value", 1 )}f;
        cDefault[2] = ${o->GetPropertyParam( "value", 2 )}f;
        @CODE }
        @CODE else{
        cDefault[0] = 0.0f;
        cDefault[1] = 0.0f;
        cDefault[2] = 0.0f;
        @CODE }
        GetColorDefault( "${shadername}_${o->GetProperty( "long" )}", cDefault );
        plug = MPlug( thisMObject(), a${o->name} );
        plug.child(0).setValue( cDefault[0] );
        plug.child(1).setValue( cDefault[1] );
        plug.child(2).setValue( cDefault[2] );
        @CODE }
    
    @CODE }     //for loop

    @CODE for( i = 0; i < AST->ObjectsCount( ); ++i ){
        @CODE Object * o = AST->objects[ i ];
        @CODE if( !o->IsType( "color" ) )
            @CODE  continue;
        @CODE  if( !o->HasProperty( "attribute" ) || o->HasProperty( "attribute", "true" ) ){        
        // Get default from optionVar "${shadername}_${o->GetProperty( "long" )}        
        @CODE if (o->HasProperty("value")){
        cDefault[0] = ${o->GetPropertyParam( "value", 0 )}f;
        cDefault[1] = ${o->GetPropertyParam( "value", 1 )}f;
        cDefault[2] = ${o->GetPropertyParam( "value", 2 )}f;
        @CODE }
        @CODE else{
        cDefault[0] = 0.0f;
        cDefault[1] = 0.0f;
        cDefault[2] = 0.0f;
        @CODE }
        GetColorDefault( "${shadername}_${o->GetProperty( "long" )}", cDefault );
        plug = MPlug( thisMObject(), a${o->name} );
        plug.child(0).setValue( cDefault[0] );
        plug.child(1).setValue( cDefault[1] );
        plug.child(2).setValue( cDefault[2] );
        @CODE }
    
    @CODE }
    }
    else
    {
        // Bug fix: 03 Jul 2002 -> Callback is initiated ONLY if shader is
        //                         created as the result of a file load/import!

        // Set callback after scene is loaded.
        afterOpenCallback = MSceneMessage::addCallback( MSceneMessage::kAfterOpen, 
                                          ${shadername}::AfterOpen, (void *) this );
        afterImportCallback = MSceneMessage::addCallback( MSceneMessage::kAfterImport, 
                                          ${shadername}::AfterOpen, (void *) this );
    }


    @CODE for( i = 0; i < AST->ObjectsCount( ); ++i ){
        @CODE Object * o = AST->objects[ i ];
        @CODE if( !o->IsType( "code" ) )
            @CODE  continue;
       @CODE if( o->HasProperty( "hook", "postconstructor" ) ){
          @CODE char source[ MAX_CODE_BUFFER ];
          @CODE PureString( o->GetProperty( "source" ), source );
          ${source}
       @CODE }
    @CODE }

    setMPSafe(true);
}


//
// Declare static member variables:
/////////////////////////////////////////////////////////////////////////////
    
// Declare All New Added Textures:
@CODE for( i = 0; i < AST->ObjectsCount( ); ++i ){
    @CODE Object * o = AST->objects[ i ];
    @CODE if( !o->IsType( "texture" ) )
        @CODE  continue;
    @CODE  if( !o->HasProperty( "attribute" ) || o->HasProperty( "attribute", "true" ) ){        
MObject  ${shadername}::a${o->name};
MObject  ${shadername}::a${o->name}R;
MObject  ${shadername}::a${o->name}G;
MObject  ${shadername}::a${o->name}B;
    @CODE }
@CODE }   
// Declare All New Added Colors:
@CODE for( i = 0; i < AST->ObjectsCount( ); ++i ){
    @CODE Object * o = AST->objects[ i ];
    @CODE if( !o->IsType( "color" ) )
        @CODE  continue;
    @CODE  if( !o->HasProperty( "attribute" ) || o->HasProperty( "attribute", "true" ) ){        
MObject  ${shadername}::a${o->name}R;
MObject  ${shadername}::a${o->name}G;
MObject  ${shadername}::a${o->name}B;
MObject  ${shadername}::a${o->name};
    @CODE }
    @CODE if( o->HasProperty( "fourCC" ) ){
MObject  ${shadername}::aExport${o->GetProperty( "fourCC" )};        //export
MObject  ${shadername}::aExport${o->GetProperty( "fourCC" )}R;        //export red
MObject  ${shadername}::aExport${o->GetProperty( "fourCC" )}G;        //export red
MObject  ${shadername}::aExport${o->GetProperty( "fourCC" )}B;        //export red
    @CODE }

@CODE }

// Declare All New Added enums:
@CODE for( i = 0; i < AST->ObjectsCount( ); ++i ){
    @CODE Object * o = AST->objects[ i ];
    @CODE if( !o->IsType( "enum" ) )
        @CODE  continue;
    @CODE  if( !o->HasProperty( "attribute" ) || o->HasProperty( "attribute", "true" ) ){        
MObject  ${shadername}::a${o->name};
    @CODE }
    @CODE if( o->HasProperty( "fourCC" ) ){
MObject  ${shadername}::aExport${o->GetProperty( "fourCC" )};        //export
    @CODE }

@CODE }   

// Declare All New Added floats:
@CODE for( i = 0; i < AST->ObjectsCount( ); ++i ){
    @CODE Object * o = AST->objects[ i ];
    @CODE if( !o->IsType( "float" ) )
        @CODE  continue;
    @CODE  if( !o->HasProperty( "attribute" ) || o->HasProperty( "attribute", "true" ) ){        
MObject  ${shadername}::a${o->name};
    @CODE }
    @CODE if( o->HasProperty( "fourCC" ) ){
MObject  ${shadername}::aExport${o->GetProperty( "fourCC" )};        //export
    @CODE }

@CODE }   
  
// Declare All New Added uvs:
@CODE for( i = 0; i < AST->ObjectsCount( ); ++i ){
    @CODE Object * o = AST->objects[ i ];
    @CODE if( !o->IsType( "uv" ) )
        @CODE  continue;
    @CODE  if( !o->HasProperty( "attribute" ) || o->HasProperty( "attribute", "true" ) ){        
MObject  ${shadername}::aU${o->name};
MObject  ${shadername}::aV${o->name};
MObject  ${shadername}::aUV${o->name};
    @CODE }
    @CODE if( o->HasProperty( "fourCC" ) ){
MObject  $UV{shadername}::aExport${o->GetProperty( "fourCC" )};        //export
MObject  $U{shadername}::aExport${o->GetProperty( "fourCC" )};        //export
MObject  $V{shadername}::aExport${o->GetProperty( "fourCC" )};        //export
    @CODE }

@CODE }   
  
// Declare All New Added ints:
@CODE for( i = 0; i < AST->ObjectsCount( ); ++i ){
    @CODE Object * o = AST->objects[ i ];
    @CODE if( !o->IsType( "int" ) )
        @CODE  continue;
    @CODE  if( !o->HasProperty( "attribute" ) || o->HasProperty( "attribute", "true" ) ){        
MObject  ${shadername}::a${o->name};
    @CODE }
@CODE if( o->HasProperty( "fourCC" ) ){
MObject  ${shadername}::aExport${o->GetProperty( "fourCC" )};        //export
@CODE }

@CODE }  

// Declare All New Added  bool:
@CODE for( i = 0; i < AST->ObjectsCount( ); ++i ){
    @CODE Object * o = AST->objects[ i ];
    @CODE if( !o->IsType( "bool" ) )
        @CODE  continue;
    @CODE  if( !o->HasProperty( "attribute" ) || o->HasProperty( "attribute", "true" ) ){        
MObject  ${shadername}::a${o->name};
    @CODE }
    @CODE if( o->HasProperty( "fourCC" ) ){
MObject  ${shadername}::aExport${o->GetProperty( "fourCC" )};        //export
    @CODE }

@CODE }  

// Declare All New Added  StringArray:
@CODE for( i = 0; i < AST->ObjectsCount( ); ++i ){
    @CODE Object * o = AST->objects[ i ];
    @CODE if( !o->IsType( "strarray" ) )
        @CODE  continue;
    @CODE  if( !o->HasProperty( "attribute" ) || o->HasProperty( "attribute", "true" ) ){        
MObject  ${shadername}::a${o->name};
    @CODE }
    @CODE if( o->HasProperty( "fourCC" ) ){
MObject  ${shadername}::aExport${o->GetProperty( "fourCC" )};        //export
    @CODE }

@CODE }  

MObject  ${shadername}::aOutColor;
MObject  ${shadername}::aOutColorR;
MObject  ${shadername}::aOutColorG;
MObject  ${shadername}::aOutColorB;
MObject  ${shadername}::aOutTrans;
MObject  ${shadername}::aOutTransR;
MObject  ${shadername}::aOutTransG;
MObject  ${shadername}::aOutTransB;

MObject  ${shadername}::aPDDIShaderName;
MObject  ${shadername}::aVertexShaderName;
MObject  ${shadername}::aExport;

MObject  ${shadername}::aIsTranslucent;
MObject  ${shadername}::aVertexNeeds;
MObject  ${shadername}::aVertexMask;

MObject  ${shadername}::aPointCamera;
MObject  ${shadername}::aPointCameraX;
MObject  ${shadername}::aPointCameraY;
MObject  ${shadername}::aPointCameraZ;
MObject  ${shadername}::aNormalCamera;
MObject  ${shadername}::aNormalCameraX;
MObject  ${shadername}::aNormalCameraY;
MObject  ${shadername}::aNormalCameraZ;
MObject  ${shadername}::aTriangleNormalCamera;
MObject  ${shadername}::aTriangleNormalCameraX;
MObject  ${shadername}::aTriangleNormalCameraY;
MObject  ${shadername}::aTriangleNormalCameraZ;
MObject  ${shadername}::aLightData;
MObject  ${shadername}::aLightDirection;
MObject  ${shadername}::aLightDirectionX;
MObject  ${shadername}::aLightDirectionY;
MObject  ${shadername}::aLightDirectionZ;
MObject  ${shadername}::aLightIntensity; 
MObject  ${shadername}::aLightIntensityR;
MObject  ${shadername}::aLightIntensityG;
MObject  ${shadername}::aLightIntensityB;
MObject  ${shadername}::aLightAmbient;
MObject  ${shadername}::aLightDiffuse;
MObject  ${shadername}::aLightSpecular;
MObject  ${shadername}::aLightShadowFraction;
MObject  ${shadername}::aPreShadowIntensity;
MObject  ${shadername}::aLightBlindData;

MObject ${shadername}::aObjectId;

//
// Constructor:
/////////////////////////////////////////////////////////////////////////////
${shadername}::${shadername}()
{
}

//
// Destructor:
/////////////////////////////////////////////////////////////////////////////
${shadername}::~${shadername}()
{
}

//
// Creator:
/////////////////////////////////////////////////////////////////////////////
void * ${shadername}::creator()
{
     return new ${shadername}();
}

//
// Intialize all attributes:
/////////////////////////////////////////////////////////////////////////////
MStatus ${shadername}::initialize()
{
    MFnNumericAttribute nAttr; 
    MFnEnumAttribute eAttr; 
    MFnLightDataAttribute lAttr;
    MFnTypedAttribute tAttr;
    MFnStringData str;
    MFnStringArrayData strarray;

    // output and internal attributes

    aOutColorR = nAttr.create( "outColorR", "ocr", MFnNumericData::kFloat);
    aOutColorG = nAttr.create( "outColorG", "ocg", MFnNumericData::kFloat);
    aOutColorB = nAttr.create( "outColorB", "ocb", MFnNumericData::kFloat);

    aOutColor = nAttr.create( "outColor","oc", aOutColorR, aOutColorG, aOutColorB);
    nAttr.setHidden(false);
    nAttr.setReadable(true);
    nAttr.setWritable(false);

    aOutTransR = nAttr.create( "outTransparencyR","otr", MFnNumericData::kFloat);
    aOutTransG = nAttr.create( "outTransparencyG","otg", MFnNumericData::kFloat);
    aOutTransB = nAttr.create( "outTransparencyB","otb", MFnNumericData::kFloat);
    aOutTrans = nAttr.create( "outTransparency","ot", aOutTransR,aOutTransG,aOutTransB);
    nAttr.setHidden(false);
    nAttr.setReadable(true);
    nAttr.setWritable(false);

    aPDDIShaderName = tAttr.create( "pddiShaderName", "psn", MFnData::kString);
    tAttr.setHidden(true);
    tAttr.setReadable(true);
    tAttr.setWritable(false);
    tAttr.setDefault(str.create("${pddiname}"));

    aVertexShaderName = tAttr.create( "vertexShaderName", "vsn", MFnData::kString);
    tAttr.setHidden(false);
    tAttr.setReadable(true);
    tAttr.setWritable(true);
    tAttr.setDefault(str.create(""));

    aIsTranslucent = nAttr.create( "isTranslucent", "trans", MFnNumericData::kBoolean);
    nAttr.setHidden(true);
    nAttr.setStorable(false);
    nAttr.setDefault(false);

    aVertexNeeds = nAttr.create( "vertexNeeds", "vn", MFnNumericData::kLong);
    nAttr.setHidden(true);
    nAttr.setStorable(false);
    nAttr.setDefault(0);

    aVertexMask = nAttr.create( "vertexMask", "vm", MFnNumericData::kLong);
    nAttr.setHidden(true);
    nAttr.setStorable(false);
    nAttr.setDefault(0);

    aPointCameraX = nAttr.create( "pointCameraX", "px", MFnNumericData::kFloat);
    nAttr.setStorable(false);
    nAttr.setDefault(1.0f);

    aPointCameraY = nAttr.create( "pointCameraY", "py", MFnNumericData::kFloat);
    nAttr.setStorable(false);
    nAttr.setDefault(1.0f);

    aPointCameraZ = nAttr.create( "pointCameraZ", "pz", MFnNumericData::kFloat);
    nAttr.setStorable(false);
    nAttr.setDefault(1.0f);

    aPointCamera = nAttr.create( "pointCamera","pc", 
                                          aPointCameraX, aPointCameraY, aPointCameraZ);
    nAttr.setStorable(false);
    nAttr.setDefault(1.0f, 1.0f, 1.0f);
    nAttr.setHidden(true);


    aNormalCameraX = nAttr.create( "normalCameraX", "nx", MFnNumericData::kFloat);
    nAttr.setStorable(false);
    nAttr.setDefault(1.0f);

    aNormalCameraY = nAttr.create( "normalCameraY", "ny", MFnNumericData::kFloat);
    nAttr.setStorable(false);
    nAttr.setDefault(1.0f);

    aNormalCameraZ = nAttr.create( "normalCameraZ", "nz", MFnNumericData::kFloat);
    nAttr.setStorable(false);
    nAttr.setDefault(1.0f);

    aNormalCamera = nAttr.create( "normalCamera","n", 
                                            aNormalCameraX, aNormalCameraY, aNormalCameraZ);
    nAttr.setStorable(false);
    nAttr.setDefault(1.0f, 1.0f, 1.0f);
    nAttr.setHidden(true);

    aTriangleNormalCameraX = nAttr.create( "triangleNormalCameraX", "tnx", MFnNumericData::kFloat);
    nAttr.setStorable(false);
    nAttr.setDefault(1.0f);

    aTriangleNormalCameraY = nAttr.create( "triangleNormalCameraY", "tny", MFnNumericData::kFloat);
    nAttr.setStorable(false);
    nAttr.setDefault(1.0f);

    aTriangleNormalCameraZ = nAttr.create( "triangleNormalCameraZ", "tnz", MFnNumericData::kFloat);
    nAttr.setStorable(false);
    nAttr.setDefault(1.0f);

    aTriangleNormalCamera = nAttr.create( "triangleNormalCamera","tn", 
                                            aTriangleNormalCameraX, aTriangleNormalCameraY, aTriangleNormalCameraZ);
    nAttr.setStorable(false);
    nAttr.setDefault(1.0f, 1.0f, 1.0f);
    nAttr.setHidden(true);

    aLightDirectionX = nAttr.create( "lightDirectionX", "ldx", MFnNumericData::kFloat);
    nAttr.setStorable(false);
    nAttr.setHidden(true);
    nAttr.setReadable(false);
    nAttr.setDefault(1.0f);

    aLightDirectionY = nAttr.create( "lightDirectionY", "ldy", MFnNumericData::kFloat);
    nAttr.setStorable(false);
    nAttr.setHidden(true);
    nAttr.setReadable(false);
    nAttr.setDefault(1.0f);

    aLightDirectionZ = nAttr.create( "lightDirectionZ", "ldz", MFnNumericData::kFloat);
    nAttr.setStorable(false);
    nAttr.setHidden(true);
    nAttr.setReadable(false);
    nAttr.setDefault(1.0f);

    aLightDirection = nAttr.create( "lightDirection", "ld", 
                                              aLightDirectionX, aLightDirectionY, aLightDirectionZ);
    nAttr.setStorable(false);
    nAttr.setHidden(true);
    nAttr.setReadable(false);
    nAttr.setDefault(1.0f, 1.0f, 1.0f);

    aLightIntensityR = nAttr.create( "lightIntensityR", "lir", MFnNumericData::kFloat);
    nAttr.setStorable(false);
    nAttr.setHidden(true);
    nAttr.setReadable(false);
    nAttr.setDefault(1.0f);

    aLightIntensityG = nAttr.create( "lightIntensityG", "lig", MFnNumericData::kFloat);
    nAttr.setStorable(false);
    nAttr.setHidden(true);
    nAttr.setReadable(false);
    nAttr.setDefault(1.0f);

    aLightIntensityB = nAttr.create( "lightIntensityB", "lib", MFnNumericData::kFloat);
    nAttr.setStorable(false);
    nAttr.setHidden(true);
    nAttr.setReadable(false);
    nAttr.setDefault(1.0f);

    aLightIntensity = nAttr.create( "lightIntensity", "li", 
                                              aLightIntensityR, aLightIntensityG, aLightIntensityB);
    nAttr.setStorable(false);
    nAttr.setHidden(true);
    nAttr.setReadable(false);
    nAttr.setDefault(1.0f, 1.0f, 1.0f);

    aLightAmbient = nAttr.create( "lightAmbient", "la", MFnNumericData::kBoolean);
    nAttr.setStorable(false);
    nAttr.setHidden(true);
    nAttr.setReadable(false);
    nAttr.setDefault(true);

    aLightDiffuse = nAttr.create( "lightDiffuse", "ldf", MFnNumericData::kBoolean);
    nAttr.setStorable(false);
    nAttr.setHidden(true);
    nAttr.setReadable(false);
    nAttr.setDefault(true);

    aLightSpecular = nAttr.create( "lightSpecular", "ls", MFnNumericData::kBoolean);
    nAttr.setStorable(false);
    nAttr.setHidden(true);
    nAttr.setReadable(false);
    nAttr.setDefault(false);

    aLightShadowFraction = nAttr.create("lightShadowFraction","lsf",MFnNumericData::kFloat);
    nAttr.setStorable(false);
    nAttr.setHidden(true);
    nAttr.setReadable(false);
    nAttr.setDefault(0.0f);

    aPreShadowIntensity = nAttr.create("preShadowIntensity","psi",MFnNumericData::kFloat);
    nAttr.setStorable(false);
    nAttr.setHidden(true);
    nAttr.setReadable(false);
    nAttr.setDefault(0.0f);

    aLightBlindData = nAttr.create("lightBlindData","lbld",MFnNumericData::kLong);
    nAttr.setStorable(false);
    nAttr.setHidden(true);
    nAttr.setReadable(false);
    nAttr.setDefault(0);

#if ( MAYA_API_VERSION >= 400 )
    aLightData = lAttr.create( "lightDataArray", "ltd", 
                                        aLightDirection, aLightIntensity, aLightAmbient, 
                                        aLightDiffuse, aLightSpecular, aLightShadowFraction,
                                        aPreShadowIntensity,
                                        aLightBlindData);
    lAttr.setDefault(0.0f, 0.0f, 0.0f, 0.0f, 0.0f, 0.0f, true, true, false, 0.0f, 1.0f, 0);
#else
#if ( MAYA_API_VERSION >= 300 )
    aLightData = lAttr.create( "lightDataArray", "ltd", 
                                        aLightDirection, aLightIntensity, aLightAmbient, 
                                        aLightDiffuse, aLightSpecular, aLightShadowFraction,
                                        aPreShadowIntensity,
                                        aLightBlindData);
    lAttr.setDefault(0.0f, 0.0f, 0.0f, 0.0f, 0.0f, 0.0f, true, true, false, 0.0f, 1.0f, 0);
#else
    aLightData = lAttr.create( "lightDataArray", "ltd", 
                                        aLightDirection, aLightIntensity, aLightAmbient, 
                                        aLightDiffuse, aLightSpecular, aLightShadowFraction,
                                        aPreShadowIntensity);
    lAttr.setDefault(0.0f, 0.0f, 0.0f, 0.0f, 0.0f, 0.0f, true, true, false, 0.0f, 1.0f);
#endif
#endif

    lAttr.setArray(true);
    lAttr.setStorable(false);
    lAttr.setHidden(true);

    // objectId
    aObjectId = nAttr.create( "objectId", "oi", MFnNumericData::kLong, 0.0 );
    nAttr.setStorable(false);
    nAttr.setHidden(true);
    nAttr.setReadable(false);

    addAttribute(aPDDIShaderName);
    addAttribute(aVertexShaderName);
    addAttribute(aExport);
    addAttribute(aIsTranslucent);
    addAttribute(aVertexNeeds);
    addAttribute(aVertexMask);

    addAttribute(aPointCamera);
    addAttribute(aNormalCamera);
    addAttribute(aTriangleNormalCamera);
    addAttribute(aLightData);
    addAttribute(aOutColor);
    addAttribute(aOutTrans);
    addAttribute(aObjectId);

    attributeAffects (aLightIntensity, aOutColor);
    attributeAffects (aLightIntensityR, aOutColor);
    attributeAffects (aLightIntensityG, aOutColor);
    attributeAffects (aLightIntensityB, aOutColor);
    attributeAffects (aPointCamera, aOutColor);
    attributeAffects (aPointCameraX, aOutColor);
    attributeAffects (aPointCameraY, aOutColor);
    attributeAffects (aPointCameraZ, aOutColor);
    attributeAffects (aNormalCamera, aOutColor);
    attributeAffects (aNormalCameraX, aOutColor);
    attributeAffects (aNormalCameraY, aOutColor);
    attributeAffects (aNormalCameraZ, aOutColor);
    attributeAffects (aTriangleNormalCamera, aOutColor);
    attributeAffects (aTriangleNormalCameraX, aOutColor);
    attributeAffects (aTriangleNormalCameraY, aOutColor);
    attributeAffects (aTriangleNormalCameraZ, aOutColor);
    attributeAffects (aLightData, aOutColor);
    attributeAffects (aLightDirectionX, aOutColor);
    attributeAffects (aLightDirectionY, aOutColor);
    attributeAffects (aLightDirectionZ, aOutColor);
    attributeAffects (aLightAmbient, aOutColor);
    attributeAffects (aLightSpecular, aOutColor);
    attributeAffects (aLightDiffuse, aOutColor);
    attributeAffects (aLightDirection, aOutColor);
    attributeAffects (aLightShadowFraction, aOutColor);
    attributeAffects (aPreShadowIntensity, aOutColor);
    attributeAffects (aLightBlindData, aOutColor);

    attributeAffects(aObjectId,aOutColor);
    attributeAffects(aObjectId,aVertexNeeds);
    attributeAffects(aObjectId,aVertexMask);

    //Create all texture attributes here:
@CODE for( i = 0; i < AST->ObjectsCount( ); ++i ){
    @CODE Object * o = AST->objects[ i ];
    @CODE if( !o->IsType( "texture" ) )
        @CODE  continue;
    @CODE  if( !o->HasProperty( "attribute" ) || o->HasProperty( "attribute", "true" ) ){        
    a${o->name}R = nAttr.create( "${o->GetProperty( "long" )}R", "${o->GetProperty( "short" )}r",MFnNumericData::kFloat);
    a${o->name}G = nAttr.create( "${o->GetProperty( "long" )}G", "${o->GetProperty( "short" )}g",MFnNumericData::kFloat);
    a${o->name}B = nAttr.create( "${o->GetProperty( "long" )}B", "${o->GetProperty( "short" )}b",MFnNumericData::kFloat);
    
    a${o->name} = nAttr.create( "${o->GetProperty( "long" )}", "${o->GetProperty( "short" )}", a${o->name}R , a${o->name}G, a${o->name}B );
    nAttr.setKeyable(true);
    @CODE if ( o->HasProperty( "storable" ) ){
    nAttr.setStorable(${o->GetProperty( "storable" )});
    @CODE }
    @CODE else{
    nAttr.setStorable(true);
    @CODE }
    @CODE if ( o->HasProperty( "value" ) ){
    nAttr.setDefault(${o->GetPropertyParam( "value", 0 )}, ${o->GetPropertyParam( "value", 1 )}, ${o->GetPropertyParam( "value", 2 )});
    @CODE }
    @CODE else{
    nAttr.setDefault(0.0f, 0.0f, 0.0f);
    @CODE }
    nAttr.setUsedAsColor(true);
    @CODE }
@CODE }

    //Create all color attributes here:
@CODE for( i = 0; i < AST->ObjectsCount( ); ++i ){
    @CODE Object * o = AST->objects[ i ];
    @CODE if( !o->IsType( "color" ) )
        @CODE  continue;
    @CODE  if( !o->HasProperty( "attribute" ) || o->HasProperty( "attribute", "true" ) ){        
    a${o->name}R = nAttr.create( "${o->GetProperty( "long" )}R", "${o->GetProperty( "short" )}r",MFnNumericData::kFloat);
    a${o->name}G = nAttr.create( "${o->GetProperty( "long" )}G", "${o->GetProperty( "short" )}g",MFnNumericData::kFloat);
    a${o->name}B = nAttr.create( "${o->GetProperty( "long" )}B", "${o->GetProperty( "short" )}b",MFnNumericData::kFloat);
    
    a${o->name} = nAttr.create( "${o->GetProperty( "long" )}", "${o->GetProperty( "short" )}", a${o->name}R , a${o->name}G, a${o->name}B );
    @CODE if (o->HasProperty( "keyable" )){
    nAttr.setKeyable(${o->GetProperty( "keyable" )});
    @CODE }
    @CODE else{
    nAttr.setKeyable(true);
    @CODE }
    @CODE if ( o->HasProperty( "storable" ) ){
    nAttr.setStorable(${o->GetProperty( "storable" )});
    @CODE }
    @CODE else{
    nAttr.setStorable(true);
    @CODE }
    @CODE if (o->HasProperty( "connectable" )){
    nAttr.setConnectable(${o->GetProperty( "connectable" )});
    @CODE }
    @CODE else{
    nAttr.setConnectable(true);
    @CODE }
    @CODE if ( o->HasProperty( "value" ) ){
    nAttr.setDefault(${o->GetPropertyParam( "value", 0 )}, ${o->GetPropertyParam( "value", 1 )}, ${o->GetPropertyParam( "value", 2 )});
    @CODE }
    @CODE else{
    nAttr.setDefault(0.0f, 0.0f, 0.0f);
    @CODE }
    nAttr.setUsedAsColor(true);
    @CODE }

@CODE }

    //Create all bool attributes here:
@CODE for( i = 0; i < AST->ObjectsCount( ); ++i ){
    @CODE Object * o = AST->objects[ i ];
    @CODE if( !o->IsType( "bool" ) )
        @CODE  continue;
    @CODE  if( !o->HasProperty( "attribute" ) || o->HasProperty( "attribute", "true" ) ){        
    a${o->name} = nAttr.create( "${o->GetProperty( "long" )}", "${o->GetProperty( "short" )}", MFnNumericData::kBoolean);
    @CODE if (o->HasProperty( "keyable" )){
    nAttr.setKeyable(${o->GetProperty( "keyable" )});
    @CODE }
    @CODE else{
    nAttr.setKeyable(true);
    @CODE }
    @CODE if (o->HasProperty( "connectable" )){
    nAttr.setConnectable(${o->GetProperty( "connectable" )});
    @CODE }
    @CODE else{
    nAttr.setConnectable(true);
    @CODE }
    @CODE if (o->HasProperty( "storable" )){
    nAttr.setStorable(${o->GetProperty( "storable" )});
    @CODE }
    @CODE else{
    nAttr.setStorable(true);
    @CODE }
    @CODE if (o->HasProperty( "value" )){
    nAttr.setDefault(${o->GetProperty("value")});
    @CODE }
    @CODE else{
    nAttr.setDefault(true);
    @CODE }
    @CODE }

@CODE }

     //Create all float attributes here:
@CODE for( i = 0; i < AST->ObjectsCount( ); ++i ){
    @CODE Object * o = AST->objects[ i ];
    @CODE if( !o->IsType( "float" ) )
        @CODE  continue;
    @CODE  if( !o->HasProperty( "attribute" ) || o->HasProperty( "attribute", "true" ) ){        
    a${o->name} = nAttr.create( "${o->GetProperty( "long" )}", "${o->GetProperty( "short" )}", MFnNumericData::kFloat);
    @CODE if (o->HasProperty( "keyable" )){
    nAttr.setKeyable(${o->GetProperty( "keyable" )});
    @CODE }
    @CODE else{
    nAttr.setKeyable(true);
    @CODE }
    @CODE if (o->HasProperty( "storable" )){
    nAttr.setStorable(${o->GetProperty( "storable" )});
    @CODE }
    @CODE else{
    nAttr.setStorable(true);
    @CODE }
    nAttr.setWritable( true );
    @CODE if (o->HasProperty( "connectable" )){
    nAttr.setConnectable(${o->GetProperty( "connectable" )});
    @CODE }
    @CODE else{
    nAttr.setConnectable(true);
    @CODE }
    @CODE if ( o->HasProperty( "min" ) ){
    nAttr.setMin(${o->GetProperty( "min" )});
    @CODE }
    @CODE if ( o->HasProperty( "max" ) ){
    nAttr.setMax(${o->GetProperty( "max" )});
    @CODE }
    @CODE if ( o->HasProperty( "value" ) ){
    nAttr.setDefault(${o->GetProperty( "value" )});
    @CODE }
    @CODE }

@CODE }

     //Create all uv attributes here:
@CODE for( i = 0; i < AST->ObjectsCount( ); ++i ){
    @CODE Object * o = AST->objects[ i ];
    @CODE if( !o->IsType( "uv" ) )
        @CODE  continue;
    @CODE  if( !o->HasProperty( "attribute" ) || o->HasProperty( "attribute", "true" ) ){        
    aU${o->name} = nAttr.create( "u${o->GetProperty( "long" )}", "u${o->GetProperty( "short" )}",MFnNumericData::kFloat);
    aV${o->name} = nAttr.create( "v${o->GetProperty( "long" )}", "v${o->GetProperty( "short" )}",MFnNumericData::kFloat);
    aUV${o->name} = nAttr.create( "uv${o->GetProperty( "long" )}", "uv${o->GetProperty( "short" )}", aU${o->name} , aV${o->name} );
    @CODE if (o->HasProperty( "keyable" )){
    nAttr.setKeyable(${o->GetProperty( "keyable" )});
    @CODE }
    @CODE else{
    nAttr.setKeyable(true);
    @CODE }
    @CODE if (o->HasProperty( "storable" )){
    nAttr.setStorable(${o->GetProperty( "storable" )});
    @CODE }
    @CODE else{
    nAttr.setStorable(true);
    @CODE }
    nAttr.setWritable( true );
    @CODE if (o->HasProperty( "connectable" )){
    nAttr.setConnectable(${o->GetProperty( "connectable" )});
    @CODE }
    @CODE else{
    nAttr.setConnectable(true);
    @CODE }
    @CODE if ( o->HasProperty( "min" ) ){
    nAttr.setMin(${o->GetProperty( "min" )});
    @CODE }
    @CODE if ( o->HasProperty( "max" ) ){
    nAttr.setMax(${o->GetProperty( "max" )});
    @CODE }
    @CODE if ( o->HasProperty( "value" ) ){
    nAttr.setDefault(${o->GetPropertyParam( "value", 0 )}, ${o->GetPropertyParam( "value", 1 )});
    @CODE }
    @CODE else{
    nAttr.setDefault(0.0f, 0.0f);
    @CODE }
    @CODE if ( o->HasProperty( "renderSource" ) ){
    nAttr.setRenderSource(${o->GetProperty( "renderSource" )});
    @CODE }
    @CODE }

@CODE }

     //Create all int attributes here:
@CODE for( i = 0; i < AST->ObjectsCount( ); ++i ){
    @CODE Object * o = AST->objects[ i ];
    @CODE if( !o->IsType( "int" ) )
        @CODE  continue;
    @CODE  if( !o->HasProperty( "attribute" ) || o->HasProperty( "attribute", "true" ) ){        
    a${o->name} = nAttr.create( "${o->GetProperty( "long" )}", "${o->GetProperty( "short" )}", MFnNumericData::kShort);
    @CODE if (o->HasProperty( "keyable" )){
    nAttr.setKeyable(${o->GetProperty( "keyable" )});
    @CODE }
    @CODE else{
    nAttr.setKeyable(true);
    @CODE }
    @CODE if ( o->HasProperty( "storable" ) ){
    nAttr.setStorable(${o->GetProperty( "storable" )});
    @CODE }
    @CODE else{
    nAttr.setStorable(true);
    @CODE }
    @CODE if (o->HasProperty( "connectable" )){
    nAttr.setConnectable(${o->GetProperty( "connectable" )});
    @CODE }
    @CODE else{
    nAttr.setConnectable(true);
    @CODE }
    @CODE if ( o->HasProperty( "min" ) ){
    nAttr.setMin(${o->GetProperty( "min" )});
    @CODE }
    @CODE else{
    nAttr.setMin(0);
    @CODE }
    @CODE if ( o->HasProperty( "max" ) ){
    nAttr.setMax(${o->GetProperty( "max" )});
    @CODE }
    @CODE else{
    nAttr.setMax(1);
    @CODE }
    @CODE if ( o->HasProperty( "value" ) ){
    nAttr.setDefault(${o->GetProperty( "value" )});
    @CODE }
    @CODE else{
    nAttr.setDefault(0);
    @CODE }
    @CODE }

@CODE }

     //Create all enum attributes here:
@CODE for( i = 0; i < AST->ObjectsCount( ); ++i ){
    @CODE Object * o = AST->objects[ i ];
    @CODE if( !o->IsType( "enum" ) )
        @CODE  continue;
    @CODE  if( !o->HasProperty( "attribute" ) || o->HasProperty( "attribute", "true" ) ){        
    @CODE if( o->HasProperty( "default" ) ){
    a${o->name} = eAttr.create( "${o->GetProperty( "long" )}", "${o->GetProperty( "short" )}", ${o->GetProperty( "default" )} );
    @CODE }
    @CODE else{
    a${o->name} = eAttr.create( "${o->GetProperty( "long" )}", "${o->GetProperty( "short" )}", 0 );
    @CODE }
    @CODE if( o->HasProperty( "keyable" ) ){
    eAttr.setKeyable(${o->GetProperty( "keyable" )});
    @CODE }
    @CODE else{
    eAttr.setKeyable(false);
    @CODE }
    @CODE if (o->HasProperty( "connectable" )){
    eAttr.setConnectable(${o->GetProperty( "connectable" )});
    @CODE }
    @CODE else{
    eAttr.setConnectable(false);
    @CODE }
    @CODE if (o->HasProperty( "storable" )){
    eAttr.setStorable(${o->GetProperty( "storable" )});
    @CODE }
    @CODE else{
    eAttr.setStorable(true);
    @CODE }    
    @CODE int count = o->GetPropertyParamNum( "value" );
    @CODE --count;
    @CODE while( count >= 0 ){
    @CODE char strcount[ MAX_LINE_LEN ];
    @CODE sprintf( strcount, "%d", count );    
    eAttr.addField( ${o->GetPropertyParam( "value", count )}, ${strcount} );
    @CODE --count;
    @CODE }
    @CODE }

@CODE }
 
     //Create all StringArray attributes here:
@CODE for( i = 0; i < AST->ObjectsCount( ); ++i ){
    @CODE Object * o = AST->objects[ i ];
    @CODE if( !o->IsType( "strarray" ) )
        @CODE  continue;
    @CODE  if( !o->HasProperty( "attribute" ) || o->HasProperty( "attribute", "true" ) ){        
    a${o->name} = tAttr.create( "${o->GetProperty( "long" )}", "${o->GetProperty( "short" )}", MFnData::kStringArray);
    tAttr.setHidden(true);
    tAttr.setReadable(true);
    tAttr.setWritable(false);
    @CODE int count = o->GetPropertyParamNum( "value" );
    @CODE char str[ MAX_LINE_LEN ] = "";
    @CODE char name[ MAX_LINE_LEN ];    
    @CODE --count;
    @CODE while( count >= 0 ){
        @CODE char strcount[ MAX_LINE_LEN ];
        @CODE sprintf( strcount, "%d", count );
        @CODE PureString( o->GetPropertyParam( "value", count ), name );
        @CODE if( strlen( str ) == 0 ){
            @CODE   strcat( str, name );
        @CODE }
        @CODE else{
            @CODE   strcat( str, "\", \"" );
            @CODE   strcat( str, name );
        @CODE }
        @CODE --count;
    @CODE }
    @CODE char valueNum[ MAX_LINE_LEN ];
    @CODE sprintf( valueNum, "%d", o->GetPropertyParamNum( "value" ) );
    const char* ${o->GetProperty( "short" )}char[] = { "${str}" };
    MStringArray ${o->GetProperty( "short" )}Strings(${o->GetProperty( "short" )}char, ${valueNum});
    tAttr.setDefault(strarray.create(${o->GetProperty( "short" )}Strings));
    @CODE }

@CODE }

    //Add all texture attributes here:
@CODE for( i = 0; i < AST->ObjectsCount( ); ++i ){
    @CODE Object * o = AST->objects[ i ];
    @CODE if( !o->IsType( "texture" ) )
        @CODE  continue;
    @CODE  if( !o->HasProperty( "attribute" ) || o->HasProperty( "attribute", "true" ) ){        
    addAttribute( a${o->name} );
    @CODE }
@CODE }

    //Add all texture attributes here:
@CODE for( i = 0; i < AST->ObjectsCount( ); ++i ){
    @CODE Object * o = AST->objects[ i ];
    @CODE if( !o->IsType( "color" ) )
        @CODE  continue;
    @CODE  if( !o->HasProperty( "attribute" ) || o->HasProperty( "attribute", "true" ) ){        
    addAttribute( a${o->name} );
    @CODE }
@CODE }

    //Add all bool attributes here:
@CODE for( i = 0; i < AST->ObjectsCount( ); ++i ){
    @CODE Object * o = AST->objects[ i ];
    @CODE if( !o->IsType( "bool" ) )
        @CODE  continue;
    @CODE  if( !o->HasProperty( "attribute" ) || o->HasProperty( "attribute", "true" ) ){        
    addAttribute( a${o->name} );
    @CODE }
@CODE }

     //Add all float attributes here:
@CODE for( i = 0; i < AST->ObjectsCount( ); ++i ){
    @CODE Object * o = AST->objects[ i ];
    @CODE if( !o->IsType( "float") )
        @CODE  continue;
    @CODE  if( !o->HasProperty( "attribute" ) || o->HasProperty( "attribute", "true" ) ){        
    addAttribute( a${o->name} );
    @CODE }
@CODE }

     //Add all uv attributes here:
@CODE for( i = 0; i < AST->ObjectsCount( ); ++i ){
    @CODE Object * o = AST->objects[ i ];
    @CODE if( !o->IsType( "uv" ) )
        @CODE  continue;
    @CODE  if( !o->HasProperty( "attribute" ) || o->HasProperty( "attribute", "true" ) ){        
    addAttribute( aUV${o->name} );
    @CODE }
@CODE }

     //Add all int attributes here:
@CODE for( i = 0; i < AST->ObjectsCount( ); ++i ){
    @CODE Object * o = AST->objects[ i ];
    @CODE if( !o->IsType( "int" ) )
        @CODE  continue;
    @CODE  if( !o->HasProperty( "attribute" ) || o->HasProperty( "attribute", "true" ) ){        
    addAttribute( a${o->name} );
    @CODE }
@CODE }

     //Add all enum attributes here:
@CODE for( i = 0; i < AST->ObjectsCount( ); ++i ){
    @CODE Object * o = AST->objects[ i ];
    @CODE if( !o->IsType( "enum" ) )
        @CODE  continue;
    @CODE  if( !o->HasProperty( "attribute" ) || o->HasProperty( "attribute", "true" ) ){        
    addAttribute( a${o->name} );
    @CODE }
@CODE }
 
     //Add all StringArray attributes here:
@CODE for( i = 0; i < AST->ObjectsCount( ); ++i ){
    @CODE Object * o = AST->objects[ i ];
    @CODE if( !o->IsType( "strarray" ) )
        @CODE  continue;
    @CODE  if( !o->HasProperty( "attribute" ) || o->HasProperty( "attribute", "true" ) ){        
    addAttribute( a${o->name} );
    @CODE }
@CODE }

    // attributeAffects for all texture attributes here:
@CODE for( i = 0; i < AST->ObjectsCount( ); ++i ){
    @CODE Object * o = AST->objects[ i ];
    @CODE if( !o->IsType( "texture" ) )
        @CODE  continue;
    @CODE  if( !o->HasProperty( "attribute" ) || o->HasProperty( "attribute", "true" ) ){        
        @CODE if ( o->HasProperty( "affect" ) ){
        @CODE int affectnum = o->GetPropertyParamNum("affect");
        @CODE --affectnum;
        @CODE while( affectnum >= 0 ){            
    attributeAffects ( a${o->name}, ${o->GetPropertyParam( "affect", affectnum )} );
    attributeAffects ( a${o->name}R, ${o->GetPropertyParam( "affect", affectnum )}R );
    attributeAffects ( a${o->name}G, ${o->GetPropertyParam( "affect", affectnum )}G );
    attributeAffects ( a${o->name}B, ${o->GetPropertyParam( "affect", affectnum )}B );
        @CODE --affectnum;
        @CODE }
        @CODE }
    @CODE }
@CODE }

    //attributeAffects for all texture attributes here:
@CODE for( i = 0; i < AST->ObjectsCount( ); ++i ){
    @CODE Object * o = AST->objects[ i ];
    @CODE if( !o->IsType( "color" ) )
        @CODE  continue;
    @CODE  if( !o->HasProperty( "attribute" ) || o->HasProperty( "attribute", "true" ) ){        
        @CODE if ( o->HasProperty( "affect" ) ){
        @CODE int affectnum = o->GetPropertyParamNum("affect");
        @CODE --affectnum;
        @CODE while( affectnum >= 0 ){            
    attributeAffects ( a${o->name}, ${o->GetPropertyParam( "affect", affectnum )} );
    attributeAffects ( a${o->name}R, ${o->GetPropertyParam( "affect", affectnum )}R );
    attributeAffects ( a${o->name}G, ${o->GetPropertyParam( "affect", affectnum )}G );
    attributeAffects ( a${o->name}B, ${o->GetPropertyParam( "affect", affectnum )}B );
        @CODE --affectnum;
        @CODE }
        @CODE }
    @CODE }
@CODE }
    //attributeAffects for all bool attributes here:
@CODE for( i = 0; i < AST->ObjectsCount( ); ++i ){
    @CODE Object * o = AST->objects[ i ];
    @CODE if( !o->IsType( "bool" ) )
        @CODE  continue;
    @CODE  if( !o->HasProperty( "attribute" ) || o->HasProperty( "attribute", "true" ) ){        
        @CODE if ( o->HasProperty( "affect" ) ){
        @CODE int affectnum = o->GetPropertyParamNum("affect");
        @CODE --affectnum;
        @CODE while( affectnum >= 0 ){            
    attributeAffects ( a${o->name}, ${o->GetPropertyParam( "affect", affectnum )} ); 
        @CODE --affectnum;
        @CODE }
        @CODE }
    @CODE }
@CODE }

     //attributeAffects for  all float attributes here:
@CODE for( i = 0; i < AST->ObjectsCount( ); ++i ){
    @CODE Object * o = AST->objects[ i ];
    @CODE if( !o->IsType( "float" ) )
        @CODE  continue;
    @CODE  if( !o->HasProperty( "attribute" ) || o->HasProperty( "attribute", "true" ) ){        
        @CODE if ( o->HasProperty( "affect" ) ){
        @CODE int affectnum = o->GetPropertyParamNum("affect");
        @CODE --affectnum;
        @CODE while( affectnum >= 0 ){            
    attributeAffects ( a${o->name}, ${o->GetPropertyParam( "affect", affectnum )} ); 
        @CODE --affectnum;
        @CODE }
        @CODE }
    @CODE }
@CODE }

     //attributeAffects for  all uv attributes here:
@CODE for( i = 0; i < AST->ObjectsCount( ); ++i ){
    @CODE Object * o = AST->objects[ i ];
    @CODE if( !o->IsType( "uv" ) )
        @CODE  continue;
    @CODE  if( !o->HasProperty( "attribute" ) || o->HasProperty( "attribute", "true" ) ){        
        @CODE if ( o->HasProperty( "affect" ) ){
        @CODE int affectnum = o->GetPropertyParamNum("affect");
        @CODE --affectnum;
        @CODE while( affectnum >= 0 ){            
    attributeAffects ( a${o->name}, ${o->GetPropertyParam( "affect", affectnum )} ); 
        @CODE --affectnum;
        @CODE }
        @CODE }
    @CODE }
@CODE }
     //attributeAffects for  all int attributes here:
@CODE for( i = 0; i < AST->ObjectsCount( ); ++i ){
    @CODE Object * o = AST->objects[ i ];
    @CODE if( !o->IsType( "int" ) )
        @CODE  continue;
    @CODE  if( !o->HasProperty( "attribute" ) || o->HasProperty( "attribute", "true" ) ){        
        @CODE if ( o->HasProperty( "affect" ) ){
        @CODE int affectnum = o->GetPropertyParamNum("affect");
        @CODE --affectnum;
        @CODE while( affectnum >= 0 ){            
    attributeAffects ( a${o->name}, ${o->GetPropertyParam( "affect", affectnum )} ); 
        @CODE --affectnum;
        @CODE }
        @CODE }
    @CODE }
@CODE }

     //attributeAffects for  all enum attributes here:
@CODE for( i = 0; i < AST->ObjectsCount( ); ++i ){
    @CODE Object * o = AST->objects[ i ];
    @CODE if( !o->IsType( "enum" ) )
        @CODE  continue;
    @CODE  if( !o->HasProperty( "attribute" ) || o->HasProperty( "attribute", "true" ) ){        
        @CODE if ( o->HasProperty( "affect" ) ){
        @CODE int affectnum = o->GetPropertyParamNum("affect");
        @CODE --affectnum;
        @CODE while( affectnum >= 0 ){            
    attributeAffects ( a${o->name}, ${o->GetPropertyParam( "affect", affectnum )} ); 
        @CODE --affectnum;
        @CODE }
        @CODE }
    @CODE }
@CODE }
 
     //attributeAffects for all StringArray attributes here:
@CODE for( i = 0; i < AST->ObjectsCount( ); ++i ){
    @CODE Object * o = AST->objects[ i ];
    @CODE if( !o->IsType( "strarray" ) )
        @CODE  continue;
    @CODE  if( !o->HasProperty( "attribute" ) || o->HasProperty( "attribute", "true" ) ){        
        @CODE if ( o->HasProperty( "affect" ) ){
        @CODE int affectnum = o->GetPropertyParamNum("affect");
        @CODE --affectnum;
        @CODE while( affectnum >= 0 ){            
    attributeAffects ( a${o->name}, ${o->GetPropertyParam( "affect", affectnum )} ); 
        @CODE --affectnum;
        @CODE }
        @CODE }
    @CODE }
@CODE }

    exporterAttributes();
    
    return MS::kSuccess;
}

//

#define INTATTR(code, source)  aExport##code = nAttr.create( #code , "export"#code , MFnNumericData::kLong); \
                                         nAttr.setStorable(false);                                                     \
                                         cAttr.addChild(aExport##code);                                                \
                                         addAttribute(aExport##code);                                                  \
                                         attributeAffects(source, aExport);                                            \
                                         attributeAffects(aExport##code, aExport);

#define FIXEDINTATTR(code, value)  aExport##code = nAttr.create( #code , "export"#code , MFnNumericData::kLong); \
                                         nAttr.setStorable(false);                                                     \
                                         cAttr.addChild(aExport##code);                                                \
                                         addAttribute(aExport##code);                                                  \
                                         nAttr.setDefault(value);                                                      \
                                         attributeAffects(aExport##code, aExport);

#define COLORATTR(code, source) \
    aExport##code##R = nAttr.create( #code"R" , "export"#code"R" , MFnNumericData::kFloat); \
    aExport##code##G = nAttr.create( #code"G" , "export"#code"G" , MFnNumericData::kFloat); \
    aExport##code##B = nAttr.create( #code"B" , "export"#code"B" , MFnNumericData::kFloat); \
    aExport##code  = nAttr.create( #code     , "export"#code, aExport##code##R, aExport##code##G, aExport##code##B); \
    nAttr.setUsedAsColor(true);                                                     \
    nAttr.setStorable(false);                                                       \
    cAttr.addChild(aExport##code);                                                  \
    addAttribute(aExport##code);                                                    \
    attributeAffects(source, aExport);                                              \
    attributeAffects(aExport##code, aExport);             

#define FIXEDCOLORATTR(code) \
    aExport##code##R = nAttr.create( #code"R" , "export"#code"R" , MFnNumericData::kFloat); \
    aExport##code##G = nAttr.create( #code"G" , "export"#code"G" , MFnNumericData::kFloat); \
    aExport##code##B = nAttr.create( #code"B" , "export"#code"B" , MFnNumericData::kFloat); \
    aExport##code  = nAttr.create( #code     , "export"#code, aExport##code##R, aExport##code##G, aExport##code##B); \
    nAttr.setUsedAsColor(true);                                                     \
    nAttr.setStorable(false);                                                       \
    cAttr.addChild(aExport##code);                                                  \
    addAttribute(aExport##code);                                                    \
    attributeAffects(aExport##code, aExport);

#define FLOATATTR(code, source) aExport##code = nAttr.create( #code , "export"#code , MFnNumericData::kFloat); \
                                          nAttr.setStorable(false);                                                       \
                                          cAttr.addChild(aExport##code);                                                 \
                                          addAttribute(aExport##code);                                                   \
                                          attributeAffects(source, aExport);                                             \
                                          attributeAffects(aExport##code, aExport);

#define FIXEDFLOATATTR(code, value) aExport##code = nAttr.create( #code , "export"#code , MFnNumericData::kFloat); \
                                          nAttr.setStorable(false);                                                       \
                                          cAttr.addChild(aExport##code);                                                 \
                                          addAttribute(aExport##code);                                                   \
                                          nAttr.setDefault(value);                                                       \
                                          attributeAffects(aExport##code, aExport);
//
// Export some attributes
/////////////////////////////////////////////////////////////////////////////
void
${shadername}::exporterAttributes()
{
    MFnNumericAttribute nAttr; 
    MFnCompoundAttribute cAttr;

    // The exporter data
    aExport = cAttr.create("shaderExport", "sxp");
    addAttribute(aExport);

    //export color attributes
@CODE for( i = 0; i < AST->ObjectsCount( ); ++i ){
    @CODE Object * o = AST->objects[ i ];
    @CODE if( !o->IsType( "color" ) || !o->HasProperty( "fourCC" ) )
        @CODE  continue;
    @CODE if( !o->HasProperty( "attribute" ) || o->HasProperty( "attribute", "true" ) ){
    COLORATTR(${o->GetProperty( "fourCC" )}, a${o->name});
    @CODE }
    @CODE else{
    FIXEDCOLORATTR(${o->GetProperty( "fourCC" )});
    @CODE }
@CODE }

    //export float attributes
@CODE for( i = 0; i < AST->ObjectsCount( ); ++i ){
    @CODE Object * o = AST->objects[ i ];
    @CODE if( !o->IsType( "float" ) || !o->HasProperty( "fourCC" ) )
        @CODE  continue;
    @CODE if( !o->HasProperty( "attribute" ) || o->HasProperty( "attribute", "true" ) ){        
    FLOATATTR(${o->GetProperty( "fourCC" )}, a${o->name});
    @CODE }
    @CODE else{
    FIXEDFLOATATTR(${o->GetProperty( "fourCC" )}, ${o->GetProperty( "value" )} );
    @CODE }
@CODE }

    //export int attributes
@CODE for( i = 0; i < AST->ObjectsCount( ); ++i ){
    @CODE Object * o = AST->objects[ i ];
    @CODE if( !o->IsType( "int" ) || !o->HasProperty( "fourCC" ) )
        @CODE  continue;
    @CODE if( !o->HasProperty( "attribute" ) || o->HasProperty( "attribute", "true" ) ){        
    INTATTR(${o->GetProperty( "fourCC" )}, a${o->name});
    @CODE }
    @CODE else{
    FIXEDINTATTR(${o->GetProperty( "fourCC" )}, ${o->GetProperty( "value" )} );
    @CODE }
@CODE }

    //export bool attributes
@CODE for( i = 0; i < AST->ObjectsCount( ); ++i ){
    @CODE Object * o = AST->objects[ i ];
    @CODE if( !o->IsType( "bool" ) || !o->HasProperty( "fourCC" ) )
        @CODE  continue;
    @CODE if( !o->HasProperty( "attribute" ) || o->HasProperty( "attribute", "true" ) ){        
    INTATTR(${o->GetProperty( "fourCC" )}, a${o->name});
    @CODE }
    @CODE else{
        @CODE char value[ MAX_LINE_LEN ] = "0";
        @CODE if( o->HasProperty( "value", "true" ) ){
            @CODE sprintf( value, "1" );
        @CODE }
    
    FIXEDINTATTR(${o->GetProperty( "fourCC" )}, ${value});
    @CODE }
@CODE }

    //export enum attributes
@CODE for( i = 0; i < AST->ObjectsCount( ); ++i ){
    @CODE Object * o = AST->objects[ i ];
    @CODE if( !o->IsType( "enum" ) || !o->HasProperty( "fourCC" ) )
        @CODE  continue;
    @CODE if( !o->HasProperty( "attribute" ) || o->HasProperty( "attribute", "true" ) ){        
    INTATTR(${o->GetProperty( "fourCC" )}, a${o->name});
    @CODE }
    @CODE else{
    FIXEDINTATTR(${o->GetProperty( "fourCC" )}, ${o->GetProperty( "value" )} );
    @CODE }
@CODE }

}

//
// Compute all attributes for exporting:
/////////////////////////////////////////////////////////////////////////////
MStatus ${shadername}::compute(
const MPlug&      plug,
        MDataBlock& block ) 
{ 

    if( compute_output( plug, block ) == MS::kSuccess )
    {
        return MS::kSuccess;
    }
    //compute all bool attributes
@CODE for( i = 0; i < AST->ObjectsCount( ); ++i ){
    @CODE Object * o = AST->objects[ i ];
    @CODE if( !o->IsType( "bool" ) )
        @CODE  continue;
    @CODE if( o->HasProperty( "fourCC" ) && ( !o->HasProperty( "attribute" ) || o->HasProperty( "attribute", "true" ) ) ){
    else if(plug == aExport${o->GetProperty( "fourCC" )})
    {
        MDataHandle out${o->GetProperty( "fourCC" )}Handle = block.outputValue( aExport${o->GetProperty( "fourCC" )} );
        short& value = out${o->GetProperty( "fourCC" )}Handle.asShort();
        value = block.inputValue( a${o->name} ).asBool();
        out${o->GetProperty( "fourCC" )}Handle.setClean();
    }
    @CODE }
@CODE }
    //compute all float attributes
@CODE for( i = 0; i < AST->ObjectsCount( ); ++i ){
    @CODE Object * o = AST->objects[ i ];
    @CODE if( !o->IsType( "float" ) )
        @CODE  continue;
    @CODE if( o->HasProperty( "fourCC" ) && ( !o->HasProperty( "attribute" ) || o->HasProperty( "attribute", "true" ) ) ){
    else if (plug == aExport${o->GetProperty( "fourCC" )})
    {
        MDataHandle out${o->GetProperty( "fourCC" )}Handle = block.outputValue( aExport${o->GetProperty( "fourCC" )} );
        float& value = out${o->GetProperty( "fourCC" )}Handle.asFloat();
        value = block.inputValue ( a${o->name} ).asFloat();
        out${o->GetProperty( "fourCC" )}Handle.setClean();
    }
    @CODE }
@CODE }
    //compute all int attributes
@CODE for( i = 0; i < AST->ObjectsCount( ); ++i ){
    @CODE Object * o = AST->objects[ i ];
    @CODE if( !o->IsType( "int" ) )
        @CODE  continue;
    @CODE if( o->HasProperty( "fourCC" ) && ( !o->HasProperty( "attribute" ) || o->HasProperty( "attribute", "true" ) ) ){
    else if (plug == aExport${o->GetProperty( "fourCC" )})
    {
        MDataHandle out${o->GetProperty( "fourCC" )}Handle = block.outputValue( aExport${o->GetProperty( "fourCC" )} );
        short& value = out${o->GetProperty( "fourCC" )}Handle.asShort();
        value = block.inputValue ( a${o->name} ).asShort();
        out${o->GetProperty( "fourCC" )}Handle.setClean();
    }
    @CODE }
@CODE } 
    //compute all color attributes
@CODE for( i = 0; i < AST->ObjectsCount( ); ++i ){
    @CODE Object * o = AST->objects[ i ];
    @CODE if( !o->IsType( "color" ) )
        @CODE  continue;
    @CODE if( o->HasProperty( "fourCC" ) && ( !o->HasProperty( "attribute" ) || o->HasProperty( "attribute", "true" ) ) ){
    else if((plug == aExport${o->GetProperty( "fourCC" )}) || (plug == aExport${o->GetProperty( "fourCC" )}R) || (plug == aExport${o->GetProperty( "fourCC" )}G) || (plug == aExport${o->GetProperty( "fourCC" )}B))
    {
        MDataHandle out${o->GetProperty( "fourCC" )}Handle = block.outputValue( aExport${o->GetProperty( "fourCC" )} );
        MFloatVector& value = out${o->GetProperty( "fourCC" )}Handle.asFloatVector();
        value = block.inputValue( a${o->name} ).asFloatVector();
        out${o->GetProperty( "fourCC" )}Handle.setClean();
    }     
    @CODE }
@CODE }
    //compute all enum attributes
@CODE for( i = 0; i < AST->ObjectsCount( ); ++i ){
    @CODE Object * o = AST->objects[ i ];
    @CODE if( !o->IsType( "enum" ) )
        @CODE  continue;
    @CODE if( o->HasProperty( "fourCC" ) && ( !o->HasProperty( "attribute" ) || o->HasProperty( "attribute", "true" ) ) ){
    else if(plug == aExport${o->GetProperty( "fourCC" )})
    {
        MDataHandle outEnumHandle = block.outputValue( aExport${o->GetProperty( "fourCC" )} );
        short& value = outEnumHandle.asShort();
        value = block.inputValue( a${o->name} ).asShort();
        outEnumHandle.setClean();
    }
    @CODE }
@CODE }
    else 
    {
        return MS::kUnknownParameter;
    }
    return MS::kSuccess;
}
@CODE if( AST )
    @CODE delete AST;

