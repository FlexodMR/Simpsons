@perl sub max { my($a,$b) = @_; ($a>$b)?($a):($b);}
@perl sub pad { my($len,$str) = @_; sprintf("%-${len}s",$str); }
@perl %typemap = ( "string" => "char*", 
@perl              "longstring" => "char*", 
@perl              "COLOUR" => "unsigned long",
@perl              "FOURCC" => "unsigned long",
@perl              "ULONG" => "unsigned long",
@perl              "UBYTE" => "unsigned char",
@perl              "UWORD" => "unsigned short",
@perl              "WORD" =>  "short",
@perl              "float" => "float",
@perl            );
@perl $filename = $output_file;
@perl $filename =~ s#^.*/##;
@perl $filename =~ s/\..*//;
@perl my $upper_name = uc($filename);
// Automatically generated by Jeeves, don't edit.  Edit ${filename}.sc instead

#ifndef _${upper_name}_HPP_
#define _${upper_name}_HPP_

#ifdef WIN32
#pragma warning(disable:4786)
#endif

#include "tlDataChunk.hpp"

// things included by $filename.sc
@foreach hpp_list ($inc_level == 0 && ($hpp_name =~ m/\.hpp$/))
#include "$hpp_name"
@end .. hpp_list

@foreach class_list
class $class_name;
@perl $class{$class_name}++;
@end .. class_list
@foreach chunk_list
class $chunk_name;
@end .. chunk_list
@foreach struct_list          
struct $struct_name;
@end .. struct_list
@foreach struct_list ($inc_level == 0)

struct $struct_name
{
    // Data Members
@// compute longest type
@perl my $longest = length("void");
@foreach attr_list
    @perl my $type = $attr_type;
    @perl $type = $typemap{$attr_type} if defined $typemap{$attr_type}; 
    @perl $type .= "*" if defined $array;
    @perl $longest = max($longest, length($type));
@end
@foreach attr_list
    @perl my $type = $attr_type;
    @perl $type = $typemap{$attr_type} if defined $typemap{$attr_type}; 
    @perl $type .= "*" if defined $array;
    @perl $type = pad($longest, $type);
    @perl $name = lc($attr_name);
    $type $name;
@end

    // Methods
    ~$struct_name();    
    void Read(tlFile* f);
    void Write(tlFile* f);
    void Print(int print_index, int indent = 0);
    void PrintFormatted(int print_index, int indent = 0);

    const char* GetType() const;
    int         GetFieldCount() const;
    const char* GetFieldName(int) const;
    bool        GetFieldValue(char*, int) const;
    static bool GetFieldUpdatable();
    bool        SetFieldValue(const char* new_val);

    void Init();
    $struct_name& operator=(const $struct_name&); 
    int  operator==(const $struct_name& a);
};
@end .. struct_list
@foreach chunk_list ($inc_level == 0)

class $chunk_name : public tlDataChunk 
{
@// compute longest type
@perl my $longest = length("void");
@foreach attr_list ($attr_type ne "Chunk")
    @perl my $type = $attr_type;
    @perl $type = $typemap{$attr_type} if defined $typemap{$attr_type}; 
    @perl $type = "const " . $type if ((defined $class{$attr_type}) || (($attr_type eq "string") || ($attr_type eq "longstring")) && (!defined $array));
    @perl $type .= "*" if defined $array;
    @perl $type .= "&" if ((defined $class{$attr_type}) && (!defined $array));
    @perl $longest = max($longest, length($type));
@end
public:

    // Methods
    $chunk_name(); 
    $chunk_name(tlReadChunk16* ch); 
    $chunk_name(const $chunk_name& ch); 
    ~$chunk_name();

    void Init();

    $chunk_name& operator=(const $chunk_name&); 
    virtual bool operator==(const tlDataChunk&);    // Returns true if the chunks are identical
    virtual bool NameCompare(const tlDataChunk&);   // Returns true if the chunks are the
                                                                    // same type and have the same name

    static tlDataChunk* Create(tlReadChunk16* ch);
    virtual long Size( );
    void   Write(tlFile* f);
    void   Print(int indent = 0,
                     unsigned int printdepth = 0xffffffff,
                     unsigned int typemask = 0xffffffff);
    void   PrintFormatted(int indent = 0);

    const char* GetType() const;
    int         GetFieldCount() const;
    bool        GetFieldIsArray(int) const;
    int         GetFieldArrayCount(int) const;
    const char* GetFieldType(int) const;
    const char* GetFieldName(int) const;
    bool        GetFieldValue(int, char*, int) const;
    bool        GetFieldArrayValue(int, int, char*, int) const;
    bool        GetFieldUpdatable(int) const;
    bool        SetFieldValue(int, const char*);
    bool        SetFieldArrayValue(int, int, const char*);

    static tlDataChunk* LoadSubChunk(tlFile* f);
    tlDataChunk* Copy(); 

    virtual int SortPriority() {return ${chunk_name}::sortPriority;}

    // Accessor Methods;
@foreach attr_list ($attr_type ne "Chunk")
    @perl my $attr, $void;
    @perl my $type = $attr_type;
    @perl $type = $typemap{$attr_type} if defined $typemap{$attr_type}; 
    @perl $type = "const " . $type if ((defined $class{$attr_type}) || (($attr_type eq "string") || ($attr_type eq "longstring")) && (!defined $array));
    @perl $type .= "*" if defined $array;
    @perl $type .= "&" if ((defined $class{$attr_type}) && (!defined $array));
    @perl $attr = pad($longest, $type);
    @perl $void = pad($longest, "void");
    $attr $attr_name();
    $attr Get$attr_name() { return $attr_name(); }
    @if (defined $array)
    $void Set$attr_name($type, int count);
    @else
    $void Set$attr_name($type);
    @endif
@end .. attr_list

private:

    // Static data
    static int sortPriority;

    // Data Members
@foreach attr_list ($attr_type ne "Chunk")
    @perl my $type = $attr_type;
    @perl $type = $typemap{$attr_type} if defined $typemap{$attr_type}; 
    @perl $type .= "*" if defined $array;
    @perl $type = pad($longest, $type);
    @perl $name = lc($attr_name);
    $type $name;
@end

};
@end .. chunk_list

#endif

